<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","basil","dev","COP290-Rust","rustlab","cli","src","main.rs"],"content":"use std::env;\nuse std::io::{self, Write};\nuse std::time::Instant;\n\n// Import everything upfront\nuse sheet::function_ext;\nuse sheet::graph_ext::{self, StateSnapshot};\n\nstatic mut NUM_CELLS: usize = 0;\nstatic mut HAS_CYCLE: bool = false;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    let mut extended = false;\n    let mut r = 0;\n    let mut c = 0;\n\n    for arg in \u0026args[1..] {\n        if arg == \"-extended\" {\n            extended = true;\n        } else if r == 0 {\n            r = arg.parse().unwrap_or(0);\n        } else if c == 0 {\n            c = arg.parse().unwrap_or(0);\n        }\n    }\n\n    if r == 0 || c == 0 {\n        println!(\"Usage: {} \u003crows\u003e \u003ccolumns\u003e [-extended]\", args[0]);\n        return Ok(());\n    }\n\n    if extended {\n        run_extended(r, c)?;\n    } else {\n        run_standard(r, c);\n    }\n\n    Ok(())\n}\n\n// ✅ Snapshot function just for extended mode\nfn create_snapshot_extended(\n    arr: \u0026[function_ext::Cell],\n    formula_array: \u0026[graph_ext::Formula],\n    graph: \u0026graph_ext::Graph,\n) -\u003e graph_ext::StateSnapshot {\n    graph_ext::StateSnapshot {\n        arr: arr.to_owned(),\n        formula_array: formula_array.to_owned(),\n        graph: graph.clone(),\n    }\n}\n\n// ✅ Standard mode logic (unchanged)\nfn run_standard(r: usize, c: usize) {\n    use sheet::display::{printer, scroller};\n    use sheet::function::*;\n    use sheet::graph::{Formula, Graph};\n    use sheet::parser::parser;\n\n    let start = Instant::now();\n    let num_cells = r * c;\n    unsafe {\n        NUM_CELLS = num_cells;\n    }\n\n    let mut graph = Graph::new(num_cells);\n    let mut formula_array = vec![Formula::default(); num_cells];\n    let mut arr = vec![0; num_cells];\n\n    let mut currx = 0;\n    let mut curry = 0;\n    let mut output_disabled = false;\n\n    if !output_disabled {\n        printer(currx, curry, \u0026arr, c, r);\n    }\n\n    print!(\"[{:.6}] (ok) \", start.elapsed().as_secs_f64());\n\n    let mut input = String::new();\n\n    loop {\n        print!(\"\u003e \");\n        io::stdout().flush().unwrap();\n        input.clear();\n        io::stdin().read_line(\u0026mut input).unwrap();\n\n        let trimmed = input.trim();\n\n        if trimmed == \"q\" {\n            break;\n        }\n\n        let loop_start = Instant::now();\n        let mut status = 1;\n\n        match trimmed {\n            \"disable_output\" =\u003e {\n                output_disabled = true;\n                print!(\"[{:.6}] (ok) \", loop_start.elapsed().as_secs_f64());\n                continue;\n            }\n            \"enable_output\" =\u003e {\n                output_disabled = false;\n                printer(currx, curry, \u0026arr, c, r);\n                print!(\"[{:.6}] (ok) \", loop_start.elapsed().as_secs_f64());\n                continue;\n            }\n            _ =\u003e {\n                if ['w', 'a', 's', 'd'].contains(\u0026trimmed.chars().next().unwrap_or(' '))\n                    || trimmed.starts_with(\"scroll_to \")\n                {\n                    if scroller(trimmed, \u0026mut arr, \u0026mut currx, \u0026mut curry, c, r, \u0026mut graph) == -1 {\n                        status = -1;\n                    }\n                } else {\n                    status = parser(trimmed, c, r, \u0026mut arr, \u0026mut graph, \u0026mut formula_array[..]);\n                }\n            }\n        }\n\n        if !output_disabled {\n            printer(currx, curry, \u0026arr, c, r);\n        }\n\n        let elapsed = loop_start.elapsed().as_secs_f64();\n        unsafe {\n            if status \u003e 0 {\n                print!(\"[{:.6}] (ok) \", elapsed);\n            } else if HAS_CYCLE {\n                print!(\"[{:.6}] (Circular dependency detected) \", elapsed);\n                HAS_CYCLE = false;\n            } else if INVALID_RANGE {\n                print!(\"[{:.6}] (Invalid range) \", elapsed);\n                INVALID_RANGE = false;\n            } else {\n                print!(\"[{:.6}] (unrecognized command) \", elapsed);\n            }\n        }\n    }\n}\n\n// ✅ Extended mode logic with undo/redo and cell types\nfn run_extended(r: usize, c: usize) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    use sheet::display_ext::{printer, scroller};\n    use sheet::function_ext::Cell;\n    use sheet::graph_ext::{Formula, Graph, State};\n    use sheet::parser_ext::parser;\n\n    let num_cells = r * c;\n    let cols_i32 = c as i32;\n    let rows_i32 = r as i32;\n\n    let mut arr = vec![Cell::new_int(0); num_cells];\n    let mut formula_array = vec![Formula::default(); num_cells];\n    let mut graph = Graph::new(num_cells);\n    let mut state = State::new();\n    let mut undo_stack: Vec\u003cStateSnapshot\u003e = Vec::new();\n    let mut redo_stack: Vec\u003cStateSnapshot\u003e = Vec::new();\n    let mut currx = 0;\n    let mut curry = 0;\n    let mut output_enabled = true;\n\n    if output_enabled {\n        printer(currx, curry, \u0026arr, cols_i32, rows_i32);\n    }\n    print!(\"[0.0] (ok) \u003e \");\n    loop {\n        let start = Instant::now();\n\n        io::stdout().flush().unwrap();\n\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input)?;\n        let input = input.trim();\n\n        if input == \"q\" {\n            break;\n        }\n\n        let result = match input {\n            \"disable_output\" =\u003e {\n                output_enabled = false;\n                Ok(())\n            }\n            \"enable_output\" =\u003e {\n                output_enabled = true;\n                Ok(())\n            }\n            \"w\" | \"a\" | \"s\" | \"d\" =\u003e {\n                scroller(input, \u0026arr, \u0026mut currx, \u0026mut curry, cols_i32, rows_i32, \u0026graph)\n            }\n            _ if input.starts_with(\"scroll_to \") =\u003e {\n                let cmd = input.replacen(\"scroll_to \", \"\", 1);\n                scroller(\n                    \u0026format!(\"scroll_to {}\", cmd),\n                    \u0026arr,\n                    \u0026mut currx,\n                    \u0026mut curry,\n                    cols_i32,\n                    rows_i32,\n                    \u0026graph,\n                )\n            }\n            \"undo\" =\u003e {\n                if let Some(prev) = undo_stack.pop() {\n                    redo_stack.push(create_snapshot_extended(\u0026arr, \u0026formula_array, \u0026graph));\n                    arr = prev.arr;\n                    formula_array = prev.formula_array;\n                    graph = prev.graph;\n                    Ok(())\n                } else {\n                    Err(\"Nothing to undo\")\n                }\n            }\n            \"redo\" =\u003e {\n                if let Some(next) = redo_stack.pop() {\n                    undo_stack.push(create_snapshot_extended(\u0026arr, \u0026formula_array, \u0026graph));\n                    arr = next.arr;\n                    formula_array = next.formula_array;\n                    graph = next.graph;\n                    Ok(())\n                } else {\n                    Err(\"Nothing to redo\")\n                }\n            }\n            _ =\u003e {\n                undo_stack.push(create_snapshot_extended(\u0026arr, \u0026formula_array, \u0026graph));\n                if undo_stack.len() \u003e 5 {\n                    undo_stack.remove(0);\n                }\n                redo_stack.clear();\n                parser(\n                    input,\n                    cols_i32,\n                    rows_i32,\n                    \u0026mut arr,\n                    \u0026mut graph,\n                    \u0026mut formula_array,\n                    \u0026mut state,\n                )\n            }\n        };\n\n        let elapsed = start.elapsed().as_secs_f32();\n        match result {\n            Ok(_) =\u003e {\n                if output_enabled {\n                    printer(currx, curry, \u0026arr, cols_i32, rows_i32);\n                }\n                print!(\"[{:.1}] (ok) \u003e \", elapsed);\n            }\n            Err(e) =\u003e {\n                if output_enabled {\n                    printer(currx, curry, \u0026arr, cols_i32, rows_i32);\n                }\n                print!(\"[{:.1}] ({}) \u003e \", elapsed, e);\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","crdt","src","lib.rs"],"content":"// lib.rs\n//! A Conflict-free Replicated Data Type (CRDT) implementation for collaborative grid editing.\n//!\n//! This library provides the core data structures and event types needed for building\n//! a collaborative grid editing system. It implements CRDTs to ensure eventual consistency\n//! across multiple clients.\n//!\n//! # Examples\n//!\n//! ```rust\n//! use crdt::{Client, Event, InitEvent, GridUpdateEvent};\n//!\n//! // Create a new client\n//! let client = Client { name: \"Alice\".to_string() };\n//!\n//! // Create an initialization event\n//! let init_event = InitEvent { name: \"Alice\".to_string() };\n//!\n//! // Create a grid update event\n//! let grid_update = GridUpdateEvent {\n//!     grid: vec![],\n//!     sender: \"Alice\".to_string(),\n//! };\n//! ```\n//!\n//! # Event Types\n//!\n//! The library supports three main event types:\n//! - `INIT`: For client initialization\n//! - `GRID_UPDATE`: For grid content updates\n//! - `CLIENT_LIST`: For broadcasting client list updates\n\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\n/// Event type for broadcasting client list updates to all connected clients.\npub const CLIENT_LIST: \u0026str = \"CLIENT_LIST\";\n\n/// Event type for client initialization.\npub const INIT: \u0026str = \"INIT\";\n\n/// Event type for grid content updates.\npub const GRID_UPDATE: \u0026str = \"GRID_UPDATE\";\n\n/// Represents a client in the collaborative system.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Client {\n    /// The unique name/identifier of the client.\n    pub name: String,\n}\n\n/// A generic event structure that can represent any type of event in the system.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Event {\n    /// The type of event (e.g., INIT, GRID_UPDATE, CLIENT_LIST).\n    pub event_type: String,\n    /// The event-specific data payload.\n    pub data: Value,\n}\n\n// two types of events:\n// INIT event\n// GRID_UPDATE event\n\n/// Represents an initialization event sent when a new client joins the system.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct InitEvent {\n    /// The name of the client being initialized.\n    pub name: String,\n}\n\n/// Represents a grid update event containing the latest state of the grid.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct GridUpdateEvent {\n    /// The updated grid content.\n    pub grid: Vec\u003cRow\u003e,\n    /// The name of the client who sent the update.\n    pub sender: String,\n}\n\n/// Represents a client list update event broadcast to all clients.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct ClientListEvent {\n    /// The current list of all connected clients.\n    pub clients: Vec\u003cClient\u003e,\n}\n\n/// Represents a single column in the grid with its metadata.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Column {\n    /// The peer/client who last modified this column.\n    pub peer: String,\n    /// The timestamp of the last modification.\n    pub timestamp: usize,\n    /// The index of this column in the grid.\n    pub idx: usize,\n    /// The current value of the column.\n    pub value: String,\n}\n\n/// Represents a row in the grid containing multiple columns.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Row {\n    /// The index of this row in the grid.\n    pub idx: usize,\n    /// The columns contained in this row.\n    pub columns: Vec\u003cColumn\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","dummy_server","src","handlers.rs"],"content":"//! # Request Handlers\n//!\n//! This module contains handler functions for the various API endpoints exposed by\n//! the spreadsheet server. It implements the core functionality for retrieving sheet data,\n//! updating cells, processing queries, and performing undo/redo operations.\n#![deny(clippy::all)]\n\nuse axum::{\n    body::Bytes,\n    extract::{Json as ExtractJson, State},\n    response::IntoResponse,\n    Json,\n};\n\nuse crate::server_models::Sheet;\nuse crate::types::{AppState, QueryResponse, UpdateCellRequest, UpdateResponse};\n\nuse sheet::graph_ext::State as State1;\nuse sheet::parser_ext::*;\n\nuse crate::create_snapshot;\nuse crate::types::UndoRedoResponse;\n\nuse sheet::{\n    function_ext::{Cell, CellValue},\n    graph_ext::{Formula, Graph},\n};\n\n/// Retrieves the current spreadsheet data.\n///\n/// This handler returns the complete sheet data in a format suitable for\n/// client-side rendering.\n///\n/// # Arguments\n///\n/// * `state` - Application state containing the current sheet\n///\n/// # Returns\n///\n/// The current spreadsheet as a JSON response\npub async fn get_sheet(state: State\u003cAppState\u003e) -\u003e Json\u003cSheet\u003e {\n    let sheet = state.read().await.sheet.clone();\n    Json(sheet)\n}\n\n/// Handles requests to undo the last action.\n///\n/// This handler:\n/// 1. Removes the most recent state from the undo stack\n/// 2. Saves current state to the redo stack\n/// 3. Restores the previous state from the undo stack\n///\n/// # Arguments\n///\n/// * `state` - Application state containing undo/redo stacks and sheet data\n///\n/// # Returns\n///\n/// A JSON response indicating success or failure of the undo operation\npub async fn undo_action(State(state): State\u003cAppState\u003e) -\u003e Json\u003cUndoRedoResponse\u003e {\n    let mut app_state = state.write().await;\n\n    if let Some(prev) = app_state.undo_stack.pop() {\n        // Create temporary copies for snapshot creation\n        let cells_copy = app_state.cells.clone();\n        let formula_array_copy = app_state.formula_array.clone();\n        let graph_copy = app_state.graph.clone();\n\n        // Save current state to redo stack before reverting\n        app_state.redo_stack.push(create_snapshot(\u0026cells_copy, \u0026formula_array_copy, \u0026graph_copy));\n\n        // Restore previous state\n        app_state.cells = prev.arr;\n        app_state.formula_array = prev.formula_array;\n        app_state.graph = prev.graph;\n\n        // Also update the regular sheet model for API compatibility\n        let cells_clone = app_state.cells.clone();\n        update_simple_sheet_from_cells(\u0026mut app_state.sheet, \u0026cells_clone, 10, 10);\n\n        Json(UndoRedoResponse { success: true, message: \"Action undone successfully\".to_string() })\n    } else {\n        Json(UndoRedoResponse { success: false, message: \"Nothing to undo\".to_string() })\n    }\n}\n\n/// Handles requests to redo a previously undone action.\n///\n/// This handler:\n/// 1. Removes the most recent state from the redo stack\n/// 2. Saves current state to the undo stack\n/// 3. Restores the next state from the redo stack\n///\n/// # Arguments\n///\n/// * `state` - Application state containing undo/redo stacks and sheet data\n///\n/// # Returns\n///\n/// A JSON response indicating success or failure of the redo operation\npub async fn redo_action(State(state): State\u003cAppState\u003e) -\u003e Json\u003cUndoRedoResponse\u003e {\n    let mut app_state = state.write().await;\n\n    if let Some(next) = app_state.redo_stack.pop() {\n        // Create temporary copies for snapshot creation\n        let cells_copy = app_state.cells.clone();\n        let formula_array_copy = app_state.formula_array.clone();\n        let graph_copy = app_state.graph.clone();\n\n        // Save current state to undo stack before redoing\n        app_state.undo_stack.push(create_snapshot(\u0026cells_copy, \u0026formula_array_copy, \u0026graph_copy));\n\n        // Restore next state\n        app_state.cells = next.arr;\n        app_state.formula_array = next.formula_array;\n        app_state.graph = next.graph;\n\n        let cells_clone = app_state.cells.clone();\n        // Also update the regular sheet model for API compatibility\n        update_simple_sheet_from_cells(\u0026mut app_state.sheet, \u0026cells_clone, 10, 10);\n\n        Json(UndoRedoResponse { success: true, message: \"Action redone successfully\".to_string() })\n    } else {\n        Json(UndoRedoResponse { success: false, message: \"Nothing to redo\".to_string() })\n    }\n}\n\n/// Updates the simple sheet model from internal cell data.\n///\n/// This helper function synchronizes the sheet view model with the underlying cell data.\n///\n/// # Arguments\n///\n/// * `sheet` - The sheet model to update\n/// * `cells` - Source cell data\n/// * `rows` - Number of rows in the sheet\n/// * `cols` - Number of columns in the sheet\nfn update_simple_sheet_from_cells(sheet: \u0026mut Sheet, cells: \u0026[Cell], rows: usize, cols: usize) {\n    for r in 0..rows {\n        for c in 0..cols {\n            let idx = r * cols + c;\n            if idx \u003c cells.len() {\n                // Convert Cell to string and update the sheet\n                match \u0026cells[idx].value {\n                    CellValue::Int(i) =\u003e sheet.data[r][c].value = CellValue::String(i.to_string()),\n                    CellValue::Float(f) =\u003e {\n                        sheet.data[r][c].value = CellValue::String(f.to_string())\n                    }\n                    CellValue::String(s) =\u003e sheet.data[r][c].value = CellValue::String(s.clone()),\n                }\n            }\n        }\n    }\n}\n\n/// Updates a specific cell in the spreadsheet.\n///\n/// This handler processes cell update requests from the client,\n/// parsing and evaluating formulas if needed.\n///\n/// # Arguments\n///\n/// * `state` - Application state containing the current sheet\n/// * `payload` - Update request containing row, column, and new value\n///\n/// # Returns\n///\n/// A JSON response indicating success or failure of the update operation\npub async fn update_cell(\n    State(state): State\u003cAppState\u003e,\n    ExtractJson(payload): ExtractJson\u003cUpdateCellRequest\u003e,\n) -\u003e Json\u003cUpdateResponse\u003e {\n    // Parse row and column IDs from string to usize\n    let row_index = match payload.row_id.parse::\u003cusize\u003e() {\n        Ok(index) =\u003e index,\n        Err(_) =\u003e {\n            return Json(UpdateResponse {\n                success: false,\n                message: \"Invalid row ID format\".to_string(),\n            })\n        }\n    };\n\n    let col_index = match payload.column_id.parse::\u003cusize\u003e() {\n        Ok(index) =\u003e index,\n        Err(_) =\u003e {\n            return Json(UpdateResponse {\n                success: false,\n                message: \"Invalid column ID format\".to_string(),\n            })\n        }\n    };\n\n    let mut app_state = state.write().await;\n    let cols = app_state.sheet.data[0].len();\n\n    // Calculate 1D index from row and column\n    let cell_index = row_index * cols + col_index;\n\n    // Check if the indices are valid\n    if row_index \u003e= app_state.sheet.data.len()\n        || col_index \u003e= app_state.sheet.data[0].len()\n        || cell_index \u003e= app_state.cells.len()\n    {\n        return Json(UpdateResponse {\n            success: false,\n            message: \"Cell indices out of bounds\".to_string(),\n        });\n    }\n\n    // Try to parse the input value and determine its type\n    if let Ok(int_val) = payload.value.parse::\u003ci32\u003e() {\n        // It's an integer\n        app_state.cells[cell_index] = Cell::new_int(int_val);\n        app_state.sheet.data[row_index][col_index].value = CellValue::Int(int_val);\n    } else if let Ok(float_val) = payload.value.parse::\u003cf64\u003e() {\n        // It's a float\n        app_state.cells[cell_index] = Cell::new_float(float_val);\n        app_state.sheet.data[row_index][col_index].value = CellValue::Float(float_val);\n    } else if payload.value.contains(\"=\") {\n        // It's a formula - parse and evaluate it\n        let mut cells_clone = app_state.cells.clone();\n        let mut formula_array_clone = app_state.formula_array.clone();\n        let mut graph_clone = app_state.graph.clone();\n        let mut state_clone = app_state.state.clone();\n        match cell_parser(\n            \u0026payload.value,\n            cols as i32,\n            app_state.sheet.data.len() as i32,\n            \u0026mut cells_clone,\n            \u0026mut graph_clone,\n            \u0026mut formula_array_clone,\n            \u0026mut state_clone,\n        ) {\n            Ok(_) =\u003e {\n                // Formula processed successfully\n                // Update the actual state with the modified clones\n                app_state.cells = cells_clone;\n                app_state.formula_array = formula_array_clone;\n                app_state.graph = graph_clone;\n                app_state.state = state_clone;\n\n                // Also update the display sheet\n                match \u0026app_state.cells[cell_index].value {\n                    CellValue::Int(i) =\u003e {\n                        app_state.sheet.data[row_index][col_index].value = CellValue::Int(*i)\n                    }\n                    CellValue::Float(f) =\u003e {\n                        app_state.sheet.data[row_index][col_index].value = CellValue::Float(*f)\n                    }\n                    CellValue::String(s) =\u003e {\n                        app_state.sheet.data[row_index][col_index].value =\n                            CellValue::String(s.clone())\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                return Json(UpdateResponse {\n                    success: false,\n                    message: format!(\"Formula error: {}\", e),\n                });\n            }\n        }\n    } else {\n        // It's a string\n        app_state.cells[cell_index] = Cell::new_string(payload.value.clone());\n        app_state.sheet.data[row_index][col_index].value = CellValue::String(payload.value.clone());\n    }\n\n    // Return success response\n    Json(UpdateResponse { success: true, message: \"Cell updated successfully\".to_string() })\n}\n\n/// Parses and evaluates a cell formula.\n///\n/// This function handles different types of formulas:\n/// - Simple values (e.g., =10)\n/// - Arithmetic expressions (e.g., =A1+B2)\n/// - Functions (e.g., =SUM(A1:B3))\n///\n/// # Arguments\n///\n/// * `a` - The formula string\n/// * `c` - Number of columns in the sheet\n/// * `r` - Number of rows in the sheet\n/// * `arr` - Array of cells to update\n/// * `graph` - Dependency graph\n/// * `formula_array` - Array of formulas\n/// * `state` - Parser state\n///\n/// # Returns\n///\n/// Result indicating success or an error message\npub fn cell_parser(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State1,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    // Placeholder for the actual cell parser function\n    let pos_equalto = a.find('=').ok_or(\"No equals sign found\")?;\n    let pos_end = a.len();\n\n    let mut value = false;\n    let mut arth_exp = false;\n    let mut func = false;\n    let mut found_digit = false;\n\n    for ch in a[pos_equalto + 1..pos_end].chars() {\n        if ch == '(' {\n            func = true;\n            break;\n        }\n        if is_digit(ch) {\n            found_digit = true;\n        }\n        if \"+-*/\".contains(ch) \u0026\u0026 found_digit {\n            arth_exp = true;\n            break;\n        }\n    }\n\n    if !func \u0026\u0026 !arth_exp {\n        value = true;\n    }\n\n    if func \u0026\u0026 arth_exp {\n        return Err(\"Invalid input: Cannot mix function and arithmetic\");\n    }\n\n    if value {\n        print!(\" [DEBUG] Value function: \");\n        value_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?;\n    } else if arth_exp {\n        arth_op(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?;\n    } else if func {\n        let func_name = \u0026a[pos_equalto + 1..a[pos_equalto..].find('(').unwrap() + pos_equalto];\n        // println!(\"[DEBUG] Function name: {}\", func_name);\n        match func_name {\n            \"MIN\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 9)?\n            }\n            \"MAX\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 10)?\n            }\n            \"AVG\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 11)?\n            }\n            \"SUM\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 12)?\n            }\n            \"STDEV\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 13)?\n            }\n            \"SLEEP\" =\u003e sleep_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?,\n\n            _ =\u003e return Err(\"Unknown function\"),\n        }\n    }\n\n    Ok(())\n}\n\n/// Processes query commands sent from the client.\n///\n/// This handler parses and executes commands like formulas,\n/// functions, and other operations on the spreadsheet data.\n///\n/// # Arguments\n///\n/// * `state` - Application state containing the current sheet\n/// * `body` - Raw request body containing the query string\n///\n/// # Returns\n///\n/// A JSON response with the result of the executed query\npub async fn process_query(State(state): State\u003cAppState\u003e, body: Bytes) -\u003e impl IntoResponse {\n    // Convert bytes to string\n    let query_string = match String::from_utf8(body.to_vec()) {\n        Ok(s) =\u003e s,\n        Err(_) =\u003e {\n            return Json(QueryResponse {\n                success: false,\n                message: \"Failed to parse query string\".to_string(),\n                result: None,\n            })\n        }\n    };\n\n    let mut app_state = state.write().await;\n    let cols = app_state.sheet.data[0].len();\n    let rows = app_state.sheet.data.len();\n\n    // Save current state for undo before modifying (for commands that modify state)\n    let query = query_string.trim();\n\n    let mut cells_clone = app_state.cells.clone();\n    let mut formula_array_clone = app_state.formula_array.clone();\n    let mut graph_clone = app_state.graph.clone();\n    let mut state_clone = app_state.state.clone();\n    // Process the query - for direct formula/command input\n    match parser(\n        query,\n        cols as i32,\n        rows as i32,\n        \u0026mut cells_clone,\n        \u0026mut graph_clone,\n        \u0026mut formula_array_clone,\n        \u0026mut state_clone,\n    ) {\n        Ok(_) =\u003e {\n            // Formula processed successfully\n            // Update the actual state with the modified clones\n            app_state.cells = cells_clone;\n            app_state.formula_array = formula_array_clone;\n            app_state.graph = graph_clone;\n            app_state.state = state_clone;\n\n            // Also update the display sheet\n            for r in 0..rows {\n                for c in 0..cols {\n                    let idx = r * cols + c;\n                    match \u0026app_state.cells[idx].value {\n                        CellValue::Int(i) =\u003e app_state.sheet.data[r][c].value = CellValue::Int(*i),\n                        CellValue::Float(f) =\u003e {\n                            app_state.sheet.data[r][c].value = CellValue::Float(*f)\n                        }\n                        CellValue::String(s) =\u003e {\n                            app_state.sheet.data[r][c].value = CellValue::String(s.clone())\n                        }\n                    }\n                }\n            }\n\n            // Formula processed successfully - continue with the existing code\n            Json(QueryResponse {\n                success: true,\n                message: \"Formula executed successfully\".to_string(),\n                result: None,\n            })\n        }\n        Err(e) =\u003e Json(QueryResponse {\n            success: false,\n            message: format!(\"Formula error: {}\", e),\n            result: None,\n        }),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","dummy_server","src","main.rs"],"content":"//! # Rust Spreadsheet Backend Server\n//!\n//! This module provides the HTTP server implementation for the Rust Spreadsheet application.\n//! It handles API endpoints for spreadsheet operations, state management, and client communication.\n\nmod handlers;\nmod server_models;\nmod types;\n\nuse axum::{\n    routing::{get, post},\n    Router,\n};\nuse sheet::function_ext::Cell;\nuse sheet::graph_ext::StateSnapshot;\nuse sheet::graph_ext::{Formula, Graph, State};\nuse std::{net::SocketAddr, sync::Arc};\nuse tokio::sync::RwLock;\nuse tower_http::cors::{Any, CorsLayer};\n\nuse handlers::{get_sheet, process_query, redo_action, undo_action, update_cell};\nuse server_models::Sheet;\nuse types::ExtendedState;\n\n/// Creates a snapshot of the current spreadsheet state for undo/redo functionality.\n///\n/// This function captures all data necessary to restore the sheet to a previous state,\n/// including cells, formulas, and dependency graph.\n///\n/// # Arguments\n///\n/// * `arr` - The array of cells representing the current sheet data\n/// * `formula_array` - The array of formulas associated with cells\n/// * `graph` - The dependency graph tracking relationships between cells\n///\n/// # Returns\n///\n/// A `StateSnapshot` containing clones of all state components\nfn create_snapshot(arr: \u0026[Cell], formula_array: \u0026[Formula], graph: \u0026Graph) -\u003e StateSnapshot {\n    StateSnapshot {\n        arr: arr.to_owned(),\n        formula_array: formula_array.to_owned(),\n        graph: graph.clone(),\n    }\n}\n\n/// Application entry point - initializes and runs the HTTP server.\n///\n/// This function:\n/// 1. Sets up the initial spreadsheet state\n/// 2. Configures API endpoints and CORS policy\n/// 3. Starts the HTTP server on the specified address\n///\n/// The server provides endpoints for:\n/// - Getting the sheet data\n/// - Updating individual cells\n/// - Processing queries\n/// - Undo/redo operations\n#[tokio::main]\nasync fn main() {\n    // Initialize the sheet with default values\n    let r = 10;\n    let c = 10;\n    let num_cells = r * c;\n\n    // Initialize extended state components\n    let cells = vec![Cell::new_int(0); num_cells];\n\n    // Initialize regular sheet model for API compatibility\n    let sheet = Sheet::new(10, 10);\n    let num_cells = r * c;\n\n    let formula_array = vec![Formula::default(); num_cells];\n    let graph = Graph::new(num_cells);\n    let state = State::new();\n    let undo_stack: Vec\u003cStateSnapshot\u003e = Vec::new();\n    let redo_stack: Vec\u003cStateSnapshot\u003e = Vec::new();\n\n    // Create the extended state with all components\n    let extended_state = ExtendedState {\n        sheet: sheet.clone(),\n        cells: cells.clone(),\n        formula_array: formula_array.clone(),\n        graph: graph.clone(),\n        state: state.clone(),\n        undo_stack,\n        redo_stack,\n    };\n    let app_state = Arc::new(RwLock::new(extended_state));\n\n    // Create a CORS layer that allows any origin\n    let cors = CorsLayer::new().allow_origin(Any).allow_methods(Any).allow_headers(Any);\n\n    // Add the CORS layer to your router\n    let app = Router::new()\n        .route(\"/sheet\", get(get_sheet))\n        .route(\"/update-cell\", post(update_cell))\n        .route(\"/api/query\", post(process_query))\n        .route(\"/api/undo\", post(undo_action)) // New endpoint for undo\n        .route(\"/api/redo\", post(redo_action)) // New endpoint for redo\n        .with_state(app_state)\n        .layer(cors);\n\n    let addr = SocketAddr::from(([127, 0, 0, 1], 3001));\n    println!(\"✅ Server running at http://{}\", addr);\n    println!(\"🔄 Cell update endpoint available at http://{}/update-cell\", addr);\n    println!(\"📝 Query endpoint available at http://{}/api/query\", addr);\n    println!(\"↩️ Undo endpoint available at http://{}/api/undo\", addr);\n    println!(\"↪️ Redo endpoint available at http://{}/api/redo\", addr);\n\n    axum::serve(tokio::net::TcpListener::bind(addr).await.unwrap(), app).await.unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","dummy_server","src","server_models.rs"],"content":"//! # Server Models\n//!\n//! This module defines the data structures used by the server to represent\n//! the spreadsheet state. These models are serializable for client-server communication.\n\nuse serde::{Deserialize, Serialize};\nuse sheet::function_ext::Cell;\n\n/// Represents a spreadsheet with rows and columns of cells.\n///\n/// This structure is the primary model for maintaining and transmitting\n/// the grid of cells that make up the spreadsheet data.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct Sheet {\n    /// The two-dimensional grid of cells that stores the spreadsheet data.\n    pub data: Vec\u003cVec\u003cCell\u003e\u003e,\n}\n#[allow(dead_code)]\nimpl Sheet {\n    /// Creates a new spreadsheet with the specified number of rows and columns.\n    ///\n    /// All cells are initialized with integer value 0.\n    ///\n    /// # Arguments\n    ///\n    /// * `rows` - The number of rows in the sheet\n    /// * `cols` - The number of columns in the sheet\n    ///\n    /// # Returns\n    ///\n    /// A new `Sheet` instance with the specified dimensions\n    pub fn new(rows: usize, cols: usize) -\u003e Self {\n        Self { data: vec![vec![Cell::new_int(0); cols]; rows] }\n    }\n\n    /// Returns a reference to the grid of cells.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the two-dimensional vector of cells\n    pub fn get_data(\u0026self) -\u003e \u0026Vec\u003cVec\u003cCell\u003e\u003e {\n        \u0026self.data\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","dummy_server","src","types.rs"],"content":"//! # Type Definitions\n//!\n//! This module defines the core data types used throughout the application,\n//! including state management structures, request and response formats,\n//! and API interfaces.\n\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nuse crate::server_models::Sheet;\nuse sheet::function_ext::Cell;\nuse sheet::graph_ext::{Formula, Graph, State, StateSnapshot};\n\n/// Enhanced state container for the spreadsheet application.\n///\n/// This structure maintains all aspects of the spreadsheet state, including:\n/// - The rendered sheet data\n/// - Cell values and formulas\n/// - Dependency tracking\n/// - History for undo/redo operations\n/// - Current cursor position\npub struct ExtendedState {\n    /// Sheet model for API compatibility with existing endpoints\n    pub sheet: Sheet,\n    /// Typed cells (int, float, string)\n    pub cells: Vec\u003cCell\u003e,\n    /// Cell formulas\n    pub formula_array: Vec\u003cFormula\u003e,\n    /// Dependency graph for formula evaluation\n    pub graph: Graph,\n    /// Global sheet state\n    pub state: State,\n    /// Stack of previous states for undo operations\n    pub undo_stack: Vec\u003cStateSnapshot\u003e,\n    /// Stack of undone states for redo operations\n    pub redo_stack: Vec\u003cStateSnapshot\u003e,\n}\n\n/// Thread-safe shared application state.\n///\n/// This type provides synchronized read/write access to the application state\n/// that can be safely shared across async tasks and API handlers.\npub type AppState = Arc\u003cRwLock\u003cExtendedState\u003e\u003e;\n\n/// Request payload for updating a cell value.\n///\n/// Contains the cell coordinates and the new value to set.\n#[derive(Serialize, Deserialize, Debug)]\npub struct UpdateCellRequest {\n    /// Row identifier (zero-based index as string)\n    pub row_id: String,\n    /// Column identifier (zero-based index as string)\n    pub column_id: String,\n    /// New value to set in the cell\n    pub value: String,\n}\n\n/// Response format for cell update operations.\n///\n/// Indicates whether the update was successful and provides a message.\n#[derive(Serialize, Deserialize, Debug)]\npub struct UpdateResponse {\n    /// Whether the operation was successful\n    pub success: bool,\n    /// Message describing the result or error\n    pub message: String,\n}\n\n/// Response format for query operations.\n///\n/// Includes success status, descriptive message, and optional result data.\n#[derive(Serialize, Deserialize, Debug)]\npub struct QueryResponse {\n    /// Whether the query was processed successfully\n    pub success: bool,\n    /// Message describing the result or error\n    pub message: String,\n    /// Optional result value from the query\n    pub result: Option\u003cString\u003e,\n}\n\n/// Response format for undo/redo operations.\n///\n/// Provides feedback about the success of history navigation.\n#[derive(Serialize, Deserialize, Debug)]\npub struct UndoRedoResponse {\n    /// Whether the undo/redo operation was successful\n    pub success: bool,\n    /// Message describing the result or error\n    pub message: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","cell_component.rs"],"content":"//! # Cell Component\n//!\n//! This module provides a component for individual spreadsheet cells with editing capabilities.\n//! It handles user interaction, cell value updates, and communication with the backend API.\n\nuse crate::context::{AppAction, AppContext};\nuse gloo::console::log;\nuse gloo_net::http::Request;\nuse wasm_bindgen::JsCast;\nuse wasm_bindgen_futures::spawn_local;\nuse web_sys::{FocusEvent, HtmlInputElement, InputEvent, KeyboardEvent};\nuse yew::prelude::*;\n\n/// Properties for the cell component.\n///\n/// Contains:\n/// - The current cell value\n/// - Row and column identifiers\n/// - API endpoint for updates\n#[derive(Properties, PartialEq)]\npub struct Props {\n    /// Current value displayed in the cell\n    pub value: String,\n    /// Row identifier (zero-based index)\n    pub row_id: String,\n    /// Column identifier (zero-based index)\n    pub column_id: String,\n    /// API endpoint for sending cell updates\n    pub api_url: String,\n}\n\n/// A component that represents an individual cell in the spreadsheet.\n///\n/// Features:\n/// - Click to edit in-place\n/// - Auto-focus on edit mode\n/// - Submit on enter or blur\n/// - Communicates with backend when cell value changes\n#[function_component(CellComponent)]\n#[allow(unused_variables)]\npub fn cell_component(props: \u0026Props) -\u003e Html {\n    let value = use_state(|| props.value.clone());\n    let is_editing = use_state(|| false);\n    let input_ref = use_node_ref(); // Add this line - use a node_ref instead\n\n    // Get the app context for triggering refreshes\n    let app_context = use_context::\u003cAppContext\u003e().expect(\"no ctx found\");\n\n    // Update the value if props change\n    {\n        let value = value.clone();\n        let props_value = props.value.clone();\n\n        use_effect_with(props.value.clone(), move |props_value| {\n            value.set(props_value.clone());\n            || ()\n        });\n    }\n\n    // Focus and select input when editing is enabled\n    {\n        let input_ref = input_ref.clone();\n        let is_editing = is_editing.clone();\n\n        use_effect_with(*is_editing, move |is_editing| {\n            if *is_editing {\n                if let Some(input) = input_ref.cast::\u003cHtmlInputElement\u003e() {\n                    let _ = input.focus();\n                    input.select();\n                }\n            }\n            || ()\n        });\n    }\n    let onclick = {\n        let is_editing = is_editing.clone();\n\n        Callback::from(move |_| {\n            is_editing.set(true);\n        })\n    };\n\n    // Handler for blur events on the input field.\n    //\n    // When the input loses focus:\n    // 1. Checks if the value has changed\n    // 2. If changed, sends an update to the backend API\n    // 3. Exits edit mode\n    let onblur = {\n        let value = value.clone();\n        let is_editing = is_editing.clone();\n        let row_id = props.row_id.clone();\n        let column_id = props.column_id.clone();\n        let api_url = props.api_url.clone();\n        let original_value = props.value.clone(); // Clone the original value here\n        let app_context = app_context.clone(); // Clone for the closure\n\n        Callback::from(move |_: FocusEvent| {\n            let current_value = (*value).clone();\n            let row_id = row_id.clone();\n            let column_id = column_id.clone();\n            let api_url = api_url.clone();\n            let app_context = app_context.clone(); // Clone for the async closure\n\n            // Only send update if the value has changed\n            if current_value != original_value {\n                spawn_local(async move {\n                    let payload = serde_json::json!({\n                        \"row_id\": row_id,\n                        \"column_id\": column_id,\n                        \"value\": current_value\n                    });\n\n                    // Create the request\n                    let request =\n                        Request::post(\u0026api_url).header(\"Content-Type\", \"application/json\");\n\n                    // Handle the body() Result\n                    let request_with_body =\n                        match request.body(serde_json::to_string(\u0026payload).unwrap()) {\n                            Ok(req) =\u003e req,\n                            Err(e) =\u003e {\n                                log!(\"Failed to set request body: {:?}\", e.to_string());\n                                return;\n                            }\n                        };\n\n                    // Send the request\n                    match request_with_body.send().await {\n                        Ok(_) =\u003e {\n                            // Trigger a refresh after successful cell update\n                            app_context.dispatch(AppAction::Refresh);\n                        }\n                        Err(e) =\u003e {\n                            log!(\"Error updating cell: {:?}\", e.to_string());\n                        }\n                    }\n                });\n            }\n\n            is_editing.set(false);\n        })\n    };\n\n    // Handler for keypress events.\n    //\n    // Handles special key behavior:\n    // - Enter key: Submits the edit by blurring the input field\n    let onkeypress = {\n        let is_editing = is_editing.clone();\n\n        Callback::from(move |e: KeyboardEvent| {\n            if e.key() == \"Enter\" {\n                e.prevent_default();\n                // Simulate blur to trigger the update\n                if let Some(target) = e.target() {\n                    if let Some(input) = target.dyn_ref::\u003cHtmlInputElement\u003e() {\n                        let _ = input.blur(); // Changed to handle the Result\n                    }\n                }\n            }\n        })\n    };\n\n    // Handler for input events.\n    //\n    // Updates the component's internal state as the user types.\n    let oninput = {\n        let value = value.clone();\n\n        Callback::from(move |e: InputEvent| {\n            if let Some(target) = e.target() {\n                if let Some(input) = target.dyn_ref::\u003cHtmlInputElement\u003e() {\n                    value.set(input.value());\n                }\n            }\n        })\n    };\n\n    html! {\n        \u003ctd style=\"border: 1px solid #ccc; padding: 8px; position: relative;\"\u003e\n            {\n                if *is_editing {\n                    html! {\n                        \u003cinput\n                            type=\"text\"\n                            value={(*value).clone()}\n                            {oninput}\n                            {onblur}\n                            {onkeypress}\n                            ref={input_ref}  // Use the node_ref here\n                            style=\"width: 100%; height: 100%; padding: 5px; border: none; outline: none; position: absolute; top: 0; left: 0; box-sizing: border-box;\"\n                        /\u003e\n                    }\n                } else {\n                    html! {\n                        \u003cdiv onclick={onclick} style=\"cursor: pointer; min-height: 20px;\"\u003e\n                            { (*value).clone() }\n                        \u003c/div\u003e\n                    }\n                }\n            }\n        \u003c/td\u003e\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","context.rs"],"content":"//! # Application Context Module\n//!\n//! This module defines the application state management and context for the spreadsheet.\n//! It provides a central state mechanism using Yew's reducer pattern for components\n//! to interact with shared application data.\n\nuse std::rc::Rc;\nuse yew::prelude::*;\n\n/// Represents the global application state.\n///\n/// This structure maintains state that needs to be shared across components,\n/// such as the refresh counter used to trigger UI updates.\n#[derive(Clone, PartialEq)]\npub struct AppState {\n    /// Counter that increments each time the UI needs to be refreshed.\n    /// Components can watch this value to detect when they should update.\n    pub refresh_counter: u32,\n}\n\nimpl Default for AppState {\n    /// Creates the default application state.\n    ///\n    /// # Returns\n    ///\n    /// A new `AppState` with initial values\n    fn default() -\u003e Self {\n        Self { refresh_counter: 0 }\n    }\n}\n\n/// Type alias for a handle to the application context.\n///\n/// This provides components with access to the application state and actions.\npub type AppContext = UseReducerHandle\u003cAppState\u003e;\n\n/// Actions that can be performed on the application state.\n///\n/// This enum represents the various ways components can update the shared state.\n#[derive(Clone)]\npub enum AppAction {\n    /// Action to trigger a refresh of the UI.\n    Refresh,\n}\n\nimpl Reducible for AppState {\n    type Action = AppAction;\n\n    /// Handles state transitions based on dispatched actions.\n    ///\n    /// # Arguments\n    ///\n    /// * `self` - The current application state\n    /// * `action` - The action to perform on the state\n    ///\n    /// # Returns\n    ///\n    /// A new version of the application state after applying the action\n    fn reduce(self: Rc\u003cSelf\u003e, action: Self::Action) -\u003e Rc\u003cSelf\u003e {\n        match action {\n            AppAction::Refresh =\u003e AppState { refresh_counter: self.refresh_counter + 1 }.into(),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","main.rs"],"content":"//! # Rust Spreadsheet Frontend\n//!\n//! This is the main module for the Rust Spreadsheet web application.\n//! It provides a browser-based spreadsheet interface built with Yew\n//! that communicates with a backend server for data processing.\n\nuse yew::prelude::*;\n\nmod cell_component;\nmod context;\nmod models;\nmod request_form;\nmod table_component;\n\nuse context::*;\nuse request_form::RequestForm;\nuse table_component::TableComponent;\n\n/// The root component of the Rust Spreadsheet application.\n///\n/// This component:\n/// - Initializes the application state\n/// - Sets up the main layout\n/// - Renders the spreadsheet table and request form\n#[function_component(App)]\nfn app() -\u003e Html {\n    // Create application state using Yew's reducer pattern\n    let app_state = use_reducer(AppState::default);\n\n    // Backend API endpoint for queries\n    let api_url = \"http://localhost:3001/api/query\".to_string();\n\n    html! {\n        \u003cContextProvider\u003cAppContext\u003e context={app_state.clone()}\u003e\n            \u003cdiv style=\"font-family: sans-serif; padding: 2rem;\"\u003e\n                \u003ch1 style=\"font-size: 2rem; margin-bottom: 1rem;\"\u003e{ \"🦀 Rust Spreadsheet\" }\u003c/h1\u003e\n                \u003cTableComponent /\u003e\n                \u003cRequestForm api_url={api_url} /\u003e\n            \u003c/div\u003e\n        \u003c/ContextProvider\u003cAppContext\u003e\u003e\n    }\n}\n\n/// Application entry point.\n///\n/// Sets up:\n/// - WebAssembly logging\n/// - Document title\n/// - Panic hook for better error reporting\n/// - Renders the root component\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n    gloo::utils::document().set_title(\"Rust Spreadsheet\");\n    console_error_panic_hook::set_once();\n    yew::Renderer::\u003cApp\u003e::new().render();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","models.rs"],"content":"//! # Data Models\n//!\n//! This module defines the core data structures used in the spreadsheet application.\n//! It provides a representation of the sheet and its cells that can be serialized\n//! and deserialized for communication with the backend.\n\nuse serde::{Deserialize, Serialize};\nuse sheet::function_ext::Cell;\n\n/// Represents a spreadsheet with rows and columns of cells.\n///\n/// This structure holds the entire grid of cells that make up the spreadsheet.\n/// It can be serialized for API communication and provides methods for creating\n/// and accessing the spreadsheet data.\n#[derive(Serialize, Deserialize, Debug, Clone)]\n\npub struct Sheet {\n    /// The two-dimensional grid of cells that stores the spreadsheet data.\n    pub data: Vec\u003cVec\u003cCell\u003e\u003e,\n}\n\n#[allow(dead_code)]\nimpl Sheet {\n    /// Creates a new spreadsheet with the specified number of rows and columns.\n    ///\n    /// All cells are initialized with integer value 0.\n    ///\n    /// # Arguments\n    ///\n    /// * `rows` - The number of rows in the sheet\n    /// * `cols` - The number of columns in the sheet\n    ///\n    /// # Returns\n    ///\n    /// A new `Sheet` instance with the specified dimensions\n    pub fn new(rows: usize, cols: usize) -\u003e Self {\n        Self { data: vec![vec![Cell::new_int(0); cols]; rows] }\n    }\n\n    /// Returns a reference to the grid of cells.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the two-dimensional vector of cells\n    pub fn get_data(\u0026self) -\u003e \u0026Vec\u003cVec\u003cCell\u003e\u003e {\n        \u0026self.data\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","request_form.rs"],"content":"//! # Request Form Component\n//!\n//! This module provides the form component that allows users to submit commands\n//! to the backend API and displays the responses.\n\nuse gloo_net::http::Request;\nuse wasm_bindgen_futures::spawn_local;\nuse web_sys::HtmlInputElement;\nuse yew::prelude::*;\n\nuse crate::context::{AppAction, AppContext};\n\n/// Properties for the RequestForm component.\n///\n/// Contains the API URL endpoint that the form will submit requests to.\n#[derive(Properties, PartialEq)]\npub struct RequestFormProps {\n    /// The API endpoint URL for sending query requests\n    pub api_url: String,\n}\n\n/// A form component for submitting commands to the backend.\n///\n/// This component provides:\n/// - A text input for command entry\n/// - A submit button to execute the command\n/// - A response display area for showing API results\n#[function_component(RequestForm)]\n#[allow(unused_variables)]\npub fn request_form(props: \u0026RequestFormProps) -\u003e Html {\n    let input_ref = use_node_ref();\n    let response = use_state(String::new);\n    let is_loading = use_state(|| false);\n\n    // Get the app context for triggering refreshes\n    let app_context = use_context::\u003cAppContext\u003e().expect(\"no ctx found\");\n\n    // Handler for form submission events.\n    //\n    // This callback:\n    // 1. Prevents default form submission\n    // 2. Gets the query text from the input\n    // 3. Sends the query to the API asynchronously\n    // 4. Updates the response state with the result\n    // 5. Triggers app refresh on success\n    let onsubmit = {\n        let input_ref = input_ref.clone();\n        let response = response.clone();\n        let api_url = props.api_url.clone();\n        let app_context = app_context.clone(); // Clone context for the closure\n\n        Callback::from(move |e: SubmitEvent| {\n            e.prevent_default();\n\n            if let Some(input) = input_ref.cast::\u003cHtmlInputElement\u003e() {\n                let query = input.value();\n                if !query.trim().is_empty() {\n                    let api_url = api_url.clone();\n                    let response = response.clone();\n                    let app_context = app_context.clone(); // Clone for the async closure\n\n                    spawn_local(async move {\n                        // Create the request with text/plain content type\n                        let request = Request::post(\u0026api_url).header(\"Content-Type\", \"text/plain\");\n\n                        // Handle the body() Result\n                        let request_with_body = match request.body(query) {\n                            Ok(req) =\u003e req,\n                            Err(e) =\u003e {\n                                response.set(format!(\"Failed to set request body: {:?}\", e));\n                                return;\n                            }\n                        };\n\n                        // Send the request\n                        match request_with_body.send().await {\n                            Ok(resp) =\u003e {\n                                // Parse the response as JSON\n                                match resp.json::\u003cserde_json::Value\u003e().await {\n                                    Ok(json) =\u003e {\n                                        // Format JSON nicely\n                                        match serde_json::to_string_pretty(\u0026json) {\n                                            Ok(formatted) =\u003e {\n                                                response.set(formatted);\n\n                                                // Trigger a refresh after successful operation\n                                                app_context.dispatch(AppAction::Refresh);\n                                            }\n                                            Err(e) =\u003e response\n                                                .set(format!(\"Error formatting JSON: {:?}\", e)),\n                                        }\n                                    }\n                                    Err(e) =\u003e {\n                                        response.set(format!(\"Error parsing response: {:?}\", e))\n                                    }\n                                }\n                            }\n                            Err(e) =\u003e response.set(format!(\"Request error: {:?}\", e)),\n                        }\n                    });\n\n                    input.set_value(\"\");\n                }\n            }\n        })\n    };\n\n    html! {\n        \u003cdiv style=\"margin-top: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;\"\u003e\n            \u003ch3\u003e{\"Command Center\"}\u003c/h3\u003e\n            \u003cform {onsubmit} style=\"display: flex; gap: 10px;\"\u003e\n                \u003cinput\n                    ref={input_ref}\n                    type=\"text\"\n                    placeholder=\"Enter your command here...\"\n                    style=\"flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px;\"\n                /\u003e\n                \u003cbutton\n                    type=\"submit\"\n                    style=\"padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;\"\n                \u003e\n                    {\"Execute\"}\n                \u003c/button\u003e\n            \u003c/form\u003e\n\n            \u003cdiv style=\"margin-top: 10px;\"\u003e\n                {\n                    if !(*response).is_empty() {\n                        html! {\n                            \u003cdiv style=\"padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: white;\"\u003e\n                                \u003ch4\u003e{\"Response:\"}\u003c/h4\u003e\n                                \u003cpre style=\"white-space: pre-wrap; overflow-wrap: break-word; background-color: #f5f5f5; padding: 10px; border-radius: 4px;\"\u003e\n                                    {\u0026*response}\n                                \u003c/pre\u003e\n                            \u003c/div\u003e\n                        }\n                    } else {\n                        html! {}\n                    }\n                }\n            \u003c/div\u003e\n        \u003c/div\u003e\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","frontend","src","table_component.rs"],"content":"//! # Table Component\n//!\n//! This module provides the spreadsheet grid component that displays cell data and\n//! allows for cell interaction.\n\nuse gloo::console::log;\nuse gloo::net::http::Request;\nuse wasm_bindgen_futures::spawn_local;\nuse yew::prelude::*;\n\n// mod cell_component;\nuse crate::cell_component::CellComponent;\nuse crate::context::AppContext;\nuse crate::models::*;\nuse sheet::function_ext::CellValue;\n\n/// The main spreadsheet table component.\n///\n/// This component:\n/// - Fetches sheet data from the backend\n/// - Displays the grid of cells with row and column headers\n/// - Refreshes when the application state changes\n#[function_component(TableComponent)]\npub fn table_component() -\u003e Html {\n    let sheet_state = use_state(|| None::\u003cSheet\u003e);\n    let error_state = use_state(|| None::\u003cString\u003e);\n\n    let app_context: UseReducerHandle\u003ccrate::context::AppState\u003e =\n        use_context::\u003cAppContext\u003e().expect(\"no ctx found\");\n\n    {\n        let sheet_state = sheet_state.clone();\n        let error_state = error_state.clone();\n        let refresh_counter = app_context.refresh_counter;\n\n        // Effect to fetch sheet data when the refresh counter changes\n        use_effect_with(refresh_counter, move |_| {\n            let sheet_state = sheet_state.clone();\n            let error_state = error_state.clone();\n\n            log!(\"Fetching sheet data... (refresh {})\", refresh_counter);\n            spawn_local(async move {\n                match Request::get(\"http://127.0.0.1:3001/sheet\").send().await {\n                    Ok(response) =\u003e {\n                        if response.status() == 200 {\n                            match response.json::\u003cSheet\u003e().await {\n                                Ok(sheet) =\u003e {\n                                    sheet_state.set(Some(sheet));\n                                    error_state.set(None);\n                                }\n                                Err(e) =\u003e {\n                                    error_state.set(Some(format!(\"Parse error: {}\", e)));\n                                }\n                            }\n                        } else {\n                            error_state.set(Some(format!(\"Server error: {}\", response.status())));\n                        }\n                    }\n                    Err(e) =\u003e {\n                        error_state.set(Some(format!(\"Request failed: {}\", e)));\n                    }\n                }\n            });\n            || ()\n        });\n    }\n\n    html! {\n        \u003cdiv\u003e\n        {\n            if let Some(error) = \u0026*error_state {\n                html! { \u003cp style=\"color: red;\"\u003e{ error }\u003c/p\u003e }\n            } else if let Some(sheet) = \u0026*sheet_state {\n                html! {\n                    \u003ctable style=\"border-collapse: collapse; width: 100%; text-align: center;\"\u003e\n                        \u003cthead\u003e\n                            \u003ctr\u003e\n                                \u003cth style=\"border: 1px solid #ccc; padding: 8px;\"\u003e{ \"↘\" }\u003c/th\u003e\n                                {\n                                    (0..sheet.data[0].len()).map(|c| html! {\n                                        \u003cth style=\"border: 1px solid #ccc; padding: 8px; background:rgb(7, 188, 152);\"\u003e\n                                            { column_label(c) }\n                                        \u003c/th\u003e\n                                    }).collect::\u003cHtml\u003e()\n                                }\n                            \u003c/tr\u003e\n                        \u003c/thead\u003e\n                        \u003ctbody\u003e\n                            {\n                                sheet.data.iter().enumerate().map(|(r, row)| {\n                                    html! {\n                                        \u003ctr\u003e\n                                            \u003ctd style=\"border: 1px solid #ccc; padding: 8px; background:rgb(7, 188, 152);\"\u003e{ r + 1 }\u003c/td\u003e\n                                            {\n                                                row.iter().enumerate().map(|(c, cell)| {\n                                                    let display_value = match \u0026cell.value {\n                                                        CellValue::Int(i) =\u003e i.to_string(),\n                                                        CellValue::Float(f) =\u003e f.to_string(),\n                                                        CellValue::String(s) =\u003e s.clone(),\n                                                    };\n\n                                                    html! {\n                                                        \u003cCellComponent\n                                                                value={display_value}\n                                                                row_id={r.to_string()}\n                                                                column_id={c.to_string()}\n                                                                api_url={\"http://127.0.0.1:3001/update-cell\".to_string()}\n                                                        /\u003e\n                                                    }\n                                                }).collect::\u003cHtml\u003e()\n                                            }\n                                        \u003c/tr\u003e\n                                    }\n                                }).collect::\u003cHtml\u003e()\n                            }\n                        \u003c/tbody\u003e\n                    \u003c/table\u003e\n                }\n            } else {\n                html! { \u003cp\u003e{ \"Loading...\" }\u003c/p\u003e }\n            }\n        }\n        \u003c/div\u003e\n    }\n}\n\n/// Converts a zero-based column index to an Excel-style column label (A, B, C, ..., Z, AA, AB, etc.)\n///\n/// # Arguments\n///\n/// * `index` - The zero-based index of the column\n///\n/// # Returns\n///\n/// A string representing the column label (e.g., 0 → \"A\", 25 → \"Z\", 26 → \"AA\")\npub fn column_label(mut index: usize) -\u003e String {\n    let mut label = String::new();\n    index += 1;\n    while index \u003e 0 {\n        index -= 1;\n        label.insert(0, (b'A' + (index % 26) as u8) as char);\n        index /= 26;\n    }\n    label\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","server","src","main.rs"],"content":"// server.rs\n//! A WebSocket server implementation for real-time collaborative grid editing.\n//!\n//! This server handles WebSocket connections from multiple clients, manages client state,\n//! and broadcasts grid updates to all connected clients.\n\nuse log::{info, warn};\nuse std::io::Error;\nuse std::{collections::HashMap, net::SocketAddr, sync::Arc};\nuse tokio::net::TcpListener;\nuse tokio::net::TcpStream;\n\nuse futures_util::{SinkExt, StreamExt};\nuse tokio::sync::{\n    RwLock,\n    mpsc::{UnboundedSender, unbounded_channel},\n};\n\nuse tokio_tungstenite::tungstenite::Message;\n\nuse crdt::{\n    CLIENT_LIST, Client, ClientListEvent, Event, GRID_UPDATE, GridUpdateEvent, INIT, InitEvent,\n};\n\n/// A type alias for the thread-safe collection of connected clients.\n/// Uses `Arc\u003cRwLock\u003cHashMap\u003e\u003e` to allow safe concurrent access from multiple tasks.\ntype Clients = Arc\u003cRwLock\u003cHashMap\u003cString, WsClient\u003e\u003e\u003e;\n\n/// Represents a connected WebSocket client.\n#[derive(Debug, Clone)]\npub struct WsClient {\n    /// The name of the client as provided during initialization.\n    pub name: String,\n    /// A channel sender used to send messages to this client.\n    pub sender: UnboundedSender\u003cString\u003e,\n}\n\n/// Handles the initialization of a new client connection.\n///\n/// # Arguments\n/// * `evt` - The initialization event containing the client's name\n/// * `clients` - The shared collection of connected clients\n/// * `sender` - The channel sender for this client\n/// * `client_id` - The shared reference to this client's ID\nasync fn handle_init(\n    evt: \u0026InitEvent,\n    clients: Clients,\n    sender: UnboundedSender\u003cString\u003e,\n    client_id: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n) {\n    let name = evt.name.to_owned();\n    *client_id.write().await = Some(name.clone());\n\n    // add to clients list\n    clients\n        .as_ref()\n        .write()\n        .await\n        .insert(name.clone(), WsClient { name: evt.name.to_owned(), sender: sender.clone() });\n\n    // send updated list of clients to all clients\n    let serialized = serde_json::to_string(\u0026Event {\n        event_type: CLIENT_LIST.to_string(),\n        data: serde_json::to_value(ClientListEvent {\n            clients: clients\n                .read()\n                .await\n                .clone()\n                .into_values()\n                .map(|c| Client { name: c.name })\n                .collect(),\n        })\n        .expect(\"Failed to serialize client list\"),\n    })\n    .expect(\"Failed to serialize client list message\");\n\n    clients.read().await.iter().for_each(|client| {\n        let _ = client.1.sender.send(serialized.clone());\n    });\n\n    info!(\"Client {} connected\", name);\n}\n\n/// Handles grid update events from clients and broadcasts them to other connected clients.\n///\n/// # Arguments\n/// * `evt` - The grid update event containing the new grid state\n/// * `clients` - The shared collection of connected clients\nasync fn handle_grid_update(evt: \u0026GridUpdateEvent, clients: Clients) {\n    let grid = evt.grid.clone();\n    let client_message = Event {\n        event_type: GRID_UPDATE.to_string(),\n        data: serde_json::to_value(GridUpdateEvent {\n            grid: grid.clone(),\n            sender: evt.sender.clone(),\n        })\n        .expect(\"Failed to serialize grid update message\"),\n    };\n\n    let serialized =\n        serde_json::to_string(\u0026client_message).expect(\"Failed to serialize grid update message\");\n\n    // send to each client in client list\n    clients.read().await.iter().for_each(|client| {\n        if client.0 != \u0026evt.sender {\n            let _ = client.1.sender.send(serialized.clone());\n        }\n    });\n\n    info!(\"Grid update sent to all clients except {}\", evt.sender);\n}\n\n/// Handles client disconnection and cleanup.\n///\n/// # Arguments\n/// * `clients` - The shared collection of connected clients\n/// * `client_id` - The shared reference to the disconnecting client's ID\n/// * `addr` - The socket address of the disconnecting client\nasync fn handle_close(clients: Clients, client_id: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e, addr: SocketAddr) {\n    if let Some(ref name) = *client_id.read().await {\n        clients.as_ref().write().await.remove(name); // remove client from list\n\n        // send new list to all clients\n        let serialized = serde_json::to_string(\u0026Event {\n            event_type: CLIENT_LIST.to_string(),\n            data: serde_json::to_value(ClientListEvent {\n                clients: clients\n                    .read()\n                    .await\n                    .clone()\n                    .into_values()\n                    .map(|c| Client { name: c.name })\n                    .collect(),\n            })\n            .expect(\"Failed to serialize client list\"),\n        })\n        .expect(\"Failed to serialize client list message\");\n\n        clients.read().await.iter().for_each(|client| {\n            let _ = client.1.sender.send(serialized.clone());\n        });\n\n        info!(\"Client {:?} disconnected at {}\", name, addr);\n    }\n}\n\n/// Accepts and handles a new WebSocket connection.\n///\n/// This function sets up the WebSocket connection, handles message routing,\n/// and manages the client's lifecycle.\n///\n/// # Arguments\n/// * `stream` - The TCP stream for the new connection\n/// * `clients` - The shared collection of connected clients\nasync fn accept_connection(stream: TcpStream, clients: Clients) {\n    // create a new websocket connection\n    let addr = stream.peer_addr().expect(\"Stream should have a peer address\");\n\n    info!(\"Client connected: {}\", addr);\n\n    // create a new websocket connection\n    let ws_stream = tokio_tungstenite::accept_async(stream)\n        .await\n        .expect(\"Error during the websocket handshake\");\n\n    info!(\"Websocket handshake successful: {}\", addr);\n\n    let (mut sender, mut receiver) = ws_stream.split();\n    let (tx, mut rx) = unbounded_channel::\u003cString\u003e();\n    let client_id: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e = Arc::new(RwLock::new(None));\n\n    loop {\n        tokio::select! {\n            msg = receiver.next() =\u003e {\n                match msg {\n                    Some(msg) =\u003e {\n                        let msg = msg.expect(\"Error parsing message\");\n                        if msg.is_text() {\n                            if let Ok(event) = serde_json::from_str::\u003cEvent\u003e(msg.to_text().expect(\"Error parsing message\")) {\n                                match event.event_type.as_str() {\n                                    INIT =\u003e {\n                                        if let Ok(evt) = serde_json::from_value::\u003cInitEvent\u003e(event.data) {\n                                            handle_init(\u0026evt, clients.clone(), tx.clone(), client_id.clone()).await;\n                                        }\n                                    },\n                                    GRID_UPDATE =\u003e {\n                                        if let Ok(evt) = serde_json::from_value::\u003cGridUpdateEvent\u003e(event.data) {\n                                            handle_grid_update(\u0026evt, clients.clone()).await;\n                                        }\n                                    },\n                                    event_type =\u003e {\n                                        warn!(\"Received unknown event: {}\", event_type);\n                                    }\n                                }\n                            }\n                        } else if msg.is_close() {\n                            handle_close(clients.clone(), client_id.clone(), addr).await;\n                            break; // client has gracefully closed the connection\n                        }\n                    }\n                    None =\u003e { // ungraceful close from client\n                        info!(\"Client disconnected: {}\", addr);\n                        break;\n                    }\n                }\n            },\n            Some(ev) = rx.recv() =\u003e {\n                sender.send(Message::Text(ev.to_owned())).await\n                    .expect(\"Failed to send message to client\");\n            }\n        }\n    }\n}\n\n/// The main entry point for the WebSocket server.\n///\n/// This function:\n/// 1. Initializes logging\n/// 2. Creates the shared client collection\n/// 3. Binds to the server port\n/// 4. Accepts and handles incoming connections\n///\n/// # Returns\n/// A `Result` indicating success or failure of the server operation.\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    // read port from command line arguments\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n\n    // default port is 3030\n    let port = if args.len() \u003e 1 { args[1].parse::\u003cu16\u003e().expect(\"Invalid port\") } else { 3030 };\n\n    // initialize an empty hashmap to store clients\n    info!(\"Initializing server...\");\n    let clients: Clients = Arc::new(RwLock::new(HashMap::new()));\n    let _ = env_logger::try_init();\n\n    info!(\"Starting server...\");\n    // bind to port 3030: this is server's listening port\n    let listener = TcpListener::bind(format!(\"127.0.0.1:{}\", port)).await.expect(\"Failed to bind\");\n\n    info!(\"Server is running on port {}\", port);\n\n    // accept connections\n    while let Ok((stream, _)) = listener.accept().await {\n        tokio::spawn(accept_connection(stream, clients.clone()));\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","display.rs"],"content":"use crate::graph::Graph;\nuse std::cmp::min;\n// use std::i32;\n\n/// Prints a 10×10 viewport of the spreadsheet from the current scroll position.\n///\n/// This version assumes the spreadsheet is stored as a flat `i32` array, where each cell is either a valid integer\n/// or `i32::MIN` to indicate an invalid cell.\n///\n/// # Arguments\n/// * `currx` - Current horizontal scroll offset (column index).\n/// * `curry` - Current vertical scroll offset (row index).\n/// * `arr` - Flat array of spreadsheet values (row-major order).\n/// * `c` - Total number of columns in the spreadsheet.\n/// * `r` - Total number of rows in the spreadsheet.\n///\n/// The function prints:\n/// - Column headers in Excel-style format (`A`, `B`, ..., `Z`, `AA`, `AB`, etc.).\n/// - Row numbers along the left edge.\n/// - Values from the spreadsheet grid, with `\"ERR\"` shown for invalid entries.\npub fn printer(currx: usize, curry: usize, arr: \u0026[i32], c: usize, r: usize) {\n    print!(\"      \");\n\n    let visible_cols = min(10, c.saturating_sub(currx));\n    for i in 0..visible_cols {\n        let mut val = currx + i + 1;\n        let mut s = Vec::new();\n\n        // Convert column number to Excel-style letter (e.g., 1 -\u003e A, 27 -\u003e AA)\n        while val \u003e 0 \u0026\u0026 s.len() \u003c 6 {\n            val -= 1;\n            s.push((b'A' + (val % 26) as u8) as char);\n            val /= 26;\n        }\n        s.reverse();\n        print!(\"{:\u003c10}\", s.iter().collect::\u003cString\u003e());\n    }\n    println!();\n\n    let visible_rows = min(10, r.saturating_sub(curry));\n    for j in 0..visible_rows {\n        print!(\"{:\u003c3}   \", curry + j + 1); // Print row number\n\n        for i in 0..visible_cols {\n            let idx = (currx + i) + c * (curry + j);\n            let value = arr[idx];\n\n            if value == i32::MIN {\n                print!(\"{:\u003c10}\", \"ERR\");\n            } else {\n                print!(\"{:\u003c10}\", value);\n            }\n        }\n        println!();\n    }\n}\n\n/// Scrolls the spreadsheet viewport based on user input.\n///\n/// Accepts basic WASD-style controls for navigating:\n/// - `\"w\"`: Scroll up\n/// - `\"a\"`: Scroll left\n/// - `\"s\"`: Scroll down\n/// - `\"d\"`: Scroll right\n///\n/// # Arguments\n/// * `a` - Scroll command (`\"w\"`, `\"a\"`, `\"s\"`, `\"d\"`).\n/// * `_arr` - Spreadsheet values (not used in current implementation).\n/// * `currx` - Mutable reference to current horizontal offset.\n/// * `curry` - Mutable reference to current vertical offset.\n/// * `c` - Total number of columns in the spreadsheet.\n/// * `r` - Total number of rows in the spreadsheet.\n/// * `_graph` - Reference to graph (not used, reserved for future dependency tracking).\n///\n/// # Returns\n/// * `0` on successful scroll or no movement (already at boundary).\n/// * `-1` if the command is unrecognized.\npub fn scroller(\n    a: \u0026str,\n    _arr: \u0026mut [i32],\n    currx: \u0026mut usize,\n    curry: \u0026mut usize,\n    c: usize,\n    r: usize,\n    _graph: \u0026mut Graph,\n) -\u003e i32 {\n    match a {\n        \"w\" =\u003e {\n            if *curry \u003c 10 {\n                if *curry \u003e 0 {\n                    *curry = 0;\n                } else {\n                    return 0;\n                }\n            } else {\n                *curry -= 10;\n            }\n        }\n        \"a\" =\u003e {\n            if *currx \u003c 10 {\n                if *currx \u003e 0 {\n                    *currx = 0;\n                } else {\n                    return 0;\n                }\n            } else {\n                *currx -= 10;\n            }\n        }\n        \"s\" =\u003e {\n            let remaining_rows = r.saturating_sub(*curry + 10);\n            if remaining_rows == 0 {\n                return 0;\n            } else {\n                *curry += min(10, remaining_rows);\n            }\n        }\n        \"d\" =\u003e {\n            let remaining_cols = c.saturating_sub(*currx + 10);\n            if remaining_cols == 0 {\n                return 0;\n            } else {\n                *currx += min(10, remaining_cols);\n            }\n        }\n        _ if a.starts_with(\"scroll_to \") =\u003e {\n            if let Some(cell) = crate::parser::cell_parser(a, c, r, 10, a.len() - 1, _graph) {\n                let row = cell / c;\n                let col = cell % c;\n\n                if row \u003c r \u0026\u0026 col \u003c c {\n                    *currx = col;\n                    *curry = row;\n                } else {\n                    return -1;\n                }\n            } else {\n                return -1;\n            }\n        }\n        _ =\u003e return -1, // Unknown command\n    }\n\n    0\n}\n","traces":[{"line":21,"address":[498882,498711,496112],"length":1,"stats":{"Line":1}},{"line":22,"address":[496215],"length":1,"stats":{"Line":2}},{"line":24,"address":[303897],"length":1,"stats":{"Line":1}},{"line":25,"address":[304113,303934],"length":1,"stats":{"Line":3}},{"line":26,"address":[304129,305594,305654],"length":1,"stats":{"Line":3}},{"line":27,"address":[305639],"length":1,"stats":{"Line":2}},{"line":30,"address":[305714,305670,306459,305771],"length":1,"stats":{"Line":5}},{"line":31,"address":[306334,306311,305777],"length":1,"stats":{"Line":3}},{"line":32,"address":[498733,498773],"length":1,"stats":{"Line":3}},{"line":33,"address":[306431],"length":1,"stats":{"Line":2}},{"line":35,"address":[305689,305822],"length":1,"stats":{"Line":2}},{"line":36,"address":[305837],"length":1,"stats":{"Line":1}},{"line":38,"address":[303999],"length":1,"stats":{"Line":1}},{"line":40,"address":[304049],"length":1,"stats":{"Line":1}},{"line":41,"address":[304210,304078,304154],"length":1,"stats":{"Line":3}},{"line":42,"address":[304234,304627],"length":1,"stats":{"Line":1}},{"line":44,"address":[304643,304600,304730],"length":1,"stats":{"Line":3}},{"line":45,"address":[304937,304746],"length":1,"stats":{"Line":1}},{"line":46,"address":[304966,304930,305008],"length":1,"stats":{"Line":2}},{"line":48,"address":[304976],"length":1,"stats":{"Line":1}},{"line":49,"address":[305305],"length":1,"stats":{"Line":1}},{"line":51,"address":[305024],"length":1,"stats":{"Line":1}},{"line":54,"address":[304683],"length":1,"stats":{"Line":1}},{"line":78,"address":[306480],"length":1,"stats":{"Line":3}},{"line":88,"address":[306609],"length":1,"stats":{"Line":3}},{"line":89,"address":[306674,307762,307811],"length":1,"stats":{"Line":1}},{"line":90,"address":[307741],"length":1,"stats":{"Line":1}},{"line":91,"address":[307804],"length":1,"stats":{"Line":0}},{"line":93,"address":[307783],"length":1,"stats":{"Line":1}},{"line":96,"address":[307767,307759,307713],"length":1,"stats":{"Line":0}},{"line":99,"address":[306646],"length":1,"stats":{"Line":2}},{"line":100,"address":[306733,307654,307703],"length":1,"stats":{"Line":1}},{"line":101,"address":[307633],"length":1,"stats":{"Line":1}},{"line":102,"address":[307696],"length":1,"stats":{"Line":0}},{"line":104,"address":[500095],"length":1,"stats":{"Line":1}},{"line":107,"address":[307651,307605,307659],"length":1,"stats":{"Line":0}},{"line":110,"address":[499121],"length":1,"stats":{"Line":2}},{"line":111,"address":[307475,307501,306792],"length":1,"stats":{"Line":2}},{"line":112,"address":[307493],"length":1,"stats":{"Line":1}},{"line":113,"address":[307517],"length":1,"stats":{"Line":0}},{"line":115,"address":[499957,500004],"length":1,"stats":{"Line":1}},{"line":118,"address":[306764],"length":1,"stats":{"Line":1}},{"line":119,"address":[307337,306862,307363],"length":1,"stats":{"Line":2}},{"line":120,"address":[307355],"length":1,"stats":{"Line":1}},{"line":121,"address":[307379],"length":1,"stats":{"Line":0}},{"line":123,"address":[307446,307400],"length":1,"stats":{"Line":1}},{"line":126,"address":[499250],"length":1,"stats":{"Line":1}},{"line":127,"address":[307002,306917],"length":1,"stats":{"Line":0}},{"line":128,"address":[307128,307091,307165],"length":1,"stats":{"Line":0}},{"line":129,"address":[307202,307157,307232],"length":1,"stats":{"Line":0}},{"line":131,"address":[307225,307277],"length":1,"stats":{"Line":0}},{"line":132,"address":[307302],"length":1,"stats":{"Line":0}},{"line":133,"address":[307305],"length":1,"stats":{"Line":0}},{"line":135,"address":[307248],"length":1,"stats":{"Line":0}},{"line":138,"address":[307099],"length":1,"stats":{"Line":0}},{"line":141,"address":[306888],"length":1,"stats":{"Line":1}},{"line":144,"address":[307308],"length":1,"stats":{"Line":1}}],"covered":43,"coverable":57},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","display_ext.rs"],"content":"use crate::function_ext::{Cell, CellValue};\nuse crate::graph_ext::Graph;\nuse crate::parser_ext::cell_parser;\nuse std::cmp::min;\n\n/// Prints a 10×10 view of the spreadsheet starting from the given coordinates.\n///\n/// # Arguments\n/// * `currx` - The starting column index (0-based) for the visible area.\n/// * `curry` - The starting row index (0-based) for the visible area.\n/// * `arr` - The flat array of [`Cell`] objects representing the spreadsheet.\n/// * `c` - Total number of columns in the spreadsheet.\n/// * `r` - Total number of rows in the spreadsheet.\n///\n/// The function prints a tabular view of up to 10 rows and columns. Column headers are displayed\n/// in Excel-style format (A, B, ..., Z, AA, AB, ...), and invalid cells show `ERR`.\n///\n/// This function is used to simulate viewport-like scrolling in a terminal-based spreadsheet UI.\npub fn printer(currx: i32, curry: i32, arr: \u0026[Cell], c: i32, r: i32) {\n    print!(\"      \");\n\n    let display_cols = min(10, c - currx);\n    for i in 0..display_cols {\n        let mut val = currx + i + 1;\n        let mut chars: Vec\u003cchar\u003e = Vec::new();\n        while val \u003e 0 {\n            val -= 1;\n            chars.push((b'A' + (val % 26) as u8) as char);\n            val /= 26;\n        }\n        let header: String = chars.into_iter().rev().collect();\n        print!(\"{:\u003c10}\", header);\n    }\n    println!();\n\n    let display_rows = min(10, r - curry);\n    for j in 0..display_rows {\n        print!(\"{:\u003c3}   \", curry + j + 1);\n        for i in 0..display_cols {\n            let value = \u0026arr[((currx + i) + c * (curry + j)) as usize];\n            if !value.is_valid {\n                print!(\"{:\u003c10}\", \"ERR\");\n            } else {\n                match \u0026value.value {\n                    CellValue::Int(i) =\u003e print!(\"{:\u003c10}\", i),\n                    CellValue::Float(f) =\u003e print!(\"{:\u003c10.2}\", f),\n                    CellValue::String(s) =\u003e {\n                        let truncated =\n                            if s.len() \u003e 10 { format!(\"{:.10}\", \u0026s[..10]) } else { s.clone() };\n                        print!(\"{:\u003c10}\", truncated);\n                    }\n                }\n            }\n        }\n        println!();\n    }\n}\n\n/// Handles scrolling logic for the spreadsheet viewport using directional commands or `scroll_to`.\n///\n/// # Arguments\n/// * `a` - Scroll command. Can be:\n///   - `\"w\"` - scroll up\n///   - `\"s\"` - scroll down\n///   - `\"a\"` - scroll left\n///   - `\"d\"` - scroll right\n///   - `\"scroll_to \u003ccell\u003e\"` - jump to a specific cell like `\"scroll_to A1\"`\n/// * `_arr` - Unused but passed in case of future validation or redraw triggers.\n/// * `currx` - Mutable reference to the current top-left column of the viewport.\n/// * `curry` - Mutable reference to the current top-left row of the viewport.\n/// * `c` - Total number of columns in the spreadsheet.\n/// * `r` - Total number of rows in the spreadsheet.\n/// * `_graph` - Currently unused, but may be used for recalculation dependencies or context.\n///\n/// # Returns\n/// * `Ok(())` if scroll was successful or allowed.\n/// * `Err(...)` if an unknown or malformed scroll command is passed.\n///\n/// This function updates `currx` and `curry` based on navigation input, ensuring they remain in bounds.\npub fn scroller(\n    a: \u0026str,\n    _arr: \u0026[Cell],\n    currx: \u0026mut i32,\n    curry: \u0026mut i32,\n    c: i32,\n    r: i32,\n    _graph: \u0026Graph,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    // let mut _flag = false;\n\n    match a {\n        \"w\" =\u003e {\n            if *curry \u003c 10 {\n                if *curry \u003e 0 {\n                    *curry = 0;\n                } else {\n                    // flag = true;\n                }\n            } else {\n                *curry -= 10;\n            }\n        }\n        \"d\" =\u003e {\n            let remaining_cols = c - *currx - 10;\n            if remaining_cols \u003c= 0 {\n                // flag = true;\n            } else if remaining_cols \u003c 10 {\n                *currx += remaining_cols;\n            } else {\n                *currx += 10;\n            }\n        }\n        \"a\" =\u003e {\n            if *currx \u003c 10 {\n                if *currx \u003e 0 {\n                    *currx = 0;\n                } else {\n                    // flag = true;\n                }\n            } else {\n                *currx -= 10;\n            }\n        }\n        \"s\" =\u003e {\n            let remaining_rows = r - *curry - 10;\n            if remaining_rows \u003c= 0 {\n                // flag = true;\n            } else if remaining_rows \u003c 10 {\n                *curry += remaining_rows;\n            } else {\n                *curry += 10;\n            }\n        }\n        s if s.starts_with(\"scroll_to \") =\u003e {\n            let parts: Vec\u003c\u0026str\u003e = s[9..].split_whitespace().collect();\n            if parts.len() != 1 {\n                return Err(\"Invalid scroll_to format\");\n            }\n            let cell = cell_parser(parts[0], c, r, 0, parts[0].len() - 1)?;\n            if cell \u003c 0 || cell \u003e= (c * r) {\n                // flag = true;\n            } else {\n                let start_row = cell / c;\n                let start_col = cell % c;\n                if start_row \u003e= r || start_col \u003e= c {\n                    // flag = true;\n                } else {\n                    *currx = start_col;\n                    *curry = start_row;\n                }\n            }\n        }\n        _ =\u003e return Err(\"Unknown scroll command\"),\n    }\n\n    Ok(())\n}\n","traces":[{"line":19,"address":[558416,561387],"length":1,"stats":{"Line":1}},{"line":20,"address":[229533],"length":1,"stats":{"Line":1}},{"line":22,"address":[229590,229659],"length":1,"stats":{"Line":3}},{"line":23,"address":[229780,233064,229636,229675],"length":1,"stats":{"Line":15}},{"line":24,"address":[232480,229794,232417],"length":1,"stats":{"Line":8}},{"line":25,"address":[232457],"length":1,"stats":{"Line":4}},{"line":26,"address":[562286,561493],"length":1,"stats":{"Line":8}},{"line":27,"address":[233093,232569,233073],"length":1,"stats":{"Line":8}},{"line":28,"address":[233080,233117],"length":1,"stats":{"Line":8}},{"line":29,"address":[233225,233274],"length":1,"stats":{"Line":4}},{"line":31,"address":[561638,561503],"length":1,"stats":{"Line":8}},{"line":32,"address":[232750,232699],"length":1,"stats":{"Line":8}},{"line":34,"address":[229715],"length":1,"stats":{"Line":4}},{"line":36,"address":[229760,229860,229818],"length":1,"stats":{"Line":8}},{"line":37,"address":[229876,229837,229928],"length":1,"stats":{"Line":12}},{"line":38,"address":[229946,230310],"length":1,"stats":{"Line":4}},{"line":39,"address":[230326,230412,230287],"length":1,"stats":{"Line":12}},{"line":40,"address":[230426,230649],"length":1,"stats":{"Line":4}},{"line":41,"address":[230624],"length":1,"stats":{"Line":4}},{"line":42,"address":[230665],"length":1,"stats":{"Line":2}},{"line":44,"address":[230951],"length":1,"stats":{"Line":2}},{"line":45,"address":[231024],"length":1,"stats":{"Line":3}},{"line":46,"address":[231322],"length":1,"stats":{"Line":1}},{"line":47,"address":[231632],"length":1,"stats":{"Line":1}},{"line":48,"address":[231640],"length":1,"stats":{"Line":1}},{"line":50,"address":[232085,232034],"length":1,"stats":{"Line":2}},{"line":55,"address":[230366],"length":1,"stats":{"Line":1}},{"line":80,"address":[234806,233328],"length":1,"stats":{"Line":10}},{"line":92,"address":[233435],"length":1,"stats":{"Line":11}},{"line":93,"address":[235386,233519],"length":1,"stats":{"Line":4}},{"line":94,"address":[235421,235362],"length":1,"stats":{"Line":3}},{"line":95,"address":[235415],"length":1,"stats":{"Line":1}},{"line":100,"address":[235391,235338,235384],"length":1,"stats":{"Line":2}},{"line":103,"address":[233472],"length":1,"stats":{"Line":8}},{"line":104,"address":[235134,233587,235186],"length":1,"stats":{"Line":0}},{"line":105,"address":[235175],"length":1,"stats":{"Line":0}},{"line":107,"address":[235206,235274,235309],"length":1,"stats":{"Line":0}},{"line":108,"address":[235247,235307,235314],"length":1,"stats":{"Line":0}},{"line":110,"address":[235219,235279,235272],"length":1,"stats":{"Line":0}},{"line":113,"address":[233533],"length":1,"stats":{"Line":8}},{"line":114,"address":[562665,564134],"length":1,"stats":{"Line":1}},{"line":115,"address":[235063,235122],"length":1,"stats":{"Line":1}},{"line":116,"address":[564163],"length":1,"stats":{"Line":0}},{"line":121,"address":[235039,235085,235092],"length":1,"stats":{"Line":0}},{"line":124,"address":[233610],"length":1,"stats":{"Line":7}},{"line":125,"address":[234887,233741,234835],"length":1,"stats":{"Line":4}},{"line":126,"address":[234876],"length":1,"stats":{"Line":2}},{"line":128,"address":[235010,234907,234975],"length":1,"stats":{"Line":3}},{"line":129,"address":[234948,235008,235015],"length":1,"stats":{"Line":0}},{"line":131,"address":[234920,234973,234980],"length":1,"stats":{"Line":2}},{"line":134,"address":[233671],"length":1,"stats":{"Line":5}},{"line":135,"address":[233793],"length":1,"stats":{"Line":4}},{"line":136,"address":[233887,233974],"length":1,"stats":{"Line":8}},{"line":137,"address":[234014],"length":1,"stats":{"Line":0}},{"line":139,"address":[563083,563005,563343,563818],"length":1,"stats":{"Line":10}},{"line":140,"address":[234415,234295,234375],"length":1,"stats":{"Line":9}},{"line":143,"address":[563596,563495],"length":1,"stats":{"Line":1}},{"line":144,"address":[234672,234582,234543],"length":1,"stats":{"Line":6}},{"line":145,"address":[234662,234740,234704],"length":1,"stats":{"Line":9}},{"line":148,"address":[234736],"length":1,"stats":{"Line":3}},{"line":149,"address":[234738],"length":1,"stats":{"Line":3}},{"line":153,"address":[233764],"length":1,"stats":{"Line":1}},{"line":156,"address":[234745],"length":1,"stats":{"Line":1}}],"covered":54,"coverable":63},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","function.rs"],"content":"//! # Spreadsheet Built-in Functions\n//!\n//! This module provides a set of core spreadsheet functions implemented in Rust. These functions operate\n//! over a 2D spreadsheet represented as a flat 1D array of `i32` values. Each function reads a specified\n//! rectangular range of cells, performs a calculation, and writes the result to a target cell.\n//!\n//! ## Supported Functions\n//! - `min_func`: Minimum value in a range\n//! - `max_func`: Maximum value in a range\n//! - `sum_func`: Total sum of values in a range\n//! - `avg_func`: Average (mean) of values in a range\n//! - `stdev_func`: Standard deviation of values in a range\n//! - `sleep_func`: Introduces a delay based on a cell value or a literal\n//!\n//! ## Architecture\n//! - Spreadsheet is stored in a flat array (`Vec\u003ci32\u003e`) indexed as `row * cols + col`\n//! - Dependency tracking is handled by a custom `Graph` structure\n//! - Formulas are stored in a separate array and referenced by index\n//! - Errors are tracked using a global `INVALID_RANGE` flag and sentinel value `i32::MIN`\n//!\n//! ## Example Usage\n//! ```text\n//! Input: \"A1 = SUM(B1:B3)\"\n//! Parsed as: write result to cell A1, sum values from B1 to B3\n//! ```\n\nuse crate::graph::{Formula, Graph};\nuse crate::parser::cell_parser;\nuse std::cmp::{max, min};\n// use std::i32;\n// use std::thread::sleep;\n// use std::time::Duration;\n/// Global flag to indicate if a function encountered an invalid range.\npub static mut INVALID_RANGE: bool = false;\n\nfn error_usize() -\u003e usize {\n    unsafe {\n        INVALID_RANGE = true;\n    }\n    0\n}\n\nfn error_range() -\u003e (usize, usize) {\n    unsafe {\n        INVALID_RANGE = true;\n    }\n    (0, 0)\n}\n\nfn error_return() -\u003e i32 {\n    unsafe {\n        INVALID_RANGE = true;\n    }\n    -1\n}\n/// Validates that `start` to `end` defines a proper left-to-right, top-to-bottom rectangular range.\nfn validate_range(start: usize, end: usize, cols: usize) -\u003e bool {\n    let (sr, sc) = (start / cols, start % cols);\n    let (er, ec) = (end / cols, end % cols);\n    sr \u003c er || (sr == er \u0026\u0026 sc \u003c= ec)\n}\n/// Calculates the standard deviation (rounded) from a slice of integers.\nfn std(values: \u0026[i32]) -\u003e i32 {\n    if values.len() \u003c= 1 {\n        return 0;\n    }\n    let mean = values.iter().sum::\u003ci32\u003e() as f64 / values.len() as f64;\n    let variance = values\n        .iter()\n        .map(|\u0026x| {\n            let diff = x as f64 - mean;\n            diff * diff\n        })\n        .sum::\u003cf64\u003e()\n        / values.len() as f64;\n    variance.sqrt().round() as i32\n}\n/// Parses a range of cells from a string (e.g., \"SUM(B1:C3)\") and returns the start and end indices.\nfn extract_range_cells(\n    a: \u0026str,\n    eq_idx: usize,\n    c: usize,\n    r: usize,\n    graph: \u0026mut Graph,\n) -\u003e Option\u003c(usize, usize)\u003e {\n    let open_paren = a[eq_idx..].find('(')? + eq_idx;\n    let close_paren = a[eq_idx..].find(')')? + eq_idx;\n    if close_paren \u003c= open_paren + 1 {\n        return None;\n    }\n    let colon_pos = a[open_paren + 1..].find(':')? + open_paren + 1;\n    let range_start = cell_parser(a, c, r, open_paren + 1, colon_pos - 1, graph)?;\n    let range_end = cell_parser(a, c, r, colon_pos + 1, close_paren - 1, graph)?;\n    if !validate_range(range_start, range_end, c) {\n        return None;\n    }\n    Some((range_start, range_end))\n}\n\n/// Computes the minimum value within a specified range and stores it in the target cell.\n/// Adds the formula and dependency to the graph for recalculation tracking.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn min_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    // Get the first cell (target) for the formula\n    let first_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n\n    // Extract the range (start and end for both rows and columns)\n    let (range_start, range_end) =\n        extract_range_cells(a, eq_idx, c, r, graph).unwrap_or_else(error_range);\n\n    // Add formula to the graph\n    Graph::add_formula(graph, first_cell, range_start, range_end, 9, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n\n    // Get the starting and ending row/column indices\n    let (start_row, start_col) = (range_start / c, range_start % c);\n    let (end_row, end_col) = (range_end / c, range_end % c);\n\n    let mut min_val = arr[range_start];\n\n    // Handle 1D range: If the range is a single column, loop only through rows\n    if start_col == end_col {\n        // 1D range (same column), loop through rows\n        for row in start_row..=end_row {\n            let idx = row * c + start_col; // Iterate through rows, same column\n            min_val = min(min_val, arr[idx]);\n        }\n    } else {\n        // 2D range (across multiple columns), loop through both rows and columns\n        for row in start_row..=end_row {\n            for col in start_col..=end_col {\n                let idx = row * c + col; // Convert (row, col) to 1D index\n                min_val = min(min_val, arr[idx]);\n            }\n        }\n    }\n\n    arr[first_cell] = min_val;\n    1\n}\n/// Computes the maximum value within a specified range and stores it in the target cell.\n/// Adds the formula and dependency to the graph for recalculation tracking.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn max_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    // Get the first cell (target) for the formula\n    let first_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n\n    // Extract the 2D range (start and end for both rows and columns)\n    let (range_start, range_end) =\n        extract_range_cells(a, eq_idx, c, r, graph).unwrap_or_else(error_range);\n\n    // Add formula to the graph\n    Graph::add_formula(graph, first_cell, range_start, range_end, 10, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n\n    // Determine 2D range bounds\n    let (start_row, start_col) = (range_start / c, range_start % c);\n    let (end_row, end_col) = (range_end / c, range_end % c);\n\n    let mut max_value = arr[range_start];\n\n    // Iterate over the 2D range\n    for row in start_row..=end_row {\n        for col in start_col..=end_col {\n            let idx = row * c + col;\n            // println!(\"idx: {}, arr[idx]: {}\", idx, arr[idx]);\n            max_value = max(max_value, arr[idx]);\n        }\n    }\n\n    // Store the maximum value in the first cell\n    arr[first_cell] = max_value;\n    // println!(\"max_value: {}\", max_value);\n    // println!(\"arr[first_cell]: {}\", arr[first_cell]);\n    1\n}\n\n/// Computes the total sum of values within a specified range and stores it in the target cell.\n/// Adds the formula and dependency to the graph for recalculation tracking.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn sum_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    let first_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n    let (range_start, range_end) =\n        extract_range_cells(a, eq_idx, c, r, graph).unwrap_or_else(error_range);\n    Graph::add_formula(graph, first_cell, range_start, range_end, 12, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n    let sum: i32 = (range_start..=range_end).map(|idx| arr[idx]).sum();\n    arr[first_cell] = sum;\n    1\n}\n/// Computes the average value within a specified range and stores it in the target cell.\n/// Adds the formula and dependency to the graph for recalculation tracking.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn avg_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    let first_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n    let (range_start, range_end) =\n        extract_range_cells(a, eq_idx, c, r, graph).unwrap_or_else(error_range);\n\n    Graph::add_formula(graph, first_cell, range_start, range_end, 11, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n\n    let (start_row, start_col) = (range_start / c, range_start % c);\n    let (end_row, end_col) = (range_end / c, range_end % c);\n\n    let mut values = Vec::new();\n    for row in start_row..=end_row {\n        for col in start_col..=end_col {\n            let idx = row * c + col;\n            values.push(arr[idx]);\n        }\n    }\n\n    let sum: i32 = values.iter().sum();\n    let count = values.len();\n    arr[first_cell] = if count \u003e 0 { sum / count as i32 } else { 0 };\n    1\n}\n\n/// Computes the standard deviation of values within a specified range and stores it in the target cell.\n/// Adds the formula and dependency to the graph for recalculation tracking.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn stdev_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    let first_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n    let (range_start, range_end) =\n        extract_range_cells(a, eq_idx, c, r, graph).unwrap_or_else(error_range);\n\n    Graph::add_formula(graph, first_cell, range_start, range_end, 13, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n\n    let (start_row, start_col) = (range_start / c, range_start % c);\n    let (end_row, end_col) = (range_end / c, range_end % c);\n\n    let mut values = Vec::new();\n    for row in start_row..=end_row {\n        for col in start_col..=end_col {\n            let idx = row * c + col;\n            values.push(arr[idx]);\n        }\n    }\n\n    arr[first_cell] = std(\u0026values);\n    1\n}\n/// Delays execution for a number of seconds specified either directly or from a referenced cell.\n/// Also stores the sleep duration in the target cell and logs the dependency.\n/// Returns 1 on success.\n#[allow(clippy::too_many_arguments)]\npub fn sleep_func(\n    a: \u0026str,\n    c: usize,\n    r: usize,\n    eq_idx: usize,\n    _: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    let target_cell = cell_parser(a, c, r, 0, eq_idx - 1, graph).unwrap_or_else(error_usize);\n    let open_paren = a[eq_idx..].find('(').map(|i| i + eq_idx).unwrap_or(0);\n    let close_paren = a[eq_idx..].find(')').map(|i| i + eq_idx).unwrap_or(a.len() - 1);\n    if close_paren \u003c= open_paren + 1 {\n        // println!(\"Invalid sleep function syntax\");\n        return error_return();\n    }\n    // println!(\"1\");\n    if let Some(ref_cell) = cell_parser(a, c, r, open_paren + 1, close_paren - 1, graph) {\n        let sleep_value = arr[ref_cell];\n        // println!(\"Sleep value: {}\", sleep_value);\n        if sleep_value == i32::MIN {\n            arr[target_cell] = i32::MIN;\n            return 1;\n        }\n        graph.add_edge(ref_cell, target_cell);\n        Graph::add_formula(graph, target_cell, ref_cell, sleep_value as usize, 14, formula_array);\n        if sleep_value \u003e 0 {\n            // println!(\"Sleeping for {} seconds 1\", sleep_value);\n            // sleep(Duration::from_secs(sleep_value as u64));\n        } else {\n            // println!(\"Sleep value is less than 0, status = OK\");\n        }\n        arr[target_cell] = sleep_value;\n    } else {\n        // println!(\"2\");\n        let value: i32 = a[open_paren + 1..close_paren].trim().parse().unwrap_or(-1);\n        Graph::add_formula(graph, target_cell, target_cell, value as usize, 14, formula_array);\n        arr[target_cell] = value;\n        if value \u003e 0 {\n            // println!(\"Sleeping for {} seconds 2\", value);\n            // sleep(Duration::from_secs(value as u64));\n        } else {\n            // println!(\"Sleep value is less than 0, status = OK\");\n        }\n    }\n    1\n}\n","traces":[{"line":36,"address":[581824],"length":1,"stats":{"Line":4}},{"line":38,"address":[567031,566993],"length":1,"stats":{"Line":3}},{"line":43,"address":[586000],"length":1,"stats":{"Line":1}},{"line":45,"address":[581932,581889],"length":1,"stats":{"Line":1}},{"line":50,"address":[538496],"length":1,"stats":{"Line":0}},{"line":52,"address":[520378,520337],"length":1,"stats":{"Line":0}},{"line":57,"address":[567184],"length":1,"stats":{"Line":4}},{"line":58,"address":[582050,582156],"length":1,"stats":{"Line":3}},{"line":59,"address":[619502,619380,619414],"length":1,"stats":{"Line":7}},{"line":60,"address":[640584,640551],"length":1,"stats":{"Line":5}},{"line":63,"address":[316224],"length":1,"stats":{"Line":2}},{"line":64,"address":[619608],"length":1,"stats":{"Line":2}},{"line":65,"address":[539158],"length":1,"stats":{"Line":0}},{"line":67,"address":[520780],"length":1,"stats":{"Line":2}},{"line":68,"address":[619731],"length":1,"stats":{"Line":2}},{"line":70,"address":[593072,593082],"length":1,"stats":{"Line":4}},{"line":71,"address":[574304],"length":1,"stats":{"Line":2}},{"line":72,"address":[622609],"length":1,"stats":{"Line":2}},{"line":76,"address":[640846],"length":1,"stats":{"Line":2}},{"line":79,"address":[585472],"length":1,"stats":{"Line":2}},{"line":86,"address":[620241,620012],"length":1,"stats":{"Line":2}},{"line":87,"address":[641226,641318,641402],"length":1,"stats":{"Line":6}},{"line":88,"address":[521482,521524],"length":1,"stats":{"Line":5}},{"line":89,"address":[587304],"length":1,"stats":{"Line":0}},{"line":91,"address":[568393,568606,568336],"length":1,"stats":{"Line":7}},{"line":92,"address":[586254,586291,586488],"length":1,"stats":{"Line":6}},{"line":93,"address":[568840,569037,568800],"length":1,"stats":{"Line":7}},{"line":94,"address":[569018],"length":1,"stats":{"Line":3}},{"line":95,"address":[576413],"length":1,"stats":{"Line":0}},{"line":97,"address":[588024],"length":1,"stats":{"Line":3}},{"line":104,"address":[576480],"length":1,"stats":{"Line":2}},{"line":115,"address":[642465,642814],"length":1,"stats":{"Line":2}},{"line":118,"address":[642731],"length":1,"stats":{"Line":2}},{"line":122,"address":[569627],"length":1,"stats":{"Line":2}},{"line":123,"address":[318324],"length":1,"stats":{"Line":2}},{"line":126,"address":[584555,584660,584518],"length":1,"stats":{"Line":4}},{"line":127,"address":[584804,584652,584692],"length":1,"stats":{"Line":4}},{"line":129,"address":[523181,523257,523227],"length":1,"stats":{"Line":4}},{"line":132,"address":[570021],"length":1,"stats":{"Line":2}},{"line":134,"address":[577523,578346,578064],"length":1,"stats":{"Line":3}},{"line":135,"address":[622931,622837,623001],"length":1,"stats":{"Line":2}},{"line":136,"address":[588583,588634,588668],"length":1,"stats":{"Line":2}},{"line":140,"address":[587731,587916,588008],"length":1,"stats":{"Line":3}},{"line":141,"address":[643485,643790],"length":1,"stats":{"Line":2}},{"line":142,"address":[643648,643741],"length":1,"stats":{"Line":1}},{"line":143,"address":[319297,319330,319246],"length":1,"stats":{"Line":2}},{"line":148,"address":[541685,542217,542184],"length":1,"stats":{"Line":4}},{"line":155,"address":[542400],"length":1,"stats":{"Line":2}},{"line":166,"address":[586078,586409],"length":1,"stats":{"Line":2}},{"line":169,"address":[586332],"length":1,"stats":{"Line":2}},{"line":173,"address":[589180],"length":1,"stats":{"Line":2}},{"line":174,"address":[571555],"length":1,"stats":{"Line":2}},{"line":177,"address":[589375,589233,589270],"length":1,"stats":{"Line":4}},{"line":178,"address":[589404,589516,589367],"length":1,"stats":{"Line":4}},{"line":180,"address":[624064,623955,623906],"length":1,"stats":{"Line":4}},{"line":183,"address":[525232,525317,525117],"length":1,"stats":{"Line":6}},{"line":184,"address":[321120,320754,320901],"length":1,"stats":{"Line":6}},{"line":185,"address":[587275,587182],"length":1,"stats":{"Line":2}},{"line":187,"address":[591420,591369,591454],"length":1,"stats":{"Line":4}},{"line":192,"address":[543601,543631,543446],"length":1,"stats":{"Line":4}},{"line":202,"address":[579888],"length":1,"stats":{"Line":2}},{"line":212,"address":[590757,590384],"length":1,"stats":{"Line":2}},{"line":213,"address":[321494],"length":1,"stats":{"Line":2}},{"line":215,"address":[580311],"length":1,"stats":{"Line":2}},{"line":216,"address":[526203],"length":1,"stats":{"Line":2}},{"line":217,"address":[574359,574336],"length":1,"stats":{"Line":6}},{"line":218,"address":[580510,580483,580446],"length":1,"stats":{"Line":4}},{"line":225,"address":[526384,528309],"length":1,"stats":{"Line":2}},{"line":235,"address":[646513,646871],"length":1,"stats":{"Line":2}},{"line":236,"address":[646685],"length":1,"stats":{"Line":2}},{"line":239,"address":[526897],"length":1,"stats":{"Line":2}},{"line":240,"address":[545105],"length":1,"stats":{"Line":2}},{"line":242,"address":[625964,625847,625807],"length":1,"stats":{"Line":4}},{"line":243,"address":[545464,545268,545308],"length":1,"stats":{"Line":4}},{"line":245,"address":[592980],"length":1,"stats":{"Line":2}},{"line":246,"address":[581429,581508,581700],"length":1,"stats":{"Line":6}},{"line":247,"address":[589557,589193],"length":1,"stats":{"Line":4}},{"line":248,"address":[589736,589823],"length":1,"stats":{"Line":2}},{"line":249,"address":[593969,593928],"length":1,"stats":{"Line":4}},{"line":253,"address":[527511,527609],"length":1,"stats":{"Line":4}},{"line":254,"address":[581810],"length":1,"stats":{"Line":2}},{"line":255,"address":[581847,582067],"length":1,"stats":{"Line":2}},{"line":263,"address":[575120,576796],"length":1,"stats":{"Line":2}},{"line":273,"address":[582705,583063],"length":1,"stats":{"Line":2}},{"line":274,"address":[593281],"length":1,"stats":{"Line":2}},{"line":277,"address":[547009],"length":1,"stats":{"Line":2}},{"line":278,"address":[528897],"length":1,"stats":{"Line":2}},{"line":280,"address":[583055,583095,583203],"length":1,"stats":{"Line":4}},{"line":281,"address":[547251,547211,547392],"length":1,"stats":{"Line":4}},{"line":283,"address":[575970],"length":1,"stats":{"Line":2}},{"line":284,"address":[576076,576256,575997],"length":1,"stats":{"Line":6}},{"line":285,"address":[649397,649548],"length":1,"stats":{"Line":4}},{"line":286,"address":[628758,628671],"length":1,"stats":{"Line":2}},{"line":287,"address":[576687,576728],"length":1,"stats":{"Line":4}},{"line":291,"address":[591141,591240,591049],"length":1,"stats":{"Line":4}},{"line":298,"address":[584192],"length":1,"stats":{"Line":3}},{"line":308,"address":[592217,591878],"length":1,"stats":{"Line":2}},{"line":309,"address":[622734,622720],"length":1,"stats":{"Line":6}},{"line":310,"address":[594943,595080,595123],"length":1,"stats":{"Line":8}},{"line":311,"address":[577443,577485],"length":1,"stats":{"Line":4}},{"line":313,"address":[629593],"length":1,"stats":{"Line":0}},{"line":316,"address":[595624,595177,595215],"length":1,"stats":{"Line":6}},{"line":317,"address":[596707,596659,596747],"length":1,"stats":{"Line":4}},{"line":319,"address":[530993],"length":1,"stats":{"Line":2}},{"line":320,"address":[549309,549393,549426],"length":1,"stats":{"Line":0}},{"line":321,"address":[578024],"length":1,"stats":{"Line":0}},{"line":323,"address":[577837],"length":1,"stats":{"Line":2}},{"line":324,"address":[577881],"length":1,"stats":{"Line":2}},{"line":331,"address":[651033,651077,651095],"length":1,"stats":{"Line":4}},{"line":334,"address":[651225,651404,650847],"length":1,"stats":{"Line":4}},{"line":335,"address":[597186],"length":1,"stats":{"Line":2}},{"line":336,"address":[326804,326844,326865],"length":1,"stats":{"Line":4}},{"line":337,"address":[326847],"length":1,"stats":{"Line":2}},{"line":344,"address":[596935],"length":1,"stats":{"Line":2}}],"covered":106,"coverable":114},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","function_ext.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::f64;\n/// Represents a single cell in a spreadsheet.\n///\n/// Each cell holds a typed value (`Int`, `Float`, or `String`) and a flag indicating whether it's valid.\n/// Invalid cells are used to represent errors (e.g., formula issues, range errors).\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub struct Cell {\n    /// The actual value of the cell.\n    pub value: CellValue,\n    /// Indicates whether the cell's value is valid.\n    pub is_valid: bool,\n}\n\n/// Represents the value stored in a `Cell`.\n///\n/// A cell can contain either an integer, a floating-point number, or a string.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\npub enum CellValue {\n    /// Integer value\n    Int(i32),\n    /// Floating-point value\n    Float(f64),\n    /// String value\n    String(String),\n}\n\nimpl Cell {\n    /// Creates a new `Cell` containing an integer value.\n    ///\n    /// # Arguments\n    /// * `value` - The integer to store in the cell.\n    ///\n    /// # Example\n    /// ```\n    /// let cell = Cell::new_int(42);\n    /// assert_eq!(cell.value, CellValue::Int(42));\n    /// assert!(cell.is_valid);\n    /// ```\n    pub fn new_int(value: i32) -\u003e Self {\n        Cell { value: CellValue::Int(value), is_valid: true }\n    }\n\n    /// Creates a new `Cell` containing a floating-point value.\n    ///\n    /// # Arguments\n    /// * `value` - The float to store in the cell.\n    pub fn new_float(value: f64) -\u003e Self {\n        Cell { value: CellValue::Float(value), is_valid: true }\n    }\n\n    /// Creates a new `Cell` containing a string value.\n    ///\n    /// # Arguments\n    /// * `value` - The string to store in the cell.\n    pub fn new_string(value: String) -\u003e Self {\n        Cell { value: CellValue::String(value), is_valid: true }\n    }\n\n    /// Returns an invalid `Cell` instance.\n    ///\n    /// This is typically used when parsing fails or a computation is invalid.\n    ///\n    /// # Example\n    /// ```\n    /// let err_cell = Cell::invalid();\n    /// assert!(!err_cell.is_valid);\n    /// ```\n    pub fn invalid() -\u003e Self {\n        Cell { value: CellValue::Int(0), is_valid: false }\n    }\n}\n\nimpl Default for Cell {\n    /// Returns the default value for a `Cell`, which is an invalid cell.\n    fn default() -\u003e Self {\n        Cell::invalid()\n    }\n}\n","traces":[{"line":40,"address":[579872],"length":1,"stats":{"Line":26}},{"line":41,"address":[652839],"length":1,"stats":{"Line":32}},{"line":48,"address":[550624],"length":1,"stats":{"Line":16}},{"line":49,"address":[550633],"length":1,"stats":{"Line":12}},{"line":56,"address":[652960],"length":1,"stats":{"Line":6}},{"line":57,"address":[652963],"length":1,"stats":{"Line":7}},{"line":69,"address":[597568],"length":1,"stats":{"Line":27}},{"line":70,"address":[550755],"length":1,"stats":{"Line":21}},{"line":76,"address":[532656],"length":1,"stats":{"Line":19}},{"line":77,"address":[580136],"length":1,"stats":{"Line":20}}],"covered":10,"coverable":10},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","graph.rs"],"content":"// use std::collections::VecDeque;\n// use std::i32;\n/// Represents a formula associated with a spreadsheet cell.\n///\n/// - `op_type`: Indicates the operation type (e.g. 0: assign, 1-4: unary op, 5-8: binary op, 9-13: range functions).\n/// - `op_info1`: First operand (may be a cell index or constant).\n/// - `op_info2`: Second operand or auxiliary value.\n#[derive(Clone, Copy, Debug, Default)]\npub struct Formula {\n    pub op_type: i32,\n    pub op_info1: i32,\n    pub op_info2: i32,\n}\n\n/// A node in an adjacency list used to represent dependencies between cells.\n#[derive(Debug)]\npub struct Cell {\n    /// Index of the dependent cell.\n    pub cell: usize,\n    /// Pointer to the next dependent cell.\n    pub next: Option\u003cBox\u003cCell\u003e\u003e,\n}\n\n/// Represents a rectangular cell range with a dependent output cell.\n#[derive(Debug)]\npub struct Range {\n    /// Start cell of the range.\n    pub start_cell: usize,\n    /// End cell of the range.\n    pub end_cell: usize,\n    /// Cell that depends on the result of the range.\n    pub dependent_cell: usize,\n    /// Pointer to the next range node.\n    pub next: Option\u003cBox\u003cRange\u003e\u003e,\n}\n\n/// The core graph structure used for tracking dependencies and formula evaluation.\npub struct Graph {\n    /// Adjacency list where each index points to a list of dependents.\n    pub adj_lists: Vec\u003cOption\u003cBox\u003cCell\u003e\u003e\u003e,\n    /// Linked list of rectangular ranges with dependent cells.\n    pub ranges: Option\u003cBox\u003cRange\u003e\u003e,\n    /// Total number of cells in the spreadsheet.\n    pub num_cells: usize,\n}\n\nimpl Graph {\n    /// Creates a new `Graph` with the given number of cells.\n    pub fn new(num_cells: usize) -\u003e Self {\n        Self { adj_lists: vec![None; num_cells], ranges: None, num_cells }\n    }\n    /// Returns a new boxed `Cell` node for the given index.\n    pub fn add_cell(cell: usize) -\u003e Option\u003cBox\u003cCell\u003e\u003e {\n        Some(Box::new(Cell { cell, next: None }))\n    }\n    /// Returns a new boxed `Range` from start to end affecting the dependent cell.\n    pub fn add_range(start: usize, end: usize, dependent: usize) -\u003e Option\u003cBox\u003cRange\u003e\u003e {\n        Some(Box::new(Range {\n            start_cell: start,\n            end_cell: end,\n            dependent_cell: dependent,\n            next: None,\n        }))\n    }\n    /// Adds a directed edge from one cell to another.\n    pub fn add_edge(\u0026mut self, from: usize, to: usize) {\n        if self.has_edge(from, to) {\n            return;\n        }\n        let new_cell = Box::new(Cell { cell: to, next: self.adj_lists[from].take() });\n        self.adj_lists[from] = Some(new_cell);\n    }\n    /// Checks whether a directed edge already exists from one cell to another.\n    pub fn has_edge(\u0026self, from: usize, to: usize) -\u003e bool {\n        let mut current = \u0026self.adj_lists[from];\n        while let Some(cell) = current {\n            if cell.cell == to {\n                return true;\n            }\n            current = \u0026cell.next;\n        }\n        false\n    }\n    /// Deletes a dependency edge from the graph.\n    pub fn delete_edge(\u0026mut self, from: usize, to: usize) {\n        let head = self.adj_lists[from].take();\n        let mut dummy = Box::new(Cell { cell: 0, next: head });\n        let mut prev = \u0026mut dummy;\n\n        while let Some(mut node) = prev.next.take() {\n            if node.cell == to {\n                prev.next = node.next.take();\n                break;\n            } else {\n                prev.next = Some(node);\n                prev = prev.next.as_mut().unwrap();\n            }\n        }\n\n        self.adj_lists[from] = dummy.next;\n    }\n    /// Inserts a new range-based dependency into the graph.\n    pub fn add_range_to_graph(\u0026mut self, start: usize, end: usize, dependent: usize) {\n        let mut new_range = Self::add_range(start, end, dependent);\n        if let Some(ref mut r) = new_range {\n            r.next = self.ranges.take();\n        }\n        self.ranges = new_range;\n    }\n    /// Removes a range from the graph if it targets the specified dependent cell.\n    pub fn delete_range(\u0026mut self, dependent: usize) {\n        let mut prev: *mut Option\u003cBox\u003cRange\u003e\u003e = \u0026mut self.ranges;\n        unsafe {\n            while let Some(ref mut current) = *prev {\n                if current.dependent_cell == dependent {\n                    *prev = current.next.take();\n                } else {\n                    prev = \u0026mut current.next;\n                }\n            }\n        }\n    }\n    /// Adds a formula to the formula array for a specific cell.\n    pub fn add_formula(\n        _graph: \u0026mut Graph,\n        cell: usize,\n        c1: usize,\n        c2: usize,\n        op_type: i32,\n        formula_array: \u0026mut [Formula],\n    ) {\n        formula_array[cell] = Formula { op_type, op_info1: c1 as i32, op_info2: c2 as i32 };\n    }\n    /// Evaluates two integers with the specified arithmetic operation.\n    pub fn arithmetic_eval2(v1: i32, v2: i32, op: char) -\u003e i32 {\n        match op {\n            '+' =\u003e v1 + v2,\n            '-' =\u003e v1 - v2,\n            '*' =\u003e v1 * v2,\n            '/' if v2 != 0 =\u003e v1 / v2,\n            _ =\u003e i32::MIN,\n        }\n    }\n    /// Performs a depth-first topological sort starting from a cell, detecting cycles.\n    ///\n    /// Updates `stack` with a valid evaluation order if no cycles are found.\n    #[allow(clippy::only_used_in_recursion)]\n    #[allow(clippy::too_many_arguments)]\n    pub fn topo_sort_from_cell(\n        \u0026self,\n        start: usize,\n        cols: usize,\n        visited: \u0026mut Vec\u003cbool\u003e,\n        on_stack: \u0026mut Vec\u003cbool\u003e,\n        stack: \u0026mut Vec\u003cusize\u003e,\n        formula_array: \u0026[Formula],\n        has_cycle: \u0026mut bool,\n    ) {\n        if *has_cycle {\n            return;\n        }\n\n        visited[start] = true;\n        on_stack[start] = true;\n\n        let mut current = \u0026self.adj_lists[start];\n        while let Some(node) = current {\n            let dep = node.cell;\n            if !visited[dep] {\n                self.topo_sort_from_cell(\n                    dep,\n                    cols,\n                    visited,\n                    on_stack,\n                    stack,\n                    formula_array,\n                    has_cycle,\n                );\n            } else if on_stack[dep] {\n                *has_cycle = true;\n                // HAS_CYCLE.store(true, Ordering::Relaxed);  // or Ordering::SeqCst if needed\n\n                return;\n            }\n            current = \u0026node.next;\n        }\n\n        let mut range = \u0026self.ranges;\n        while let Some(r) = range {\n            let sr = r.start_cell / cols;\n            let sc = r.start_cell % cols;\n            let er = r.end_cell / cols;\n            let ec = r.end_cell % cols;\n            let row = start / cols;\n            let col = start % cols;\n\n            if row \u003e= sr \u0026\u0026 row \u003c= er \u0026\u0026 col \u003e= sc \u0026\u0026 col \u003c= ec {\n                if !visited[r.dependent_cell] {\n                    self.topo_sort_from_cell(\n                        r.dependent_cell,\n                        cols,\n                        visited,\n                        on_stack,\n                        stack,\n                        formula_array,\n                        has_cycle,\n                    );\n                } else if on_stack[r.dependent_cell] {\n                    *has_cycle = true;\n                    // HAS_CYCLE.store(true, Ordering::Relaxed);  // or Ordering::SeqCst if needed\n\n                    return;\n                }\n            }\n\n            range = \u0026r.next;\n        }\n\n        on_stack[start] = false;\n        stack.push(start);\n    }\n    /// Evaluates and updates all dependent cells starting from `start_cell`.\n    ///\n    /// Performs topological sort, evaluates formulas, handles errors and propagation.\n    pub fn recalc(\n        \u0026mut self,\n        cols: usize,\n        arr: \u0026mut [i32],\n        start_cell: usize,\n        formula_array: \u0026mut [Formula],\n        has_cycle: \u0026mut bool,\n    ) {\n        let mut visited = vec![false; self.num_cells];\n        let mut on_stack = vec![false; self.num_cells];\n        let mut stack = Vec::new();\n\n        self.topo_sort_from_cell(\n            start_cell,\n            cols,\n            \u0026mut visited,\n            \u0026mut on_stack,\n            \u0026mut stack,\n            formula_array,\n            has_cycle,\n        );\n\n        if *has_cycle {\n            return;\n        }\n\n        while let Some(cell) = stack.pop() {\n            let formula = formula_array[cell];\n            match formula.op_type {\n                0 =\u003e {\n                    arr[cell] = formula.op_info1;\n                }\n\n                1..=4 =\u003e {\n                    let v1 = arr[formula.op_info1 as usize];\n                    let v2 = formula.op_info2;\n                    if v1 == i32::MIN || (formula.op_type == 4 \u0026\u0026 v2 == 0) {\n                        arr[cell] = i32::MIN;\n                    } else {\n                        let op = match formula.op_type {\n                            1 =\u003e '+',\n                            2 =\u003e '-',\n                            3 =\u003e '*',\n                            4 =\u003e '/',\n                            _ =\u003e '?',\n                        };\n                        arr[cell] = Graph::arithmetic_eval2(v1, v2, op);\n                    }\n                }\n\n                5..=8 =\u003e {\n                    let v1 = arr[formula.op_info1 as usize];\n                    let v2 = arr[formula.op_info2 as usize];\n                    if v1 == i32::MIN || v2 == i32::MIN || (formula.op_type == 8 \u0026\u0026 v2 == 0) {\n                        arr[cell] = i32::MIN;\n                    } else {\n                        let op = match formula.op_type {\n                            5 =\u003e '+',\n                            6 =\u003e '-',\n                            7 =\u003e '*',\n                            8 =\u003e '/',\n                            _ =\u003e '?',\n                        };\n                        arr[cell] = Graph::arithmetic_eval2(v1, v2, op);\n                    }\n                }\n\n                9..=13 =\u003e {\n                    let start_cell = formula.op_info1 as usize;\n                    let end_cell = formula.op_info2 as usize;\n\n                    let start_row = start_cell / cols;\n                    let start_col = start_cell % cols;\n                    let end_row = end_cell / cols;\n                    let end_col = end_cell % cols;\n\n                    // Optimize by swapping if start \u003e end\n                    let (start_row, end_row) = if start_row \u003e end_row {\n                        (end_row, start_row)\n                    } else {\n                        (start_row, end_row)\n                    };\n                    let (start_col, end_col) = if start_col \u003e end_col {\n                        (end_col, start_col)\n                    } else {\n                        (start_col, end_col)\n                    };\n\n                    let mut sum = 0;\n                    let mut count = 0;\n                    let mut min_val = i32::MAX;\n                    let mut max_val = i32::MIN;\n                    let mut has_error = false;\n                    let mut values = vec![];\n\n                    // First pass: Calculate sum, min, max and check for errors\n                    for row in start_row..=end_row {\n                        for col in start_col..=end_col {\n                            let idx = row * cols + col;\n                            let val = arr[idx];\n\n                            if val == i32::MIN {\n                                has_error = true;\n                                break;\n                            }\n\n                            sum += val;\n                            count += 1;\n                            min_val = min_val.min(val);\n                            max_val = max_val.max(val);\n                            values.push(val);\n                        }\n                        if has_error {\n                            break;\n                        }\n                    }\n\n                    if has_error || count == 0 {\n                        arr[cell] = i32::MIN;\n                    } else {\n                        arr[cell] = match formula.op_type {\n                            9 =\u003e min_val,      // MIN\n                            10 =\u003e max_val,     // MAX\n                            11 =\u003e sum / count, // AVG\n                            12 =\u003e sum,         // SUM\n                            13 =\u003e {\n                                // STDEV\n                                let mean = sum as f64 / count as f64;\n                                let variance = values\n                                    .iter()\n                                    .map(|\u0026x| {\n                                        let diff = x as f64 - mean;\n                                        diff * diff\n                                    })\n                                    .sum::\u003cf64\u003e()\n                                    / count as f64;\n                                variance.sqrt().round() as i32\n                            }\n                            _ =\u003e i32::MIN,\n                        };\n                    }\n                }\n                14 =\u003e {\n                    let v = if formula.op_info1 as usize == cell {\n                        formula.op_info2\n                    } else {\n                        arr[formula.op_info1 as usize]\n                    };\n\n                    if v == i32::MIN {\n                        arr[cell] = i32::MIN;\n                    } else {\n                        if v \u003e 0 {\n                            // println!(\"Sleeping for {} seconds 3\", v);\n                            std::thread::sleep(std::time::Duration::from_secs(v as u64));\n                        }\n                        arr[cell] = v;\n                    }\n                }\n\n                15 =\u003e {\n                    let v1 = formula.op_info1;\n                    let v2 = arr[formula.op_info2 as usize];\n                    if v2 == i32::MIN || (v2 == 0 \u0026\u0026 formula.op_type == 4) {\n                        arr[cell] = i32::MIN;\n                    } else {\n                        let op = '/'; // op_type 15 is used for CONSTANT / CELL\n                        arr[cell] = Graph::arithmetic_eval2(v1, v2, op);\n                    }\n                }\n\n                _ =\u003e {\n                    arr[cell] = i32::MIN;\n                }\n            }\n        }\n    }\n}\n/// Clones a dependency list node recursively.\nimpl Clone for Cell {\n    fn clone(\u0026self) -\u003e Self {\n        Self { cell: self.cell, next: self.next.clone() }\n    }\n}\n/// Clones a range list node recursively.\nimpl Clone for Range {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            start_cell: self.start_cell,\n            end_cell: self.end_cell,\n            dependent_cell: self.dependent_cell,\n            next: self.next.clone(),\n        }\n    }\n}\n","traces":[{"line":49,"address":[461392],"length":1,"stats":{"Line":33}},{"line":50,"address":[456858],"length":1,"stats":{"Line":22}},{"line":53,"address":[563200],"length":1,"stats":{"Line":0}},{"line":54,"address":[494345],"length":1,"stats":{"Line":0}},{"line":57,"address":[596208],"length":1,"stats":{"Line":3}},{"line":58,"address":[669196],"length":1,"stats":{"Line":6}},{"line":62,"address":[461587],"length":1,"stats":{"Line":7}},{"line":66,"address":[461648,461911,461937],"length":1,"stats":{"Line":4}},{"line":67,"address":[457122],"length":1,"stats":{"Line":8}},{"line":70,"address":[469179],"length":1,"stats":{"Line":11}},{"line":71,"address":[216506,216540,216653],"length":1,"stats":{"Line":8}},{"line":74,"address":[494768],"length":1,"stats":{"Line":9}},{"line":75,"address":[216696],"length":1,"stats":{"Line":11}},{"line":76,"address":[469466,469672],"length":1,"stats":{"Line":10}},{"line":77,"address":[216757,216792],"length":1,"stats":{"Line":6}},{"line":78,"address":[545699],"length":1,"stats":{"Line":2}},{"line":80,"address":[457631,457594,457645],"length":1,"stats":{"Line":3}},{"line":82,"address":[494874],"length":1,"stats":{"Line":12}},{"line":85,"address":[671657,671222,669840],"length":1,"stats":{"Line":1}},{"line":86,"address":[462292],"length":1,"stats":{"Line":1}},{"line":87,"address":[614501],"length":1,"stats":{"Line":1}},{"line":88,"address":[597023],"length":1,"stats":{"Line":1}},{"line":90,"address":[546039,546686,545919],"length":1,"stats":{"Line":3}},{"line":91,"address":[546184,546116],"length":1,"stats":{"Line":2}},{"line":92,"address":[470960,470265,470734,470994],"length":1,"stats":{"Line":2}},{"line":95,"address":[546350,546531,546696,546263],"length":1,"stats":{"Line":1}},{"line":96,"address":[463114,462978,463032],"length":1,"stats":{"Line":3}},{"line":100,"address":[671314,671249,671593],"length":1,"stats":{"Line":2}},{"line":103,"address":[472089,471552,472115],"length":1,"stats":{"Line":3}},{"line":104,"address":[464151],"length":1,"stats":{"Line":6}},{"line":105,"address":[599088,598812],"length":1,"stats":{"Line":12}},{"line":106,"address":[471685,471778,471925],"length":1,"stats":{"Line":12}},{"line":108,"address":[565918,566242],"length":1,"stats":{"Line":5}},{"line":111,"address":[219296,219859],"length":1,"stats":{"Line":2}},{"line":112,"address":[497491],"length":1,"stats":{"Line":2}},{"line":114,"address":[472247,472156,472212],"length":1,"stats":{"Line":4}},{"line":115,"address":[460585,460195,460236,460387],"length":1,"stats":{"Line":6}},{"line":116,"address":[219548,219613,219782,219869],"length":1,"stats":{"Line":4}},{"line":118,"address":[464952,464878,464938],"length":1,"stats":{"Line":0}},{"line":124,"address":[472736],"length":1,"stats":{"Line":11}},{"line":132,"address":[617532,617467],"length":1,"stats":{"Line":11}},{"line":135,"address":[460848],"length":1,"stats":{"Line":2}},{"line":136,"address":[617578],"length":1,"stats":{"Line":2}},{"line":137,"address":[465488,465559],"length":1,"stats":{"Line":2}},{"line":138,"address":[465509,465594],"length":1,"stats":{"Line":4}},{"line":139,"address":[567300,567210],"length":1,"stats":{"Line":2}},{"line":140,"address":[673148,673246],"length":1,"stats":{"Line":4}},{"line":141,"address":[600110],"length":1,"stats":{"Line":1}},{"line":149,"address":[465744],"length":1,"stats":{"Line":5}},{"line":159,"address":[600573],"length":1,"stats":{"Line":9}},{"line":163,"address":[220578],"length":1,"stats":{"Line":11}},{"line":164,"address":[498802],"length":1,"stats":{"Line":11}},{"line":166,"address":[549538],"length":1,"stats":{"Line":11}},{"line":167,"address":[618193,618622,618183],"length":1,"stats":{"Line":26}},{"line":168,"address":[600801,600902,600745],"length":1,"stats":{"Line":8}},{"line":169,"address":[220863],"length":1,"stats":{"Line":4}},{"line":170,"address":[568030],"length":1,"stats":{"Line":4}},{"line":179,"address":[466388],"length":1,"stats":{"Line":1}},{"line":180,"address":[473922],"length":1,"stats":{"Line":1}},{"line":185,"address":[674083,674066,674014],"length":1,"stats":{"Line":7}},{"line":188,"address":[220757],"length":1,"stats":{"Line":7}},{"line":189,"address":[221117,222686,220769],"length":1,"stats":{"Line":19}},{"line":190,"address":[466555,466652,466820],"length":1,"stats":{"Line":8}},{"line":191,"address":[462446,462237,462284],"length":1,"stats":{"Line":8}},{"line":192,"address":[568710,568867,568663],"length":1,"stats":{"Line":9}},{"line":193,"address":[569024,568847,568888],"length":1,"stats":{"Line":10}},{"line":194,"address":[462776,462853,462816],"length":1,"stats":{"Line":10}},{"line":195,"address":[474925,474877,474955],"length":1,"stats":{"Line":10}},{"line":197,"address":[500292,500365],"length":1,"stats":{"Line":5}},{"line":198,"address":[467592],"length":1,"stats":{"Line":1}},{"line":199,"address":[463335],"length":1,"stats":{"Line":0}},{"line":200,"address":[463360,463219,463159],"length":1,"stats":{"Line":0}},{"line":208,"address":[463381,463187],"length":1,"stats":{"Line":2}},{"line":209,"address":[602688],"length":1,"stats":{"Line":1}},{"line":216,"address":[222674,222691,222123],"length":1,"stats":{"Line":10}},{"line":219,"address":[550114],"length":1,"stats":{"Line":4}},{"line":220,"address":[568306],"length":1,"stats":{"Line":7}},{"line":225,"address":[625668,620240,624636],"length":1,"stats":{"Line":2}},{"line":233,"address":[475722],"length":1,"stats":{"Line":4}},{"line":234,"address":[569998],"length":1,"stats":{"Line":4}},{"line":235,"address":[468385],"length":1,"stats":{"Line":4}},{"line":237,"address":[620637],"length":1,"stats":{"Line":5}},{"line":247,"address":[676194],"length":1,"stats":{"Line":4}},{"line":251,"address":[464112,464039],"length":1,"stats":{"Line":8}},{"line":252,"address":[468776,468867,468731],"length":1,"stats":{"Line":27}},{"line":253,"address":[552323],"length":1,"stats":{"Line":21}},{"line":254,"address":[501875],"length":1,"stats":{"Line":10}},{"line":255,"address":[570760,570606,570736],"length":1,"stats":{"Line":20}},{"line":258,"address":[571516,570567],"length":1,"stats":{"Line":16}},{"line":259,"address":[469854,473033,473090],"length":1,"stats":{"Line":2}},{"line":260,"address":[574727],"length":1,"stats":{"Line":1}},{"line":261,"address":[505927,505881,506222,505973,506157],"length":1,"stats":{"Line":3}},{"line":262,"address":[608039,608067,607779],"length":1,"stats":{"Line":0}},{"line":264,"address":[625306],"length":1,"stats":{"Line":1}},{"line":265,"address":[556737],"length":1,"stats":{"Line":1}},{"line":266,"address":[468670],"length":1,"stats":{"Line":0}},{"line":267,"address":[607883],"length":1,"stats":{"Line":0}},{"line":268,"address":[574936],"length":1,"stats":{"Line":0}},{"line":269,"address":[473204],"length":1,"stats":{"Line":0}},{"line":271,"address":[473275,473362],"length":1,"stats":{"Line":1}},{"line":275,"address":[621964,622044],"length":1,"stats":{"Line":14}},{"line":276,"address":[465358,468015,467965],"length":1,"stats":{"Line":12}},{"line":277,"address":[468053,468089,467979],"length":1,"stats":{"Line":12}},{"line":278,"address":[556147,556430,556194,556231,556495],"length":1,"stats":{"Line":22}},{"line":279,"address":[472968,472697,472996],"length":1,"stats":{"Line":2}},{"line":281,"address":[607370],"length":1,"stats":{"Line":5}},{"line":282,"address":[227287],"length":1,"stats":{"Line":1}},{"line":283,"address":[480271],"length":1,"stats":{"Line":2}},{"line":284,"address":[480284],"length":1,"stats":{"Line":1}},{"line":285,"address":[556345],"length":1,"stats":{"Line":1}},{"line":286,"address":[480245],"length":1,"stats":{"Line":0}},{"line":288,"address":[607571,607484],"length":1,"stats":{"Line":5}},{"line":292,"address":[477356,477443],"length":1,"stats":{"Line":4}},{"line":293,"address":[224560],"length":1,"stats":{"Line":4}},{"line":294,"address":[622157],"length":1,"stats":{"Line":4}},{"line":296,"address":[677637,677766,677726],"length":1,"stats":{"Line":6}},{"line":297,"address":[503019,502974,503056],"length":1,"stats":{"Line":8}},{"line":298,"address":[604917,604957,604872],"length":1,"stats":{"Line":8}},{"line":299,"address":[477834,477781,477870],"length":1,"stats":{"Line":8}},{"line":302,"address":[470391,470501,470451],"length":1,"stats":{"Line":10}},{"line":303,"address":[477941],"length":1,"stats":{"Line":0}},{"line":305,"address":[572115],"length":1,"stats":{"Line":4}},{"line":307,"address":[225191,225120,225157],"length":1,"stats":{"Line":12}},{"line":308,"address":[225175],"length":1,"stats":{"Line":0}},{"line":310,"address":[466010],"length":1,"stats":{"Line":4}},{"line":313,"address":[622812],"length":1,"stats":{"Line":4}},{"line":314,"address":[478151],"length":1,"stats":{"Line":4}},{"line":315,"address":[466130],"length":1,"stats":{"Line":4}},{"line":316,"address":[225272],"length":1,"stats":{"Line":4}},{"line":317,"address":[225283],"length":1,"stats":{"Line":4}},{"line":318,"address":[622864],"length":1,"stats":{"Line":4}},{"line":321,"address":[225330,225557,225393],"length":1,"stats":{"Line":12}},{"line":322,"address":[572710,572917],"length":1,"stats":{"Line":8}},{"line":323,"address":[554883,554781],"length":1,"stats":{"Line":4}},{"line":324,"address":[678956,679000,679042],"length":1,"stats":{"Line":8}},{"line":326,"address":[466857],"length":1,"stats":{"Line":4}},{"line":327,"address":[466931],"length":1,"stats":{"Line":0}},{"line":331,"address":[623655,623614,623685],"length":1,"stats":{"Line":8}},{"line":332,"address":[226115,226143,226057],"length":1,"stats":{"Line":8}},{"line":333,"address":[479055,479115],"length":1,"stats":{"Line":8}},{"line":334,"address":[679250],"length":1,"stats":{"Line":4}},{"line":335,"address":[555216],"length":1,"stats":{"Line":4}},{"line":337,"address":[225741],"length":1,"stats":{"Line":4}},{"line":342,"address":[470971,472453,472369,471727],"length":1,"stats":{"Line":11}},{"line":343,"address":[472446,472471,471753],"length":1,"stats":{"Line":0}},{"line":345,"address":[467447,467207,467799,467827],"length":1,"stats":{"Line":9}},{"line":346,"address":[471832],"length":1,"stats":{"Line":1}},{"line":347,"address":[471851],"length":1,"stats":{"Line":2}},{"line":348,"address":[606507,606675],"length":1,"stats":{"Line":4}},{"line":349,"address":[226433],"length":1,"stats":{"Line":1}},{"line":352,"address":[573602],"length":1,"stats":{"Line":2}},{"line":353,"address":[467393,467582,467680],"length":1,"stats":{"Line":6}},{"line":355,"address":[596800,596810],"length":1,"stats":{"Line":4}},{"line":356,"address":[652272],"length":1,"stats":{"Line":2}},{"line":357,"address":[586529],"length":1,"stats":{"Line":2}},{"line":360,"address":[505047],"length":1,"stats":{"Line":2}},{"line":361,"address":[606893],"length":1,"stats":{"Line":2}},{"line":363,"address":[226343],"length":1,"stats":{"Line":0}},{"line":368,"address":[603814,603595,603786],"length":1,"stats":{"Line":6}},{"line":369,"address":[469132],"length":1,"stats":{"Line":2}},{"line":371,"address":[464632,464549,464604],"length":1,"stats":{"Line":2}},{"line":374,"address":[621598,621357,621533],"length":1,"stats":{"Line":4}},{"line":375,"address":[552995,552967,552774],"length":1,"stats":{"Line":0}},{"line":377,"address":[676826],"length":1,"stats":{"Line":3}},{"line":379,"address":[552825],"length":1,"stats":{"Line":2}},{"line":381,"address":[476756,476858,476882],"length":1,"stats":{"Line":4}},{"line":386,"address":[501798],"length":1,"stats":{"Line":2}},{"line":387,"address":[677154,676603,677112],"length":1,"stats":{"Line":4}},{"line":388,"address":[571262,571209,571393,571458,571299],"length":1,"stats":{"Line":6}},{"line":389,"address":[621943,621749,621915],"length":1,"stats":{"Line":0}},{"line":391,"address":[501055],"length":1,"stats":{"Line":2}},{"line":392,"address":[677243,677334],"length":1,"stats":{"Line":2}},{"line":396,"address":[470068],"length":1,"stats":{"Line":1}},{"line":397,"address":[502877,502905,502780],"length":1,"stats":{"Line":2}},{"line":405,"address":[575232],"length":1,"stats":{"Line":0}},{"line":406,"address":[506377],"length":1,"stats":{"Line":0}},{"line":411,"address":[575280],"length":1,"stats":{"Line":0}},{"line":413,"address":[625774],"length":1,"stats":{"Line":0}},{"line":414,"address":[506454],"length":1,"stats":{"Line":0}},{"line":415,"address":[608287],"length":1,"stats":{"Line":0}},{"line":416,"address":[608296],"length":1,"stats":{"Line":0}}],"covered":156,"coverable":181},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","graph_ext.rs"],"content":"use crate::function_ext::Cell;\nuse crate::util_ext::arithmetic_eval;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nuse crate::function_ext::CellValue;\n/// A compact formula representation for spreadsheet cells.\n///\n/// - `op_type`: The operation type (e.g., literal assignment, arithmetic, sum, avg, etc.).\n/// - `op_info1`: First operand (could be a cell index or constant).\n/// - `op_info2`: Second operand (used for binary ops or range end).\n#[derive(Clone, Copy, Default)]\npub struct Formula {\n    pub op_type: i32,\n    pub op_info1: i32,\n    pub op_info2: i32,\n}\n/// A node in the adjacency list representing a dependency from one cell to another.\n\n#[derive(Clone)]\npub struct GraphNode {\n    /// The dependent cell.\n    pub cell: i32,\n    /// Pointer to the next dependency in the list.\n    pub next: Option\u003cBox\u003cGraphNode\u003e\u003e,\n}\n/// A rectangular range in the spreadsheet and the cell it affects.\n#[derive(Clone)]\npub struct Range {\n    /// Starting cell index of the range.\n    pub start_cell: i32,\n    /// Ending cell index of the range.\n    pub end_cell: i32,\n    /// Cell that depends on the values in this range.\n    pub dependent_cell: i32,\n    /// Next range in the linked list.\n    pub next: Option\u003cBox\u003cRange\u003e\u003e,\n}\n/// The core data structure representing dependencies between cells.\n///\n/// - Uses adjacency lists to represent single-cell dependencies.\n/// - Also maintains a linked list of range-based dependencies.\npub struct Graph {\n    /// Heads of adjacency lists where each index corresponds to a cell.\n    pub adj_lists_head: Vec\u003cOption\u003cBox\u003cGraphNode\u003e\u003e\u003e,\n    /// Head of a linked list representing all cell ranges with dependencies.\n    pub ranges_head: Option\u003cBox\u003cRange\u003e\u003e,\n}\nimpl Clone for Graph {\n    fn clone(\u0026self) -\u003e Self {\n        Graph { adj_lists_head: self.adj_lists_head.clone(), ranges_head: self.ranges_head.clone() }\n    }\n}\n\nimpl Graph {\n    /// Creates a new dependency graph for a spreadsheet with `num_cells` cells.\n    ///\n    /// Initializes an adjacency list and empty range list.\n    pub fn new(num_cells: usize) -\u003e Self {\n        let mut adj_lists_head = Vec::with_capacity(num_cells);\n        for _ in 0..num_cells {\n            adj_lists_head.push(None);\n        }\n        Graph { adj_lists_head, ranges_head: None }\n    }\n\n    /// Adds a formula for a specific cell, recording the operation type and operands.\n    ///\n    /// - `cell`: The index of the cell being assigned a formula.\n    /// - `c1`, `c2`: Operands (cell references or constants).\n    /// - `op_type`: Type of operation (e.g., addition, SUM, AVG, etc.).\n    /// - `formula_array`: Mutable reference to the formula array.\n    pub fn add_formula(\n        \u0026mut self,\n        cell: i32,\n        c1: i32,\n        c2: i32,\n        op_type: i32,\n        formula_array: \u0026mut [Formula],\n    ) {\n        let mut new_formula = Formula { op_type, op_info1: -1, op_info2: -1 };\n        if op_type == 0 {\n            new_formula.op_info1 = c1;\n        } else {\n            new_formula.op_info1 = c1;\n            new_formula.op_info2 = c2;\n        }\n        formula_array[cell as usize] = new_formula;\n    }\n\n    fn add_node(cell: i32) -\u003e Box\u003cGraphNode\u003e {\n        Box::new(GraphNode { cell, next: None })\n    }\n\n    fn add_range(\n        \u0026mut self,\n        start_cell: i32,\n        end_cell: i32,\n        dependent_cell: i32,\n    ) -\u003e Option\u003cBox\u003cRange\u003e\u003e {\n        Some(Box::new(Range {\n            start_cell,\n            end_cell,\n            dependent_cell,\n            next: self.ranges_head.take(),\n        }))\n    }\n    /// Adds a single dependency edge to the graph from `cell1` to `head_idx`.\n    ///\n    /// Ensures no duplicate edges.\n    pub fn add_edge(\u0026mut self, cell1: i32, head_idx: usize) {\n        let head = \u0026mut self.adj_lists_head[head_idx];\n        if head.is_none() {\n            self.adj_lists_head[head_idx] = Some(Self::add_node(cell1));\n            return;\n        }\n        let mut current = head.as_mut().unwrap();\n        if current.cell == cell1 {\n            return;\n        }\n        while let Some(ref mut next) = current.next {\n            if next.cell == cell1 {\n                return;\n            }\n            current = next;\n        }\n        current.next = Some(Self::add_node(cell1));\n    }\n    /// Adds a rectangular dependency range to the graph with the specified dependent cell.\n    pub fn add_range_to_graph(\u0026mut self, start_cell: i32, end_cell: i32, dependent_cell: i32) {\n        if let Some(new_range) = self.add_range(start_cell, end_cell, dependent_cell) {\n            self.ranges_head = Some(new_range);\n        }\n    }\n    /// Deletes a single dependency node (edge) pointing from `cell1` in the list at `head_idx`.\n    pub fn delete_node(\u0026mut self, cell1: i32, head_idx: usize) {\n        let head = \u0026mut self.adj_lists_head[head_idx];\n        if head.is_none() {\n            return;\n        }\n        if head.as_ref().unwrap().cell == cell1 {\n            self.adj_lists_head[head_idx] = head.as_mut().unwrap().next.take();\n            return;\n        }\n        let mut current = head.as_mut().unwrap();\n        while let Some(ref mut next) = current.next {\n            if next.cell == cell1 {\n                current.next = next.next.take();\n                return;\n            }\n            if next.next.is_none() {\n                break;\n            }\n            current = current.next.as_mut().unwrap();\n        }\n    }\n\n    //     void DeleteRangeFromGraph(Graph *graph, int dependentCell)\n    // {\n    //     Range *current = graph-\u003eranges_head;\n    //     Range *prev = NULL;\n\n    //     while (current != NULL)\n    //     {\n    //         if (current-\u003edependentCell == dependentCell)\n    //         {\n    //             // Remove this range\n    //             if (prev == NULL)\n    //             {\n    //                 // It's the head node\n    //                 graph-\u003eranges_head = current-\u003enext;\n    //                 free(current);\n    //                 current = graph-\u003eranges_head;\n    //             }\n    //             else\n    //             {\n    //                 // Middle or end node\n    //                 prev-\u003enext = current-\u003enext;\n    //                 free(current);\n    //                 current = prev-\u003enext;\n    //             }\n    //         }\n    //         else\n    //         {\n    //             prev = current;\n    //             current = current-\u003enext;\n    //         }\n    //     }\n    // }\n    /// Deletes any range that affects `dependent_cell`.\n    ///\n    /// Used for cleaning up graph dependencies on formula deletion.\n    pub fn delete_range_from_graph(\u0026mut self, dependent_cell: i32) {\n        let mut current = \u0026mut self.ranges_head;\n\n        while current.is_some() {\n            let should_remove = current.as_ref().unwrap().dependent_cell == dependent_cell;\n\n            if should_remove {\n                let next = current.as_mut().unwrap().next.take();\n                *current = next;\n                break;\n            } else {\n                current = \u0026mut current.as_mut().unwrap().next;\n            }\n        }\n    }\n\n    /// Removes all dependency edges associated with a given formula.\n    pub fn delete_edge(\u0026mut self, cell: i32, _cols: i32, formula_array: \u0026[Formula]) {\n        let x = formula_array[cell as usize];\n        match x.op_type {\n            -1 =\u003e self.delete_node(cell, x.op_info1 as usize),\n            1..=4 =\u003e self.delete_node(cell, x.op_info1 as usize),\n            5..=8 =\u003e {\n                self.delete_node(cell, x.op_info1 as usize);\n                self.delete_node(cell, x.op_info2 as usize);\n            }\n            9..=13 =\u003e self.delete_range_from_graph(cell),\n            14 =\u003e self.delete_node(cell, x.op_info1 as usize),\n            15 =\u003e self.delete_node(cell, x.op_info2 as usize),\n            _ =\u003e {}\n        }\n    }\n    /// Rebuilds all dependency edges for the given formula.\n    ///\n    /// Useful after modifying a formula or loading a snapshot.\n    pub fn add_edge_formula(\u0026mut self, cell: i32, _cols: i32, formula_array: \u0026[Formula]) {\n        let x = formula_array[cell as usize];\n        match x.op_type {\n            -1 =\u003e self.add_edge(cell, x.op_info1 as usize),\n            1..=4 =\u003e self.add_edge(cell, x.op_info1 as usize),\n            5..=8 =\u003e {\n                self.add_edge(cell, x.op_info1 as usize);\n                self.add_edge(cell, x.op_info2 as usize);\n            }\n            9..=13 =\u003e {\n                let start_cell = x.op_info1;\n                let end_cell = x.op_info2;\n                self.add_range_to_graph(start_cell, end_cell, cell);\n            }\n            14 =\u003e {\n                if x.op_info1 != cell {\n                    self.add_edge(cell, x.op_info1 as usize);\n                }\n            }\n            15 =\u003e self.add_edge(cell, x.op_info2 as usize),\n            _ =\u003e {}\n        }\n    }\n    /// Internal DFS used to perform topological sort and detect cycles.\n    ///\n    /// Traverses standard dependencies and range-based dependencies.\n    /// - `cell`: Current DFS node\n    /// - `visited`: Whether cell has been visited\n    /// - `on_stack`: DFS recursion stack flag\n    /// - `result`: Output topologically sorted result\n    /// - `has_cycle`: Set to true if a cycle is detected\n    /// - `cols`: Number of spreadsheet columns\n    fn dfs(\n        \u0026self,\n        cell: i32,\n        visited: \u0026mut [bool],\n        on_stack: \u0026mut [bool],\n        result: \u0026mut Vec\u003ci32\u003e,\n        has_cycle: \u0026mut bool,\n        cols: i32,\n    ) {\n        if *has_cycle {\n            return;\n        }\n        visited[cell as usize] = true;\n        on_stack[cell as usize] = true;\n        let mut current = \u0026self.adj_lists_head[cell as usize];\n        while let Some(node) = current.as_ref() {\n            let dependent = node.cell;\n            if !visited[dependent as usize] {\n                self.dfs(dependent, visited, on_stack, result, has_cycle, cols);\n            } else if on_stack[dependent as usize] {\n                *has_cycle = true;\n                // HAS_CYCLE.store(true, Ordering::Relaxed);  // or Ordering::SeqCst if needed\n\n                return;\n            }\n            if *has_cycle {\n                return;\n            }\n            current = \u0026node.next;\n        }\n        let mut range = \u0026self.ranges_head;\n        while let Some(r) = range.as_ref() {\n            let start_cell = r.start_cell;\n            let end_cell = r.end_cell;\n            let dependent = r.dependent_cell;\n            let start_row = start_cell / cols;\n            let start_col = start_cell % cols;\n            let end_row = end_cell / cols;\n            let end_col = end_cell % cols;\n            let (start_row, end_row) =\n                if start_row \u003e end_row { (end_row, start_row) } else { (start_row, end_row) };\n            let (start_col, end_col) =\n                if start_col \u003e end_col { (end_col, start_col) } else { (start_col, end_col) };\n            let cell_row = cell / cols;\n            let cell_col = cell % cols;\n            if cell_row \u003e= start_row\n                \u0026\u0026 cell_row \u003c= end_row\n                \u0026\u0026 cell_col \u003e= start_col\n                \u0026\u0026 cell_col \u003c= end_col\n            {\n                if !visited[dependent as usize] {\n                    self.dfs(dependent, visited, on_stack, result, has_cycle, cols);\n                } else if on_stack[dependent as usize] {\n                    *has_cycle = true;\n                    // HAS_CYCLE.store(true, Ordering::Relaxed);  // or Ordering::SeqCst if needed\n\n                    return;\n                }\n                if *has_cycle {\n                    return;\n                }\n            }\n            range = \u0026r.next;\n        }\n        on_stack[cell as usize] = false;\n        result.push(cell);\n    }\n    /// Topologically sorts all cells reachable from `start_cell`.\n    ///\n    /// Used before recalculation to ensure a valid execution order.\n    ///\n    /// Returns an error if a circular dependency is detected.\n    pub fn topo_sort_from_cell(\n        \u0026self,\n        start_cell: i32,\n        cols: i32,\n        state: \u0026mut State,\n    ) -\u003e Result\u003cVec\u003ci32\u003e, \u0026'static str\u003e {\n        let mut visited = vec![false; state.num_cells];\n        let mut on_stack = vec![false; state.num_cells];\n        let mut result = Vec::new();\n        let mut has_cycle = false;\n        self.dfs(start_cell, \u0026mut visited, \u0026mut on_stack, \u0026mut result, \u0026mut has_cycle, cols);\n        if has_cycle {\n            state.has_cycle = true;\n            return Err(\"Circular dependency detected\");\n        }\n        result.reverse();\n        Ok(result)\n    }\n    /// Recalculates all formulas reachable from `start_cell`\n    /// in topological order based on the dependency graph.\n    ///\n    /// Supports direct assignment, binary operations, range-based functions,\n    /// and sleep-based side-effects.\n    pub fn recalc(\n        \u0026self,\n        cols: i32,\n        arr: \u0026mut [Cell],\n        start_cell: i32,\n        formula_array: \u0026[Formula],\n        state: \u0026mut State,\n    ) -\u003e Result\u003c(), \u0026'static str\u003e {\n        let sorted_cells = self.topo_sort_from_cell(start_cell, cols, state)?;\n        for \u0026cell in \u0026sorted_cells {\n            let f = formula_array[cell as usize];\n            match f.op_type {\n                -1 =\u003e {\n                    // for cell = cell\n                    let v1 = arr[f.op_info1 as usize].clone();\n\n                    if !v1.is_valid {\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info1, v1);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    // let op = match f.op_type {\n                    //     1 =\u003e '+',\n                    //     2 =\u003e '-',\n                    //     3 =\u003e '*',\n                    //     4 =\u003e '/',\n                    //     _ =\u003e unreachable!(),\n                    // };\n                    arr[cell as usize] = v1;\n                }\n                0 =\u003e arr[cell as usize] = Cell::new_int(f.op_info1),\n                1..=4 =\u003e {\n                    let v1 = arr[f.op_info1 as usize].clone();\n                    let v2 = Cell::new_int(f.op_info2);\n\n                    if !v1.is_valid {\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info1, v1);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    let op = match f.op_type {\n                        1 =\u003e '+',\n                        2 =\u003e '-',\n                        3 =\u003e '*',\n                        4 =\u003e '/',\n                        _ =\u003e unreachable!(),\n                    };\n                    arr[cell as usize] = arithmetic_eval(v1, v2, op);\n                }\n                5..=8 =\u003e {\n                    let v1 = arr[f.op_info1 as usize].clone();\n                    let v2 = arr[f.op_info2 as usize].clone();\n                    if !v1.is_valid || !v2.is_valid {\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info1, v1);\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info2, v2);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    let op = match f.op_type {\n                        5 =\u003e '+',\n                        6 =\u003e '-',\n                        7 =\u003e '*',\n                        8 =\u003e '/',\n                        _ =\u003e unreachable!(),\n                    };\n                    arr[cell as usize] = arithmetic_eval(v1, v2, op);\n                }\n                9..=13 =\u003e {\n                    let start_cell = f.op_info1;\n                    let end_cell = f.op_info2;\n                    let start_row = start_cell / cols;\n                    let start_col = start_cell % cols;\n                    let end_row = end_cell / cols;\n                    let end_col = end_cell % cols;\n                    let (start_row, end_row) = if start_row \u003e end_row {\n                        (end_row, start_row)\n                    } else {\n                        (start_row, end_row)\n                    };\n                    let (start_col, end_col) = if start_col \u003e end_col {\n                        (end_col, start_col)\n                    } else {\n                        (start_col, end_col)\n                    };\n                    let mut sum = 0.0;\n                    let mut count = 0;\n                    let mut min_val = f64::MAX;\n                    let mut max_val = f64::MIN;\n                    let mut has_error = false;\n                    let mut values = Vec::new();\n                    'outer: for row in start_row..=end_row {\n                        for col in start_col..=end_col {\n                            let idx = row * cols + col;\n                            let val = \u0026arr[idx as usize];\n                            if !val.is_valid {\n                                has_error = true;\n                                break 'outer;\n                            }\n                            match \u0026val.value {\n                                CellValue::Int(i) =\u003e {\n                                    let v = *i as f64;\n                                    sum += v;\n                                    count += 1;\n                                    min_val = min_val.min(v);\n                                    max_val = max_val.max(v);\n                                    values.push(v);\n                                }\n                                CellValue::Float(f) =\u003e {\n                                    sum += *f;\n                                    count += 1;\n                                    min_val = min_val.min(*f);\n                                    max_val = max_val.max(*f);\n                                    values.push(*f);\n                                }\n                                CellValue::String(_) =\u003e {\n                                    has_error = true;\n                                    break 'outer;\n                                }\n                            }\n                        }\n                    }\n                    if has_error || count == 0 {\n                        // println!(\"Invalid range for cell {}: {:?}\", cell, arr[cell as usize]);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    arr[cell as usize] = match f.op_type {\n                        9 =\u003e {\n                            if min_val.fract() == 0.0 {\n                                Cell::new_int(min_val as i32)\n                            } else {\n                                Cell::new_float(min_val)\n                            }\n                        }\n                        10 =\u003e {\n                            if max_val.fract() == 0.0 {\n                                Cell::new_int(max_val as i32)\n                            } else {\n                                Cell::new_float(max_val)\n                            }\n                        }\n                        11 =\u003e {\n                            let avg = sum / count as f64;\n                            if avg.fract() == 0.0 {\n                                Cell::new_int(avg as i32)\n                            } else {\n                                Cell::new_float(avg)\n                            }\n                        }\n                        12 =\u003e {\n                            if sum.fract() == 0.0 {\n                                Cell::new_int(sum as i32)\n                            } else {\n                                Cell::new_float(sum)\n                            }\n                        }\n                        13 =\u003e {\n                            let mean = sum / count as f64;\n                            let variance =\n                                values.iter().map(|\u0026x| (x - mean) * (x - mean)).sum::\u003cf64\u003e()\n                                    / count as f64;\n                            let stdev = variance.sqrt();\n                            if stdev.fract() == 0.0 {\n                                Cell::new_int(stdev as i32)\n                            } else {\n                                Cell::new_float(stdev)\n                            }\n                        }\n                        _ =\u003e unreachable!(),\n                    };\n                }\n                14 =\u003e {\n                    let mut sleep_value = arr[f.op_info1 as usize].clone();\n                    if f.op_info1 == cell {\n                        sleep_value = Cell::new_int(f.op_info2);\n                    }\n                    if !sleep_value.is_valid {\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info1, sleep_value);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    if let CellValue::Int(val) = sleep_value.value {\n                        if val \u003e 0 {\n                            sleep(Duration::from_secs(val as u64));\n                        }\n                    }\n                    arr[cell as usize] = sleep_value;\n                }\n                15 =\u003e {\n                    let v1 = Cell::new_int(f.op_info1);\n                    let v2 = arr[f.op_info2 as usize].clone();\n                    if !v2.is_valid {\n                        // println!(\"Invalid value for cell {}: {:?}\", f.op_info2, v2);\n                        arr[cell as usize] = Cell::invalid();\n                        continue;\n                    }\n                    arr[cell as usize] = arithmetic_eval(v1, v2, '/');\n                }\n                16 =\u003e {\n                    // Do nothing — string is already assigned in arr, skip overwriting\n                }\n                17 =\u003e {\n                    //Do nothing - float is already assigned\n                }\n\n                _ =\u003e {\n                    // println!(\"Invalid formula type for cell {}: {:?}\", cell, f.op_type); ;\n                    arr[cell as usize] = Cell::invalid()\n                }\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl Drop for Graph {\n    fn drop(\u0026mut self) {}\n}\n\n/// Tracks metadata and cycle detection state for formula recalculation.\n#[derive(Default, Clone)]\npub struct State {\n    /// Previous value of the cell before recalculation.\n    pub old_value: Cell,\n    pub old_op_type: i32,\n    pub old_op_info1: i32,\n    pub old_op_info2: i32,\n    /// Whether a cycle was detected during traversal.\n    pub has_cycle: bool,\n    /// Number of cells in the spreadsheet.\n    pub num_cells: usize,\n}\n\nimpl State {\n    /// Constructs a default empty state.\n    pub fn new() -\u003e Self {\n        State {\n            old_value: Cell::invalid(),\n            old_op_type: 0,\n            old_op_info1: 0,\n            old_op_info2: 0,\n            has_cycle: false,\n            num_cells: 0,\n        }\n    }\n}\n\n/// Captures the entire spreadsheet state including formulas and dependencies.\n///\n/// Used for features like undo/redo or saving state between operations.\n#[derive(Clone)]\npub struct StateSnapshot {\n    /// Current values in the spreadsheet.\n    pub arr: Vec\u003cCell\u003e,\n    /// Formulas assigned to each cell.\n    pub formula_array: Vec\u003cFormula\u003e,\n    /// Dependency graph linking formulas and affected cells.\n    pub graph: Graph,\n}\n","traces":[{"line":50,"address":[508592,508744],"length":1,"stats":{"Line":0}},{"line":51,"address":[528712],"length":1,"stats":{"Line":0}},{"line":59,"address":[542016,542370],"length":1,"stats":{"Line":16}},{"line":60,"address":[608174],"length":1,"stats":{"Line":17}},{"line":61,"address":[528920,528996],"length":1,"stats":{"Line":39}},{"line":62,"address":[509080],"length":1,"stats":{"Line":27}},{"line":73,"address":[509152],"length":1,"stats":{"Line":3}},{"line":81,"address":[549935],"length":1,"stats":{"Line":2}},{"line":82,"address":[553156,553170],"length":1,"stats":{"Line":7}},{"line":83,"address":[553166],"length":1,"stats":{"Line":1}},{"line":85,"address":[608636],"length":1,"stats":{"Line":4}},{"line":86,"address":[542512],"length":1,"stats":{"Line":5}},{"line":88,"address":[529373,529447],"length":1,"stats":{"Line":4}},{"line":91,"address":[608752],"length":1,"stats":{"Line":4}},{"line":92,"address":[542634],"length":1,"stats":{"Line":10}},{"line":95,"address":[553344],"length":1,"stats":{"Line":2}},{"line":101,"address":[509479],"length":1,"stats":{"Line":2}},{"line":105,"address":[542273],"length":1,"stats":{"Line":4}},{"line":111,"address":[543138,543287,542352],"length":1,"stats":{"Line":4}},{"line":112,"address":[491432],"length":1,"stats":{"Line":6}},{"line":113,"address":[491466],"length":1,"stats":{"Line":4}},{"line":114,"address":[550417,551055],"length":1,"stats":{"Line":10}},{"line":117,"address":[575705],"length":1,"stats":{"Line":2}},{"line":118,"address":[575732,575817],"length":1,"stats":{"Line":4}},{"line":121,"address":[529924,529966,530037,530065,530175],"length":1,"stats":{"Line":2}},{"line":122,"address":[167018,166977],"length":1,"stats":{"Line":0}},{"line":125,"address":[167102],"length":1,"stats":{"Line":0}},{"line":127,"address":[576148,575968,576291],"length":1,"stats":{"Line":2}},{"line":130,"address":[543296,543450],"length":1,"stats":{"Line":2}},{"line":131,"address":[543922,543754],"length":1,"stats":{"Line":8}},{"line":132,"address":[167596,167645,167685],"length":1,"stats":{"Line":6}},{"line":136,"address":[610096,611137,611386],"length":1,"stats":{"Line":3}},{"line":137,"address":[551496],"length":1,"stats":{"Line":3}},{"line":138,"address":[576880],"length":1,"stats":{"Line":5}},{"line":141,"address":[510834,510889],"length":1,"stats":{"Line":8}},{"line":142,"address":[492852,493619],"length":1,"stats":{"Line":5}},{"line":145,"address":[510972],"length":1,"stats":{"Line":1}},{"line":146,"address":[511439,511066,511171],"length":1,"stats":{"Line":1}},{"line":147,"address":[493032,492991],"length":1,"stats":{"Line":2}},{"line":148,"address":[610841,610678],"length":1,"stats":{"Line":2}},{"line":151,"address":[168339,168272],"length":1,"stats":{"Line":0}},{"line":154,"address":[552164,552091],"length":1,"stats":{"Line":0}},{"line":193,"address":[611798,611408],"length":1,"stats":{"Line":1}},{"line":194,"address":[578113],"length":1,"stats":{"Line":1}},{"line":196,"address":[611434,611707],"length":1,"stats":{"Line":2}},{"line":197,"address":[611577,611454],"length":1,"stats":{"Line":1}},{"line":199,"address":[556115],"length":1,"stats":{"Line":2}},{"line":200,"address":[494109,494197,494234],"length":1,"stats":{"Line":2}},{"line":201,"address":[611828,611790,611754],"length":1,"stats":{"Line":2}},{"line":204,"address":[512336,512217,512326],"length":1,"stats":{"Line":2}},{"line":210,"address":[578544],"length":1,"stats":{"Line":3}},{"line":211,"address":[169561,169470],"length":1,"stats":{"Line":3}},{"line":212,"address":[545818],"length":1,"stats":{"Line":3}},{"line":213,"address":[494495],"length":1,"stats":{"Line":1}},{"line":214,"address":[556648,556553],"length":1,"stats":{"Line":6}},{"line":215,"address":[546018,545963],"length":1,"stats":{"Line":2}},{"line":216,"address":[169726],"length":1,"stats":{"Line":1}},{"line":217,"address":[578870],"length":1,"stats":{"Line":1}},{"line":219,"address":[556677,556739],"length":1,"stats":{"Line":2}},{"line":220,"address":[512677],"length":1,"stats":{"Line":1}},{"line":221,"address":[612075],"length":1,"stats":{"Line":1}},{"line":228,"address":[553568],"length":1,"stats":{"Line":1}},{"line":229,"address":[545801,545710],"length":1,"stats":{"Line":1}},{"line":230,"address":[533034],"length":1,"stats":{"Line":1}},{"line":231,"address":[513023],"length":1,"stats":{"Line":1}},{"line":232,"address":[579065,579172],"length":1,"stats":{"Line":2}},{"line":233,"address":[579159,579214],"length":1,"stats":{"Line":2}},{"line":234,"address":[546414],"length":1,"stats":{"Line":1}},{"line":235,"address":[513186],"length":1,"stats":{"Line":1}},{"line":237,"address":[533298,533233],"length":1,"stats":{"Line":2}},{"line":238,"address":[533318],"length":1,"stats":{"Line":1}},{"line":239,"address":[612606],"length":1,"stats":{"Line":1}},{"line":240,"address":[170173],"length":1,"stats":{"Line":1}},{"line":243,"address":[494880],"length":1,"stats":{"Line":1}},{"line":244,"address":[546330],"length":1,"stats":{"Line":1}},{"line":247,"address":[579121],"length":1,"stats":{"Line":1}},{"line":260,"address":[533360],"length":1,"stats":{"Line":9}},{"line":269,"address":[533507],"length":1,"stats":{"Line":8}},{"line":272,"address":[546735,546679,546772],"length":1,"stats":{"Line":19}},{"line":273,"address":[533667,533587,533713],"length":1,"stats":{"Line":18}},{"line":274,"address":[557495],"length":1,"stats":{"Line":9}},{"line":275,"address":[546449,547013,546415],"length":1,"stats":{"Line":20}},{"line":276,"address":[533804,533860,533956],"length":1,"stats":{"Line":4}},{"line":277,"address":[170818,170769],"length":1,"stats":{"Line":4}},{"line":278,"address":[170928],"length":1,"stats":{"Line":1}},{"line":279,"address":[546853,546905],"length":1,"stats":{"Line":4}},{"line":280,"address":[534233],"length":1,"stats":{"Line":2}},{"line":285,"address":[170988],"length":1,"stats":{"Line":1}},{"line":288,"address":[558073,558122],"length":1,"stats":{"Line":0}},{"line":290,"address":[579803],"length":1,"stats":{"Line":13}},{"line":291,"address":[580282,581944,579815],"length":1,"stats":{"Line":25}},{"line":292,"address":[496133,496296,496200],"length":1,"stats":{"Line":5}},{"line":293,"address":[555287,555197,555156],"length":1,"stats":{"Line":5}},{"line":294,"address":[171513,171589,171472],"length":1,"stats":{"Line":6}},{"line":295,"address":[547905,547939,548019],"length":1,"stats":{"Line":6}},{"line":296,"address":[171689,171723,171801],"length":1,"stats":{"Line":6}},{"line":297,"address":[535079,534965,534999],"length":1,"stats":{"Line":6}},{"line":298,"address":[555696,555730,555808],"length":1,"stats":{"Line":6}},{"line":299,"address":[614488,614458],"length":1,"stats":{"Line":6}},{"line":301,"address":[548067],"length":1,"stats":{"Line":4}},{"line":303,"address":[497127,497229],"length":1,"stats":{"Line":2}},{"line":304,"address":[497340,497259,497222],"length":1,"stats":{"Line":6}},{"line":305,"address":[515494],"length":1,"stats":{"Line":4}},{"line":306,"address":[172489],"length":1,"stats":{"Line":1}},{"line":307,"address":[556296],"length":1,"stats":{"Line":1}},{"line":308,"address":[497428],"length":1,"stats":{"Line":0}},{"line":310,"address":[535700],"length":1,"stats":{"Line":0}},{"line":311,"address":[548981],"length":1,"stats":{"Line":0}},{"line":312,"address":[497654,497605],"length":1,"stats":{"Line":0}},{"line":313,"address":[535955],"length":1,"stats":{"Line":0}},{"line":318,"address":[515787],"length":1,"stats":{"Line":0}},{"line":322,"address":[559792,559805,559444],"length":1,"stats":{"Line":4}},{"line":324,"address":[515929,515964,514331],"length":1,"stats":{"Line":20}},{"line":325,"address":[548749],"length":1,"stats":{"Line":13}},{"line":332,"address":[497824,498545],"length":1,"stats":{"Line":9}},{"line":338,"address":[516049],"length":1,"stats":{"Line":8}},{"line":339,"address":[548930],"length":1,"stats":{"Line":9}},{"line":340,"address":[549429],"length":1,"stats":{"Line":9}},{"line":341,"address":[615617],"length":1,"stats":{"Line":8}},{"line":342,"address":[516339,516249],"length":1,"stats":{"Line":17}},{"line":343,"address":[536535],"length":1,"stats":{"Line":7}},{"line":344,"address":[516488],"length":1,"stats":{"Line":2}},{"line":345,"address":[549308],"length":1,"stats":{"Line":2}},{"line":347,"address":[557169,557273],"length":1,"stats":{"Line":21}},{"line":348,"address":[536665],"length":1,"stats":{"Line":14}},{"line":355,"address":[510811,500309,498576],"length":1,"stats":{"Line":6}},{"line":363,"address":[583293,582947],"length":1,"stats":{"Line":7}},{"line":364,"address":[616731,616570,616855],"length":1,"stats":{"Line":28}},{"line":365,"address":[561571,561423,561480],"length":1,"stats":{"Line":21}},{"line":366,"address":[174451],"length":1,"stats":{"Line":14}},{"line":369,"address":[551088,550950],"length":1,"stats":{"Line":4}},{"line":371,"address":[617283],"length":1,"stats":{"Line":2}},{"line":373,"address":[562367,561837,562034],"length":1,"stats":{"Line":4}},{"line":383,"address":[552042,551202,551742],"length":1,"stats":{"Line":2}},{"line":385,"address":[561648,562773],"length":1,"stats":{"Line":4}},{"line":386,"address":[565703,561591],"length":1,"stats":{"Line":10}},{"line":387,"address":[587865,593782],"length":1,"stats":{"Line":6}},{"line":388,"address":[509692,509625],"length":1,"stats":{"Line":6}},{"line":390,"address":[547956],"length":1,"stats":{"Line":3}},{"line":392,"address":[571790,571911,572256],"length":1,"stats":{"Line":4}},{"line":395,"address":[627265],"length":1,"stats":{"Line":1}},{"line":396,"address":[561639],"length":1,"stats":{"Line":2}},{"line":397,"address":[561652],"length":1,"stats":{"Line":0}},{"line":398,"address":[528417],"length":1,"stats":{"Line":1}},{"line":399,"address":[184971],"length":1,"stats":{"Line":0}},{"line":402,"address":[628281,627817],"length":1,"stats":{"Line":1}},{"line":404,"address":[541863,541943],"length":1,"stats":{"Line":6}},{"line":405,"address":[562585,567084],"length":1,"stats":{"Line":6}},{"line":406,"address":[183044,183172],"length":1,"stats":{"Line":6}},{"line":407,"address":[559823,559852],"length":1,"stats":{"Line":6}},{"line":410,"address":[626093,625961,626438],"length":1,"stats":{"Line":0}},{"line":413,"address":[559862],"length":1,"stats":{"Line":3}},{"line":414,"address":[626493],"length":1,"stats":{"Line":0}},{"line":415,"address":[183715],"length":1,"stats":{"Line":1}},{"line":416,"address":[626519],"length":1,"stats":{"Line":1}},{"line":417,"address":[567876],"length":1,"stats":{"Line":1}},{"line":420,"address":[593700,593231],"length":1,"stats":{"Line":3}},{"line":422,"address":[554647,554730],"length":1,"stats":{"Line":4}},{"line":423,"address":[521931],"length":1,"stats":{"Line":3}},{"line":424,"address":[503792],"length":1,"stats":{"Line":2}},{"line":425,"address":[542465,542556,542069],"length":1,"stats":{"Line":5}},{"line":426,"address":[542549,542591,542680],"length":1,"stats":{"Line":4}},{"line":427,"address":[179348,179306,179439],"length":1,"stats":{"Line":5}},{"line":428,"address":[622121,622216,622079],"length":1,"stats":{"Line":5}},{"line":429,"address":[556137,556181,556082],"length":1,"stats":{"Line":6}},{"line":430,"address":[622281],"length":1,"stats":{"Line":0}},{"line":432,"address":[504715],"length":1,"stats":{"Line":4}},{"line":434,"address":[566927,566895,566957],"length":1,"stats":{"Line":8}},{"line":435,"address":[555839],"length":1,"stats":{"Line":0}},{"line":437,"address":[543089],"length":1,"stats":{"Line":4}},{"line":439,"address":[179808],"length":1,"stats":{"Line":2}},{"line":440,"address":[556339],"length":1,"stats":{"Line":4}},{"line":441,"address":[504952],"length":1,"stats":{"Line":2}},{"line":442,"address":[523130],"length":1,"stats":{"Line":2}},{"line":443,"address":[567058],"length":1,"stats":{"Line":2}},{"line":444,"address":[523146],"length":1,"stats":{"Line":4}},{"line":445,"address":[556222,556058,555995],"length":1,"stats":{"Line":8}},{"line":446,"address":[589491],"length":1,"stats":{"Line":4}},{"line":447,"address":[622992,623097],"length":1,"stats":{"Line":2}},{"line":448,"address":[505598,505544,505645],"length":1,"stats":{"Line":6}},{"line":449,"address":[557029],"length":1,"stats":{"Line":4}},{"line":450,"address":[556642],"length":1,"stats":{"Line":2}},{"line":453,"address":[523847],"length":1,"stats":{"Line":3}},{"line":454,"address":[589989],"length":1,"stats":{"Line":3}},{"line":455,"address":[623316],"length":1,"stats":{"Line":3}},{"line":456,"address":[180660],"length":1,"stats":{"Line":2}},{"line":457,"address":[557229,557369,557401],"length":1,"stats":{"Line":6}},{"line":458,"address":[505968,506032],"length":1,"stats":{"Line":6}},{"line":459,"address":[590265],"length":1,"stats":{"Line":3}},{"line":460,"address":[568173],"length":1,"stats":{"Line":3}},{"line":462,"address":[567936],"length":1,"stats":{"Line":0}},{"line":463,"address":[557287],"length":1,"stats":{"Line":0}},{"line":464,"address":[623438,623675,623711],"length":1,"stats":{"Line":0}},{"line":465,"address":[623749,623682],"length":1,"stats":{"Line":0}},{"line":466,"address":[506222],"length":1,"stats":{"Line":0}},{"line":467,"address":[506277],"length":1,"stats":{"Line":0}},{"line":470,"address":[556908],"length":1,"stats":{"Line":1}},{"line":476,"address":[556621,557720],"length":1,"stats":{"Line":5}},{"line":478,"address":[559142,557298,558834],"length":1,"stats":{"Line":4}},{"line":481,"address":[591770,590997,590568,591879],"length":1,"stats":{"Line":8}},{"line":483,"address":[568721,568882,568506],"length":1,"stats":{"Line":6}},{"line":484,"address":[181519,181627],"length":1,"stats":{"Line":4}},{"line":486,"address":[558158,558062],"length":1,"stats":{"Line":0}},{"line":490,"address":[506943,506454,506813,506930],"length":1,"stats":{"Line":0}},{"line":491,"address":[181683,181760],"length":1,"stats":{"Line":0}},{"line":493,"address":[181659,181747],"length":1,"stats":{"Line":0}},{"line":497,"address":[590706],"length":1,"stats":{"Line":1}},{"line":498,"address":[181367,181782,181891,181904],"length":1,"stats":{"Line":3}},{"line":499,"address":[565895,565959],"length":1,"stats":{"Line":2}},{"line":501,"address":[558042,557955],"length":1,"stats":{"Line":0}},{"line":505,"address":[545487,544797,545474,545357],"length":1,"stats":{"Line":3}},{"line":506,"address":[569222,569303],"length":1,"stats":{"Line":2}},{"line":508,"address":[558618,558522],"length":1,"stats":{"Line":0}},{"line":512,"address":[506569],"length":1,"stats":{"Line":1}},{"line":514,"address":[507246,507344,506600],"length":1,"stats":{"Line":5}},{"line":515,"address":[591559],"length":1,"stats":{"Line":1}},{"line":516,"address":[558333],"length":1,"stats":{"Line":1}},{"line":517,"address":[507528,507385,507515],"length":1,"stats":{"Line":2}},{"line":518,"address":[569600,569536],"length":1,"stats":{"Line":2}},{"line":520,"address":[558483,558399],"length":1,"stats":{"Line":0}},{"line":523,"address":[506393],"length":1,"stats":{"Line":0}},{"line":527,"address":[563142,561685],"length":1,"stats":{"Line":6}},{"line":528,"address":[176390,176113],"length":1,"stats":{"Line":6}},{"line":529,"address":[560044,560111],"length":1,"stats":{"Line":4}},{"line":531,"address":[501145],"length":1,"stats":{"Line":2}},{"line":533,"address":[585650,586066,585733],"length":1,"stats":{"Line":0}},{"line":536,"address":[552840,552421],"length":1,"stats":{"Line":4}},{"line":537,"address":[176838],"length":1,"stats":{"Line":4}},{"line":538,"address":[540265],"length":1,"stats":{"Line":3}},{"line":541,"address":[560785,561261,560961],"length":1,"stats":{"Line":4}},{"line":544,"address":[174652,177374],"length":1,"stats":{"Line":4}},{"line":545,"address":[564521,564658],"length":1,"stats":{"Line":4}},{"line":546,"address":[520746],"length":1,"stats":{"Line":2}},{"line":548,"address":[586820,587021,587381],"length":1,"stats":{"Line":0}},{"line":551,"address":[503194,502618,503541],"length":1,"stats":{"Line":4}},{"line":562,"address":[555143,555250,555581],"length":1,"stats":{"Line":2}},{"line":566,"address":[558163],"length":1,"stats":{"Line":4}},{"line":571,"address":[456789,456784],"length":1,"stats":{"Line":9}},{"line":590,"address":[595056],"length":1,"stats":{"Line":7}},{"line":592,"address":[529006],"length":1,"stats":{"Line":15}}],"covered":205,"coverable":240},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","lib.rs"],"content":"//! # Spreadsheet System\n//!\n//! A modular and extensible spreadsheet engine implemented in Rust, designed for efficient formula evaluation,\n//! dependency tracking, and interactive features. This project supports both standard and extended spreadsheet modes.\n//!\n//! ## Features\n//! - Arithmetic expression parsing and evaluation\n//! - Cell dependency management using graph structures\n//! - Cycle detection and topological sorting for recalculation\n//! - Built-in functions: `SUM`, `AVG`, `MIN`, `MAX`, `STDEV`, etc.\n//! - Extended support for `String`, `Float`, and typed cell operations\n//! - Support for undo/redo functionality (in extended mode)\n//! - Autofill feature with pattern detection (AP, GP, etc.)\n//!\n//! ## Modules\n//! - [`display`](display): Handles rendering of spreadsheet UI (standard mode).\n//! - [`function`](function): Implements arithmetic and helper functions (standard mode).\n//! - [`graph`](graph): Tracks dependencies and handles formula recalculations (standard mode).\n//! - [`parser`](parser): Parses and evaluates expressions with support for integer cells (standard mode).\n//! - [`util_ext`](util_ext): Shared utilities used in extended evaluation logic.\n//! - [`display_ext`](display_ext): Enhanced rendering logic with extended features.\n//! - [`function_ext`](function_ext): Extended functions for float and string cell values.\n//! - [`graph_ext`](graph_ext): Extended dependency tracking with range support and advanced recalculation.\n//! - [`parser_ext`](parser_ext): Extended parser for multiple cell types and string operations.\n//!\n//! ## Getting Started\n//! To use the spreadsheet engine, select either the standard or extended mode through your binary's entry point.\n//! This selection allows dynamic inclusion of features depending on user needs.\n//!\n//! ### Example\n//! ```bash\n//! cargo run -- 10 10           # Run in standard mode\n//! cargo run -- 10 10 -extended # Run in extended mode\n//! ```\n//!\n//! ---\n//!\n//! **Author**: Built by Vani Gupta, 2025  \n//! *Modular design encourages future contributions and easy feature expansion.*\n\npub mod display;\npub mod display_ext;\npub mod function;\npub mod function_ext;\npub mod graph;\npub mod graph_ext;\npub mod parser;\npub mod parser_ext;\npub mod util_ext;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","parser.rs"],"content":"use crate::function::*;\nuse crate::graph::{Formula, Graph};\n\n/// Global flag indicating whether a circular dependency (cycle)\n/// was detected during graph traversal or formula evaluation.\n///\n/// This is used by the `parser` and `recalc` logic to rollback\n/// changes if a cycle is found, ensuring spreadsheet integrity.\n///\n/// # Safety\n/// Since this is a mutable static variable, it must be accessed\n/// within `unsafe` blocks. Use with caution and ensure proper synchronization.\npub static mut HAS_CYCLE: bool = false;\n\n/// Global flag indicating whether an invalid range was encountered\n/// during a range function (e.g., `MIN`, `MAX`, `SUM`, etc.) evaluation.\n///\n/// # Safety\n/// This mutable static should be used inside `unsafe` blocks only.\n/// Be careful of concurrent access if used in multithreaded context.\npub static mut INVALID_RANGE: bool = false;\n/// Parses a spreadsheet cell label (e.g., \"A1\", \"B12\") into a linear cell index.\n/// Converts column letters to number and parses row digits.\n/// Returns `Some(index)` if valid, else `None`.\n///\n/// # Parameters\n/// - `a`: Full input string\n/// - `cols`: Number of columns in the sheet\n/// - `rows`: Number of rows\n/// - `start`, `end`: Character indices in `a` for cell label substring\n/// - `_graph`: Unused in this version\npub fn cell_parser(\n    a: \u0026str,\n    cols: usize,\n    rows: usize,\n    start: usize,\n    end: usize,\n    _graph: \u0026Graph,\n) -\u003e Option\u003cusize\u003e {\n    // let slice = \u0026a[start..=end];\n    if end \u003e= a.len() || start \u003e end {\n        return None;\n    }\n    let slice = \u0026a[start..=end];\n\n    let mut col = 0;\n    let mut row = 0;\n    let mut digit_found = false;\n\n    for ch in slice.chars() {\n        if ch.is_ascii_alphabetic() {\n            if digit_found {\n                return None;\n            }\n            col = col * 26 + (ch.to_ascii_uppercase() as usize - 'A' as usize + 1);\n        } else if ch.is_ascii_digit() {\n            row = row * 10 + (ch as usize - '0' as usize);\n            digit_found = true;\n        } else {\n            return None;\n        }\n    }\n\n    if col == 0 || row == 0 {\n        return None;\n    }\n\n    let col_idx = col - 1;\n    let row_idx = row - 1;\n\n    if col_idx \u003e= cols || row_idx \u003e= rows {\n        return None;\n    }\n\n    Some(row_idx * cols + col_idx)\n}\n/// Detects whether the expression contains an arithmetic operator.\nfn is_arithmetic(expr: \u0026str) -\u003e bool {\n    expr.contains('+') || expr.contains('-') || expr.contains('*') || expr.contains('/')\n}\n\n/// Main parser function for spreadsheet cell assignment or function application.\n/// Handles constants, arithmetic operations, cell references, and supported functions\n/// like MIN, MAX, SUM, AVG, STDEV, and SLEEP. Also handles cycle detection and rollback.\n///\n/// # Parameters\n/// - `input`: Raw formula input as a string\n/// - `cols`: Number of columns in spreadsheet\n/// - `rows`: Number of rows in spreadsheet\n/// - `arr`: Array representing cell values\n/// - `graph`: Dependency graph for formula evaluation\n/// - `formula_array`: Stores formulas for each cell\n///\n/// # Returns\n/// - `1` if parsing and evaluation succeed\n/// - `-1` if parsing fails or cycle is detected\npub fn parser(\n    input: \u0026str,\n    cols: usize,\n    rows: usize,\n    arr: \u0026mut [i32],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n) -\u003e i32 {\n    unsafe {\n        HAS_CYCLE = false;\n        INVALID_RANGE = false;\n    }\n\n    let trimmed = input.trim();\n    // Check for '=' sign indicating a formula assignment\n    let eq_pos = trimmed.find('=');\n    if eq_pos.is_none() {\n        return -1;\n    }\n\n    let eq_index = eq_pos.unwrap();\n    let _left = \u0026trimmed[..eq_index];\n    // let right = \u0026trimmed[eq_index + 1..];\n    let right = \u0026trimmed[eq_index + 1..].trim();\n\n    if eq_index == 0 || eq_index \u003e trimmed.len() {\n        return -1;\n    }\n    // Parse left-hand side cell index\n    let left_cell = match cell_parser(trimmed, cols, rows, 0, eq_index - 1, graph) {\n        Some(idx) =\u003e idx,\n        None =\u003e return -1,\n    };\n\n    // Save old state for rollback if needed\n    let old_value = arr[left_cell];\n    let old_formula = formula_array[left_cell];\n\n    // Clear old edges if any\n    if old_formula.op_type != 0 {\n        graph.delete_edge(left_cell, old_formula.op_info1 as usize);\n        if (1..=8).contains(\u0026old_formula.op_type) {\n            graph.delete_edge(left_cell, old_formula.op_info2 as usize);\n        }\n        if (9..=13).contains(\u0026old_formula.op_type) {\n            graph.delete_range(left_cell);\n        }\n    }\n\n    let mut status = -1;\n    // Supported: MIN(), MAX(), AVG(), SUM(), STDEV()\n    if right.starts_with(\"MIN(\") {\n        status = min_func(trimmed, cols, rows, eq_index, trimmed.len(), arr, graph, formula_array);\n    } else if right.starts_with(\"MAX(\") {\n        status = max_func(trimmed, cols, rows, eq_index, trimmed.len(), arr, graph, formula_array);\n    } else if right.starts_with(\"AVG(\") {\n        status = avg_func(trimmed, cols, rows, eq_index, trimmed.len(), arr, graph, formula_array);\n    } else if right.starts_with(\"SUM(\") {\n        status = sum_func(trimmed, cols, rows, eq_index, trimmed.len(), arr, graph, formula_array);\n    } else if right.starts_with(\"STDEV(\") {\n        status =\n            stdev_func(trimmed, cols, rows, eq_index, trimmed.len(), arr, graph, formula_array);\n        // Handles SLEEP(n) or SLEEP(A1) where A1 holds sleep time\n    } else if right.starts_with(\"SLEEP(\") {\n        // Ensure we have a valid SLEEP() format\n        if right.ends_with(\")\") {\n            let value_str = \u0026right[6..right.len() - 1].trim(); // Extract value inside SLEEP()\n            if let Ok(_sleep_value) = value_str.parse::\u003ci32\u003e() {\n                status = sleep_func(\n                    trimmed,\n                    cols,\n                    rows,\n                    eq_index,\n                    trimmed.len(),\n                    arr,\n                    graph,\n                    formula_array,\n                );\n                // SLEEP value is parsed as expected\n            } else if let Some(idx) =\n                cell_parser(value_str, cols, rows, 0, value_str.len() - 1, graph)\n            {\n                graph.add_edge(idx, left_cell);\n                formula_array[left_cell] = Formula {\n                    op_type: 14, // Assuming 14 represents SLEEP with cell reference\n                    op_info1: idx as i32,\n                    op_info2: 0,\n                };\n                status = sleep_func(\n                    trimmed,\n                    cols,\n                    rows,\n                    eq_index,\n                    trimmed.len(),\n                    arr,\n                    graph,\n                    formula_array,\n                );\n            } else {\n                // Invalid number or cell reference inside SLEEP()\n                return -1;\n            }\n        } else {\n            // Invalid SLEEP syntax, missing closing parenthesis\n            return -1;\n        }\n    } else if right.starts_with('-') \u0026\u0026 right[1..].chars().all(|c| c.is_ascii_digit()) {\n        let const_val = right.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n        // println!(\"const_val: {}\", const_val);\n        formula_array[left_cell] = Formula { op_type: 0, op_info1: const_val, op_info2: 0 };\n\n        arr[left_cell] = const_val;\n\n        // println!(\"************8{}\", arr[left_cell]);\n        status = 1;\n        // return 1;\n        // Extract operands and operators like A1 + 5, 3 * B2, etc.\n    } else if is_arithmetic(right) {\n        // println!(\"Arithmetic expression detected: {}\", right);\n        // Parse left and right of operator\n        let ops = ['+', '-', '*', '/'];\n        let (op_index, op_char) =\n            right.char_indices().find(|(_, ch)| ops.contains(ch)).unwrap_or((0, '+'));\n\n        let left_expr = right[..op_index].trim();\n        let right_expr = right[op_index + 1..].trim();\n\n        let is_left_cell =\n            cell_parser(left_expr, cols, rows, 0, left_expr.len() - 1, graph).is_some();\n        let is_right_cell =\n            cell_parser(right_expr, cols, rows, 0, right_expr.len() - 1, graph).is_some();\n\n        let (left_val, right_val, op_type) = if is_left_cell \u0026\u0026 is_right_cell {\n            let idx1 = cell_parser(left_expr, cols, rows, 0, left_expr.len() - 1, graph).unwrap();\n            let idx2 = cell_parser(right_expr, cols, rows, 0, right_expr.len() - 1, graph).unwrap();\n            graph.add_edge(idx1, left_cell);\n            graph.add_edge(idx2, left_cell);\n            formula_array[left_cell] = Formula {\n                op_type: match op_char {\n                    '+' =\u003e 5,\n                    '-' =\u003e 6,\n                    '*' =\u003e 7,\n                    '/' =\u003e 8,\n                    _ =\u003e 0,\n                },\n                op_info1: idx1 as i32,\n                op_info2: idx2 as i32,\n            };\n            (arr[idx1], arr[idx2], formula_array[left_cell].op_type)\n        } else if is_left_cell {\n            let idx1 = cell_parser(left_expr, cols, rows, 0, left_expr.len() - 1, graph).unwrap();\n            let val2 = right_expr.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n            graph.add_edge(idx1, left_cell);\n            formula_array[left_cell] = Formula {\n                op_type: match op_char {\n                    '+' =\u003e 1,\n                    '-' =\u003e 2,\n                    '*' =\u003e 3,\n                    '/' =\u003e 4,\n                    _ =\u003e 0,\n                },\n                op_info1: idx1 as i32,\n                op_info2: val2,\n            };\n            (arr[idx1], val2, formula_array[left_cell].op_type)\n        } else if is_right_cell {\n            let idx2 = cell_parser(right_expr, cols, rows, 0, right_expr.len() - 1, graph).unwrap();\n            let val1 = left_expr.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n            graph.add_edge(idx2, left_cell);\n            formula_array[left_cell] =\n                Formula { op_type: 15, op_info1: val1, op_info2: idx2 as i32 };\n            (val1, arr[idx2], 15)\n        } else {\n            let val1 = left_expr.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n            let val2 = right_expr.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n            formula_array[left_cell] = Formula {\n                op_type: 0,\n                op_info1: match op_char {\n                    '+' =\u003e val1 + val2,\n                    '-' =\u003e val1 - val2,\n                    '*' =\u003e val1 * val2,\n                    '/' =\u003e {\n                        if val2 != 0 {\n                            val1 / val2\n                        } else {\n                            i32::MIN\n                        }\n                    }\n                    _ =\u003e i32::MIN,\n                },\n                op_info2: 0,\n            };\n            (val1, val2, 0)\n        };\n\n        arr[left_cell] = if op_type == 15 {\n            if right_val == 0 {\n                i32::MIN\n            } else {\n                left_val / right_val\n            }\n        } else if right_val == i32::MIN || left_val == i32::MIN {\n            i32::MIN\n        } else {\n            match op_char {\n                '+' =\u003e left_val + right_val,\n                '-' =\u003e left_val - right_val,\n                '*' =\u003e left_val * right_val,\n                '/' =\u003e {\n                    if right_val != 0 {\n                        left_val / right_val\n                    } else {\n                        i32::MIN\n                    }\n                }\n                _ =\u003e i32::MIN,\n            }\n        };\n\n        status = 1;\n    } else {\n        // Plain value or reference\n        if right.starts_with('-') \u0026\u0026 right[1..].chars().all(|c| c.is_ascii_digit()) {\n            let const_val = right.parse::\u003ci32\u003e().unwrap_or(i32::MIN);\n            // println!(\"const_val: {}\", const_val);\n            formula_array[left_cell] = Formula { op_type: 0, op_info1: const_val, op_info2: 0 };\n            arr[left_cell] = const_val;\n            return 1;\n        }\n\n        if let Ok(const_val) = right.parse::\u003ci32\u003e() {\n            formula_array[left_cell] = Formula { op_type: 0, op_info1: const_val, op_info2: 0 };\n            arr[left_cell] = const_val;\n            status = 1;\n        } else if let Some(idx) = cell_parser(right, cols, rows, 0, right.len() - 1, graph) {\n            graph.add_edge(idx, left_cell);\n            formula_array[left_cell] = Formula { op_type: 1, op_info1: idx as i32, op_info2: 0 };\n            arr[left_cell] = arr[idx];\n            status = 1;\n        }\n    }\n\n    if status == 1 {\n        // Perform recalculation\n        // println!(\"{}\", arr[left_cell]);\n        unsafe {\n            HAS_CYCLE = false;\n        }\n        // status = 0;\n        #[allow(static_mut_refs)]\n        graph.recalc(cols, arr, left_cell, formula_array, unsafe { \u0026mut HAS_CYCLE });\n        // println!(\"Graph recalculation complete\");\n        // println!(\"{}\", arr[left_cell]);\n        unsafe {\n            if HAS_CYCLE {\n                // Rollback to old value and reinsert old edges\n\n                // println!(\"Cycle detected, reverting to old value\");\n\n                // Step 1: Remove the edges added by the bad formula\n                let new_formula = formula_array[left_cell];\n                if (1..=8).contains(\u0026new_formula.op_type) {\n                    graph.delete_edge(new_formula.op_info1 as usize, left_cell);\n                    graph.delete_edge(new_formula.op_info2 as usize, left_cell);\n                } else if (9..=13).contains(\u0026new_formula.op_type) {\n                    graph.delete_range(left_cell);\n                } else if [1, 15].contains(\u0026new_formula.op_type) {\n                    graph.delete_edge(new_formula.op_info1 as usize, left_cell);\n                }\n\n                // Step 2: Restore the old formula and value\n                arr[left_cell] = old_value;\n                formula_array[left_cell] = old_formula;\n\n                // Step 3: Re-establish old edges\n                if (1..=8).contains(\u0026old_formula.op_type) {\n                    graph.add_edge(old_formula.op_info1 as usize, left_cell);\n                    graph.add_edge(old_formula.op_info2 as usize, left_cell);\n                } else if (9..=13).contains(\u0026old_formula.op_type) {\n                    graph.add_range_to_graph(\n                        old_formula.op_info1 as usize,\n                        old_formula.op_info2 as usize,\n                        left_cell,\n                    );\n                } else if [1, 15].contains(\u0026old_formula.op_type) {\n                    graph.add_edge(old_formula.op_info1 as usize, left_cell);\n                }\n\n                return -1;\n            }\n        }\n    }\n\n    status\n}\n","traces":[{"line":32,"address":[706480],"length":1,"stats":{"Line":18}},{"line":41,"address":[564979],"length":1,"stats":{"Line":17}},{"line":42,"address":[619991],"length":1,"stats":{"Line":0}},{"line":44,"address":[706645],"length":1,"stats":{"Line":17}},{"line":46,"address":[620091],"length":1,"stats":{"Line":17}},{"line":47,"address":[706727],"length":1,"stats":{"Line":17}},{"line":48,"address":[565139],"length":1,"stats":{"Line":17}},{"line":50,"address":[565147,565241],"length":1,"stats":{"Line":36}},{"line":51,"address":[605501,605709,604967],"length":1,"stats":{"Line":57}},{"line":52,"address":[202947],"length":1,"stats":{"Line":17}},{"line":53,"address":[707438],"length":1,"stats":{"Line":1}},{"line":55,"address":[565810,565855,566002],"length":1,"stats":{"Line":39}},{"line":56,"address":[654643],"length":1,"stats":{"Line":18}},{"line":57,"address":[637330,637194],"length":1,"stats":{"Line":20}},{"line":58,"address":[654821],"length":1,"stats":{"Line":19}},{"line":60,"address":[637177],"length":1,"stats":{"Line":3}},{"line":64,"address":[654268,654335],"length":1,"stats":{"Line":37}},{"line":65,"address":[706881],"length":1,"stats":{"Line":10}},{"line":68,"address":[620282,620375,620339],"length":1,"stats":{"Line":37}},{"line":69,"address":[654485,654411,654470],"length":1,"stats":{"Line":38}},{"line":71,"address":[598686,598719],"length":1,"stats":{"Line":37}},{"line":72,"address":[622084],"length":1,"stats":{"Line":2}},{"line":75,"address":[707187,707103],"length":1,"stats":{"Line":20}},{"line":78,"address":[655072],"length":1,"stats":{"Line":15}},{"line":79,"address":[707655],"length":1,"stats":{"Line":15}},{"line":97,"address":[637712],"length":1,"stats":{"Line":16}},{"line":106,"address":[566379,566440],"length":1,"stats":{"Line":16}},{"line":107,"address":[630552,630656,630493],"length":1,"stats":{"Line":32}},{"line":110,"address":[599730],"length":1,"stats":{"Line":16}},{"line":112,"address":[599773],"length":1,"stats":{"Line":16}},{"line":113,"address":[638088],"length":1,"stats":{"Line":16}},{"line":114,"address":[630795],"length":1,"stats":{"Line":2}},{"line":117,"address":[655632],"length":1,"stats":{"Line":16}},{"line":118,"address":[599904],"length":1,"stats":{"Line":16}},{"line":120,"address":[655736,655870,655795],"length":1,"stats":{"Line":32}},{"line":122,"address":[630958,630902],"length":1,"stats":{"Line":32}},{"line":123,"address":[204147],"length":1,"stats":{"Line":1}},{"line":126,"address":[606619],"length":1,"stats":{"Line":16}},{"line":127,"address":[708655],"length":1,"stats":{"Line":16}},{"line":128,"address":[623642],"length":1,"stats":{"Line":2}},{"line":132,"address":[204428,204379,204468],"length":1,"stats":{"Line":32}},{"line":133,"address":[708856,708745,708800],"length":1,"stats":{"Line":32}},{"line":136,"address":[600476],"length":1,"stats":{"Line":16}},{"line":137,"address":[567346],"length":1,"stats":{"Line":0}},{"line":138,"address":[656400],"length":1,"stats":{"Line":0}},{"line":139,"address":[656471],"length":1,"stats":{"Line":0}},{"line":141,"address":[204682],"length":1,"stats":{"Line":0}},{"line":142,"address":[709063],"length":1,"stats":{"Line":0}},{"line":146,"address":[623880],"length":1,"stats":{"Line":16}},{"line":148,"address":[639198,638819],"length":1,"stats":{"Line":17}},{"line":149,"address":[600801],"length":1,"stats":{"Line":1}},{"line":150,"address":[709455,709074],"length":1,"stats":{"Line":17}},{"line":151,"address":[656786],"length":1,"stats":{"Line":1}},{"line":152,"address":[656707,657088],"length":1,"stats":{"Line":17}},{"line":153,"address":[607651],"length":1,"stats":{"Line":1}},{"line":154,"address":[624468,624849],"length":1,"stats":{"Line":17}},{"line":155,"address":[623108],"length":1,"stats":{"Line":1}},{"line":156,"address":[601682,601301],"length":1,"stats":{"Line":17}},{"line":157,"address":[568427],"length":1,"stats":{"Line":1}},{"line":158,"address":[639861],"length":1,"stats":{"Line":1}},{"line":160,"address":[601494],"length":1,"stats":{"Line":16}},{"line":162,"address":[625080],"length":1,"stats":{"Line":3}},{"line":163,"address":[629899,630113],"length":1,"stats":{"Line":2}},{"line":164,"address":[647315,646604,646721,646844],"length":1,"stats":{"Line":5}},{"line":165,"address":[212432],"length":1,"stats":{"Line":1}},{"line":170,"address":[614911],"length":1,"stats":{"Line":1}},{"line":176,"address":[212473,212618],"length":1,"stats":{"Line":2}},{"line":179,"address":[608760],"length":1,"stats":{"Line":1}},{"line":180,"address":[664840,664682,664579],"length":1,"stats":{"Line":2}},{"line":185,"address":[615454],"length":1,"stats":{"Line":1}},{"line":190,"address":[615382],"length":1,"stats":{"Line":1}},{"line":197,"address":[575578],"length":1,"stats":{"Line":0}},{"line":201,"address":[638987],"length":1,"stats":{"Line":1}},{"line":203,"address":[640089,646406,639975],"length":1,"stats":{"Line":20}},{"line":204,"address":[625242],"length":1,"stats":{"Line":1}},{"line":206,"address":[568747,574817,574766],"length":1,"stats":{"Line":2}},{"line":208,"address":[638971,638936,638874],"length":1,"stats":{"Line":2}},{"line":211,"address":[716459],"length":1,"stats":{"Line":1}},{"line":214,"address":[608231,614417],"length":1,"stats":{"Line":28}},{"line":217,"address":[625438],"length":1,"stats":{"Line":14}},{"line":218,"address":[635632,635648],"length":1,"stats":{"Line":42}},{"line":221,"address":[640521],"length":1,"stats":{"Line":14}},{"line":222,"address":[659472,658108,659576],"length":1,"stats":{"Line":28}},{"line":224,"address":[659747,659544,659640],"length":1,"stats":{"Line":23}},{"line":226,"address":[625651,625822,625747],"length":1,"stats":{"Line":19}},{"line":229,"address":[607283,604130,604088,605142],"length":1,"stats":{"Line":31}},{"line":230,"address":[612931,613027,610616],"length":1,"stats":{"Line":8}},{"line":231,"address":[662610,662323,662419],"length":1,"stats":{"Line":8}},{"line":232,"address":[715070],"length":1,"stats":{"Line":4}},{"line":233,"address":[645055],"length":1,"stats":{"Line":4}},{"line":234,"address":[573797,573681],"length":1,"stats":{"Line":4}},{"line":235,"address":[628504],"length":1,"stats":{"Line":4}},{"line":236,"address":[715199],"length":1,"stats":{"Line":1}},{"line":237,"address":[210787],"length":1,"stats":{"Line":1}},{"line":238,"address":[630233],"length":1,"stats":{"Line":1}},{"line":239,"address":[573638],"length":1,"stats":{"Line":1}},{"line":240,"address":[628562],"length":1,"stats":{"Line":0}},{"line":245,"address":[628750,628821,629032],"length":1,"stats":{"Line":8}},{"line":246,"address":[604117,606382],"length":1,"stats":{"Line":10}},{"line":247,"address":[629359,627580,629107],"length":1,"stats":{"Line":2}},{"line":248,"address":[661622],"length":1,"stats":{"Line":1}},{"line":249,"address":[644229],"length":1,"stats":{"Line":1}},{"line":250,"address":[637057,636941],"length":1,"stats":{"Line":1}},{"line":251,"address":[572709],"length":1,"stats":{"Line":1}},{"line":252,"address":[661820],"length":1,"stats":{"Line":1}},{"line":253,"address":[636873],"length":1,"stats":{"Line":0}},{"line":254,"address":[210006],"length":1,"stats":{"Line":0}},{"line":255,"address":[612531],"length":1,"stats":{"Line":0}},{"line":256,"address":[629375],"length":1,"stats":{"Line":0}},{"line":261,"address":[612737,612867,612666],"length":1,"stats":{"Line":2}},{"line":262,"address":[605662,605108,604194],"length":1,"stats":{"Line":18}},{"line":263,"address":[209466,209235,208535],"length":1,"stats":{"Line":2}},{"line":264,"address":[611788],"length":1,"stats":{"Line":1}},{"line":265,"address":[611891],"length":1,"stats":{"Line":1}},{"line":266,"address":[627272,627323,627217],"length":1,"stats":{"Line":2}},{"line":267,"address":[661256],"length":1,"stats":{"Line":1}},{"line":268,"address":[572386,572435,572324],"length":1,"stats":{"Line":2}},{"line":270,"address":[208285],"length":1,"stats":{"Line":8}},{"line":271,"address":[604407],"length":1,"stats":{"Line":8}},{"line":272,"address":[611590,611249,611519],"length":1,"stats":{"Line":14}},{"line":274,"address":[660294],"length":1,"stats":{"Line":8}},{"line":275,"address":[643032,642913],"length":1,"stats":{"Line":4}},{"line":276,"address":[604655,604842],"length":1,"stats":{"Line":4}},{"line":277,"address":[611156,611338],"length":1,"stats":{"Line":4}},{"line":279,"address":[626638,626732,626451],"length":1,"stats":{"Line":4}},{"line":280,"address":[208897,208984],"length":1,"stats":{"Line":1}},{"line":282,"address":[604899],"length":1,"stats":{"Line":1}},{"line":285,"address":[627955],"length":1,"stats":{"Line":0}},{"line":289,"address":[605083],"length":1,"stats":{"Line":8}},{"line":292,"address":[571950,574152,574726,574684],"length":1,"stats":{"Line":23}},{"line":293,"address":[630851,630728,630687],"length":1,"stats":{"Line":2}},{"line":294,"address":[629085],"length":1,"stats":{"Line":0}},{"line":296,"address":[630737,630853,630788],"length":1,"stats":{"Line":2}},{"line":298,"address":[663326,663133,663308],"length":1,"stats":{"Line":16}},{"line":299,"address":[613987],"length":1,"stats":{"Line":0}},{"line":301,"address":[715898],"length":1,"stats":{"Line":8}},{"line":302,"address":[211527,211613],"length":1,"stats":{"Line":4}},{"line":303,"address":[631090,630999],"length":1,"stats":{"Line":4}},{"line":304,"address":[614130,614226],"length":1,"stats":{"Line":4}},{"line":306,"address":[211602,211810,211716],"length":1,"stats":{"Line":4}},{"line":307,"address":[631173,631260],"length":1,"stats":{"Line":1}},{"line":309,"address":[663582],"length":1,"stats":{"Line":1}},{"line":312,"address":[645870],"length":1,"stats":{"Line":0}},{"line":316,"address":[629670],"length":1,"stats":{"Line":13}},{"line":319,"address":[633279,632870],"length":1,"stats":{"Line":1}},{"line":320,"address":[624259],"length":1,"stats":{"Line":0}},{"line":322,"address":[609979,609108,610030],"length":1,"stats":{"Line":0}},{"line":323,"address":[634375,634437,634472],"length":1,"stats":{"Line":0}},{"line":324,"address":[625336],"length":1,"stats":{"Line":0}},{"line":327,"address":[710726,711055,711326],"length":1,"stats":{"Line":3}},{"line":328,"address":[609334,609385,609188],"length":1,"stats":{"Line":2}},{"line":329,"address":[609424,609456,609362],"length":1,"stats":{"Line":2}},{"line":330,"address":[658755],"length":1,"stats":{"Line":1}},{"line":331,"address":[603454,603075,602763],"length":1,"stats":{"Line":3}},{"line":332,"address":[569925],"length":1,"stats":{"Line":1}},{"line":333,"address":[569955,570072],"length":1,"stats":{"Line":1}},{"line":334,"address":[641656,641585,641763],"length":1,"stats":{"Line":2}},{"line":335,"address":[659235],"length":1,"stats":{"Line":1}},{"line":339,"address":[207029],"length":1,"stats":{"Line":1}},{"line":343,"address":[630869,630792,630835],"length":1,"stats":{"Line":2}},{"line":347,"address":[609259,609213,609117],"length":1,"stats":{"Line":2}},{"line":351,"address":[615699,615739],"length":1,"stats":{"Line":18}},{"line":357,"address":[615880,615788],"length":1,"stats":{"Line":1}},{"line":358,"address":[213275],"length":1,"stats":{"Line":1}},{"line":359,"address":[717827],"length":1,"stats":{"Line":0}},{"line":360,"address":[632865],"length":1,"stats":{"Line":0}},{"line":361,"address":[640264],"length":1,"stats":{"Line":1}},{"line":362,"address":[647857],"length":1,"stats":{"Line":1}},{"line":363,"address":[576273],"length":1,"stats":{"Line":0}},{"line":364,"address":[632974],"length":1,"stats":{"Line":0}},{"line":368,"address":[213582,213556,213487],"length":1,"stats":{"Line":2}},{"line":369,"address":[665511,665582,665456],"length":1,"stats":{"Line":2}},{"line":372,"address":[616211],"length":1,"stats":{"Line":1}},{"line":373,"address":[665641],"length":1,"stats":{"Line":0}},{"line":374,"address":[616343],"length":1,"stats":{"Line":0}},{"line":375,"address":[718158],"length":1,"stats":{"Line":1}},{"line":376,"address":[633319],"length":1,"stats":{"Line":0}},{"line":377,"address":[640775],"length":1,"stats":{"Line":0}},{"line":378,"address":[213841],"length":1,"stats":{"Line":0}},{"line":381,"address":[665687],"length":1,"stats":{"Line":1}},{"line":382,"address":[640829],"length":1,"stats":{"Line":0}},{"line":385,"address":[640797],"length":1,"stats":{"Line":1}},{"line":390,"address":[615552],"length":1,"stats":{"Line":1}}],"covered":153,"coverable":183},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","parser_ext.rs"],"content":"use crate::function_ext::Cell;\nuse crate::graph_ext::Formula;\nuse crate::graph_ext::Graph;\nuse crate::graph_ext::State;\n\nuse crate::function_ext::CellValue;\nuse crate::util_ext::{arithmetic_eval, return_optype};\n\n/// Checks if a character is an uppercase alphabet (A–Z)\npub fn is_alpha(c: char) -\u003e bool {\n    c.is_ascii_uppercase() \u0026\u0026 c.is_ascii_uppercase()\n}\n/// Checks if a character is a digit (0–9)\npub fn is_digit(c: char) -\u003e bool {\n    c.is_ascii_digit()\n}\n\n/// Parses a cell label (like \"B2\") into its flattened 1D array index\n/// Example: B2 in a 5-column grid → index = 1 + 1*5 = 6\npub fn cell_parser(a: \u0026str, c: i32, r: i32, start: usize, end: usize) -\u003e Result\u003ci32, \u0026'static str\u003e {\n    let mut cell_col = 0;\n    let mut cell_row = 0;\n    let mut digit_found = false;\n\n    if start \u003e= end || end \u003e= a.len() {\n        return Err(\"Invalid cell reference\");\n    }\n    for ch in a[start..=end].chars() {\n        if is_alpha(ch) {\n            if digit_found {\n                return Err(\"Letters after digits not allowed\");\n            }\n            cell_col = 26 * cell_col + (ch as u32 - 'A' as u32 + 1) as i32;\n        } else if is_digit(ch) {\n            cell_row = 10 * cell_row + (ch as u32 - '0' as u32) as i32;\n            digit_found = true;\n        } else {\n            return Err(\"Invalid character in cell reference\");\n        }\n    }\n\n    let cell_col = cell_col - 1;\n    let cell_row = cell_row - 1;\n\n    if cell_col \u003c 0 || cell_row \u003c 0 || cell_col \u003e= c || cell_row \u003e= r {\n        return Err(\"Cell reference out of bounds\");\n    }\n\n    Ok(c * cell_row + cell_col)\n}\n/* --------  parser.rs (or autofill.rs)  ---------- */\n\n/// Try to recognise the pattern in the first four integers.\n/// Returns \"AP\" | \"GP\" | \"FIB\" | \"CONST\" or None.\npub fn detect_pattern(base: \u0026[i32]) -\u003e Option\u003cString\u003e {\n    if base.len() \u003c 4 {\n        return None;\n    }\n    let [a, b, c, d] = [base[0], base[1], base[2], base[3]];\n\n    // 1. Arithmetic progression  (early‑return!)\n    if b - a == c - b \u0026\u0026 c - b == d - c {\n        return Some(\"AP\".to_string());\n    }\n\n    // 2. Geometric progression\n    if a != 0 \u0026\u0026 b % a == 0 \u0026\u0026 c % b == 0 \u0026\u0026 d % c == 0 {\n        let r = b / a;\n        if b == a * r \u0026\u0026 c == b * r \u0026\u0026 d == c * r {\n            return Some(\"GP\".to_string());\n        }\n    }\n\n    // 3. Fibonacci‑like\n    if c == a + b \u0026\u0026 d == b + c {\n        return Some(\"FIB\".to_string());\n    }\n\n    // 4. Constant\n    if a == b \u0026\u0026 b == c \u0026\u0026 c == d {\n        return Some(\"CONST\".to_string());\n    }\n\n    eprintln!(\"[autofill] seed = {:?} → pattern = None\", base);\n    None\n}\n\n/// Produce the full sequence given the four‑element seed and pattern tag.\npub fn generate_sequence(base: \u0026[i32], pattern: \u0026str, total_len: usize) -\u003e Vec\u003ci32\u003e {\n    let mut out = base.to_vec();\n\n    match pattern {\n        \"AP\" =\u003e {\n            let d = base[1] - base[0];\n            for i in 4..total_len {\n                out.push(out[i - 1] + d);\n            }\n        }\n        \"GP\" =\u003e {\n            let r = base[1] / base[0];\n            for i in 4..total_len {\n                out.push(out[i - 1] * r);\n            }\n        }\n        \"FIB\" =\u003e {\n            for i in 4..total_len {\n                out.push(out[i - 1] + out[i - 2]);\n            }\n        }\n        \"CONST\" =\u003e {\n            out.resize(total_len, base[0]);\n        }\n        _ =\u003e {} // unreachable\n    }\n    out\n}\n\n/// Fills a spreadsheet column with a recognized pattern (AP, GP, FIB, CONST).\n/// Requires the first 4 cells of the column to be valid integers.\npub fn autofill(\n    col_char: \u0026str,\n    length: usize,\n    cols: i32,\n    _rows: i32,\n    arr: \u0026mut [Cell],\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    let col_idx = col_char\n        .chars()\n        .fold(0, |acc, ch| acc * 26 + (ch as usize - b'A' as usize + 1))\n        .saturating_sub(1);\n    if col_idx \u003e= cols as usize {\n        return Err(\"Column index out of bounds\");\n    }\n\n    /* ----- collect first four seed cells ----- */\n    let mut seed = Vec::with_capacity(4);\n    for i in 0..4 {\n        let idx = i * cols as usize + col_idx;\n        if idx \u003e= arr.len() || !arr[idx].is_valid {\n            return Err(\"Autofill needs four valid integers\");\n        }\n        match arr[idx].value {\n            CellValue::Int(v) =\u003e seed.push(v),\n            _ =\u003e return Err(\"Only integer autofill supported\"),\n        }\n    }\n\n    /* ----- recognise pattern \u0026 build sequence ----- */\n    let tag = detect_pattern(\u0026seed).ok_or(\"Pattern not recognised\")?;\n    let sequence = generate_sequence(\u0026seed, \u0026tag, length.min(arr.len() / cols as usize));\n\n    /* ----- write sequence back into the column ----- */\n    for (row, val) in sequence.into_iter().enumerate() {\n        let idx = row * cols as usize + col_idx;\n        arr[idx] = Cell::new_int(val);\n    }\n    println!(\"[autofill] autofilled column {} to length {}\", col_char, length);\n    Ok(())\n}\n/// Parses and sets a value (int, float, string, or cell reference) into a target cell.\n/// It updates the formula graph accordingly and detects cycles.\n///\n/// # Arguments\n/// - `a`: Input string representing the formula.\n/// - `c`: Number of columns in the spreadsheet.\n/// - `r`: Number of rows in the spreadsheet.\n/// - `pos_equalto`: Position of '=' character in the input.\n/// - `pos_end`: End position of the formula string.\n/// - `arr`: Spreadsheet cell array.\n/// - `graph`: Dependency graph for recalculation.\n/// - `formula_array`: Formula metadata for each cell.\n/// - `state`: State to store previous values for rollback in case of cycles.\n#[allow(clippy::too_many_arguments)]\npub fn value_func(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    pos_equalto: usize,\n    pos_end: usize,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    // println!(\"value function\");\n    let first_cell = cell_parser(a, c, r, 0, pos_equalto - 1)?;\n    state.old_value = arr[first_cell as usize].clone();\n    state.old_op_type = formula_array[first_cell as usize].op_type;\n    state.old_op_info1 = formula_array[first_cell as usize].op_info1;\n    state.old_op_info2 = formula_array[first_cell as usize].op_info2;\n\n    if formula_array[first_cell as usize].op_type \u003e 0 {\n        graph.delete_edge(first_cell, c, formula_array);\n    }\n\n    let mut second_cell;\n    let mut is_cell = false;\n    let mut is_negative = false;\n\n    let mut pos = pos_equalto + 1;\n    if pos \u003c a.len() \u0026\u0026 (a[pos..].starts_with('-') || a[pos..].starts_with('+')) {\n        is_negative = a[pos..].starts_with('-');\n        pos += 1;\n    }\n\n    if a[pos..pos_end].starts_with('\"') \u0026\u0026 a[pos..pos_end].ends_with('\"') {\n        // Handle string values\n        let string_value = \u0026a[pos + 1..pos_end - 1]; // Remove surrounding quotes\n        arr[first_cell as usize] = Cell::new_string(string_value.to_string());\n        // println!(\"[debug] {:?}\", arr[first_cell as usize]);\n        graph.add_formula(first_cell, 0, 0, 16, formula_array);\n        graph.recalc(c, arr, first_cell, formula_array, state)?;\n        // println!(\"Stored string in cell {}: {}\", first_cell, string_value);\n\n        return Ok(());\n    } else if a[pos..pos_end].chars().all(is_digit) {\n        second_cell = a[pos..pos_end].parse::\u003ci32\u003e().map_err(|_| \"Invalid integer\")?;\n    } else if a[pos..pos_end].chars().any(|ch| ch == '.') {\n        let float_value = a[pos..pos_end].parse::\u003cf64\u003e().map_err(|_| \"Invalid float\")?;\n        arr[first_cell as usize] = Cell::new_float(float_value);\n        // println!(\"[DEBUG] Float value of cell : {:?}\", arr[first_cell as usize]);\n        // println!(\"[DEBUG] Float value: {}\", float_value);\n        graph.add_formula(first_cell, 0, 0, 17, formula_array);\n        // println!(\"[DEBUG] Float value of cell : {:?}\", arr[first_cell as usize]);\n\n        graph.recalc(c, arr, first_cell, formula_array, state)?;\n        // println!(\"[DEBUG] Float value of cell : {:?}\", arr[first_cell as usize]);\n\n        return Ok(());\n    } else {\n        second_cell = cell_parser(a, c, r, pos, pos_end - 1)?;\n        // println!(\"[DEBUG] Cell reference: {}\", second_cell);\n        is_cell = true;\n    }\n\n    // println!(\"[DEBUG] Before handling negative: second_cell = {}, is_negative = {}, is_cell = {}\", second_cell, is_negative, is_cell);\n    if is_negative \u0026\u0026 !is_cell {\n        second_cell = -second_cell;\n    }\n    // println!(\"[DEBUG] After handling negative: second_cell = {}\", second_cell);\n    // println!(\"[DEBUG] Value of second_cell: {:?}\", arr[second_cell as usize].value);\n    if !is_cell \u0026\u0026 !a[pos..pos_end].starts_with('\"') {\n        arr[first_cell as usize] = Cell::new_int(second_cell);\n        graph.add_formula(first_cell, second_cell, 0, 0, formula_array);\n        graph.recalc(c, arr, first_cell, formula_array, state)?;\n    } else if is_cell {\n        let value = if is_negative {\n            match arr[second_cell as usize].value {\n                CellValue::Int(i) =\u003e Cell::new_int(-i),\n                CellValue::Float(f) =\u003e Cell::new_float(-f),\n                _ =\u003e Cell::invalid(),\n            }\n        } else {\n            arr[second_cell as usize].clone()\n        };\n        // println!(\"[DEBUG] Value of second_cell: {:?}\", value.value);\n        arr[first_cell as usize] = value;\n        // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n        graph.add_edge(first_cell, second_cell as usize);\n        // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n\n        let op_type = -1;\n        // let mut v;\n        // if let CellValue::String(_) = arr[second_cell as usize].value {\n        //     v = \"\".to_string();\n        // } else if let CellValue::Float(_) = arr[second_cell as usize].value {\n        //     v = 0.0;\n        // } else {\n        //     v = 0;\n        // }\n\n        graph.add_formula(first_cell, second_cell, 0, op_type, formula_array);\n        // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n\n        graph.recalc(c, arr, first_cell, formula_array, state)?;\n        // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n    }\n\n    if state.has_cycle {\n        arr[first_cell as usize] = state.old_value.clone();\n        graph.delete_edge(first_cell, c, formula_array);\n        formula_array[first_cell as usize] = Formula {\n            op_type: state.old_op_type,\n            op_info1: state.old_op_info1,\n            op_info2: state.old_op_info2,\n        };\n        graph.add_edge_formula(first_cell, c, formula_array);\n        return Err(\"Cycle detected\");\n    }\n\n    Ok(())\n}\n/// Handles arithmetic operations of the form A1=B1+C1 or A1=5+B1 etc.\n/// Identifies operand types (cell or literal), builds graph edges, and computes result.\n///\n/// # Arguments\n/// Same as `value_func`.\n///\n/// # Errors\n/// Returns error if parsing fails or a circular dependency is introduced.\n#[allow(clippy::too_many_arguments)]\npub fn arth_op(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    pos_equalto: usize,\n    pos_end: usize,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    // println!(\"arithmetic operation\");\n    let mut operation = None;\n    let mut opindex = None;\n    // println!(\"[DEBUG] Parsing arithmetic operation: {}\", \u0026a[pos_equalto + 1..pos_end]);\n    for (i, ch) in a[pos_equalto + 1..pos_end].chars().enumerate() {\n        if \"+-*/\".contains(ch) \u0026\u0026 i + pos_equalto + 1 \u003e pos_equalto + 1 {\n            let prev = a[(i + pos_equalto)..].chars().next().unwrap();\n            if !\"+-*/\".contains(prev) {\n                operation = Some(ch);\n                opindex = Some(i + pos_equalto + 1);\n                break;\n            }\n        }\n    }\n\n    let (op, opindex) = operation.zip(opindex).ok_or(\"No valid operator found\")?;\n\n    let first_cell = cell_parser(a, c, r, 0, pos_equalto - 1)?;\n\n    state.old_value = arr[first_cell as usize].clone();\n    state.old_op_type = formula_array[first_cell as usize].op_type;\n    state.old_op_info1 = formula_array[first_cell as usize].op_info1;\n    state.old_op_info2 = formula_array[first_cell as usize].op_info2;\n\n    if formula_array[first_cell as usize].op_type \u003e 0 {\n        graph.delete_edge(first_cell, c, formula_array);\n    }\n\n    let second_cell;\n    let third_cell;\n    let mut is1cell = false;\n    let mut is2cell = false;\n    let mut sign1 = 1;\n    let mut sign2 = 1;\n\n    let mut start = pos_equalto + 1;\n    if a[start..].starts_with('-') {\n        sign1 = -1;\n        start += 1;\n    } else if a[start..].starts_with('+') {\n        start += 1;\n    }\n\n    let first_part = \u0026a[start..opindex];\n    if first_part.chars().any(is_alpha) {\n        second_cell = cell_parser(a, c, r, start, opindex - 1)?;\n        is1cell = true;\n    } else {\n        second_cell = first_part.parse::\u003ci32\u003e().map_err(|_| \"Invalid first operand\")? * sign1;\n    }\n\n    let mut second_start = opindex + 1;\n    if a[second_start..].starts_with('-') {\n        sign2 = -1;\n        second_start += 1;\n    } else if a[second_start..].starts_with('+') {\n        second_start += 1;\n    }\n\n    let second_part = \u0026a[second_start..pos_end];\n    if second_part.chars().any(is_alpha) {\n        third_cell = cell_parser(a, c, r, second_start, pos_end - 1)?;\n        is2cell = true;\n    } else {\n        third_cell = second_part.parse::\u003ci32\u003e().map_err(|_| \"Invalid second operand\")? * sign2;\n    }\n\n    match (is1cell, is2cell) {\n        (false, false) =\u003e {\n            let res = arithmetic_eval(Cell::new_int(second_cell), Cell::new_int(third_cell), op);\n            arr[first_cell as usize] = res.clone();\n            if let CellValue::Int(value) = res.value {\n                graph.add_formula(first_cell, value, 0, 0, formula_array);\n            } else if let CellValue::Float(value) = res.value {\n                graph.add_formula(first_cell, value as i32, 0, 17, formula_array);\n            } else {\n                return Err(\"Unsupported value type for arithmetic operation\");\n            }\n            // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n            // println!(\"operation: {:?} {} {:?}\", arr[first_cell as usize].value, return_optype(op), arr[third_cell as usize].value);\n        }\n        (true, false) =\u003e {\n            graph.add_edge(first_cell, second_cell as usize);\n            graph.add_formula(\n                first_cell,\n                second_cell,\n                third_cell,\n                return_optype(op),\n                formula_array,\n            );\n        }\n        (false, true) =\u003e {\n            graph.add_edge(first_cell, third_cell as usize);\n            let op_type = if op == '/' { 15 } else { return_optype(op) };\n            graph.add_formula(first_cell, second_cell, third_cell, op_type, formula_array);\n        }\n        (true, true) =\u003e {\n            graph.add_edge(first_cell, second_cell as usize);\n            graph.add_edge(first_cell, third_cell as usize);\n            graph.add_formula(\n                first_cell,\n                second_cell,\n                third_cell,\n                return_optype(op) + 4,\n                formula_array,\n            );\n        }\n    };\n    // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n\n    graph.recalc(c, arr, first_cell, formula_array, state)?;\n    // println!(\"[DEBUG] Value of first_cell: {:?}\", arr[first_cell as usize].value);\n    if state.has_cycle {\n        arr[first_cell as usize] = state.old_value.clone();\n        graph.delete_edge(first_cell, c, formula_array);\n        formula_array[first_cell as usize] = Formula {\n            op_type: state.old_op_type,\n            op_info1: state.old_op_info1,\n            op_info2: state.old_op_info2,\n        };\n        graph.add_edge_formula(first_cell, c, formula_array);\n        return Err(\"Cycle detected\");\n    }\n\n    Ok(())\n}\n/// Handles range-based functions like SUM(A1:B2), AVG, MIN, etc.\n/// Parses start and end of range, inserts the formula, and calculates the result.\n///\n/// # Arguments\n/// - `op_type`: An integer representing the function type (9 = MIN, 10 = MAX, ..., 13 = STDEV).\n///\n/// # Errors\n/// Returns error if parsing fails or a cycle is detected.\n#[allow(clippy::too_many_arguments)]\npub fn range_func(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    pos_equalto: usize,\n    _pos_end: usize,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State,\n    op_type: i32,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    let first_cell = cell_parser(a, c, r, 0, pos_equalto - 1)?;\n    state.old_value = arr[first_cell as usize].clone();\n    state.old_op_type = formula_array[first_cell as usize].op_type;\n    state.old_op_info1 = formula_array[first_cell as usize].op_info1;\n    state.old_op_info2 = formula_array[first_cell as usize].op_info2;\n\n    if formula_array[first_cell as usize].op_type \u003e 0 {\n        graph.delete_edge(first_cell, c, formula_array);\n    }\n\n    let eq_str = \u0026a[pos_equalto..];\n    let open_paren =\n        eq_str.find('(').map(|i| i + pos_equalto).ok_or(\"Missing opening parenthesis\")?;\n    let close_paren =\n        eq_str.find(')').map(|i| i + pos_equalto).ok_or(\"Missing closing parenthesis\")?;\n    let colon_pos =\n        a[open_paren + 1..].find(':').map(|i| i + open_paren + 1).ok_or(\"Missing colon\")?;\n\n    let range_start = cell_parser(a, c, r, open_paren + 1, colon_pos - 1)?;\n    let range_end = cell_parser(a, c, r, colon_pos + 1, close_paren - 1)?;\n\n    graph.add_formula(first_cell, range_start, range_end, op_type, formula_array);\n    graph.add_range_to_graph(range_start, range_end, first_cell);\n    graph.recalc(c, arr, first_cell, formula_array, state)?;\n\n    if state.has_cycle {\n        arr[first_cell as usize] = state.old_value.clone();\n        graph.delete_edge(first_cell, c, formula_array);\n        formula_array[first_cell as usize] = Formula {\n            op_type: state.old_op_type,\n            op_info1: state.old_op_info1,\n            op_info2: state.old_op_info2,\n        };\n        graph.add_edge_formula(first_cell, c, formula_array);\n        return Err(\"Cycle detected\");\n    }\n    Ok(())\n}\n/// Handles the SLEEP(n) function which pauses execution for `n` seconds.\n/// `n` can either be a literal or a reference to another cell.\n/// Updates the formula graph and triggers recalculation.\n///\n/// # Errors\n/// Returns error if the value is invalid or a cycle is introduced.\n#[allow(clippy::too_many_arguments)]\npub fn sleep_func(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    pos_equalto: usize,\n    _pos_end: usize,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    let target_cell = cell_parser(a, c, r, 0, pos_equalto - 1)?;\n    state.old_value = arr[target_cell as usize].clone();\n    state.old_op_type = formula_array[target_cell as usize].op_type;\n    state.old_op_info1 = formula_array[target_cell as usize].op_info1;\n    state.old_op_info2 = formula_array[target_cell as usize].op_info2;\n\n    if formula_array[target_cell as usize].op_type \u003e 0 {\n        graph.delete_edge(target_cell, c, formula_array);\n    }\n\n    let eq_str = \u0026a[pos_equalto..];\n    let open_paren =\n        eq_str.find('(').map(|i| i + pos_equalto).ok_or(\"Missing opening parenthesis\")?;\n    let close_paren =\n        eq_str.find(')').map(|i| i + pos_equalto).ok_or(\"Missing closing parenthesis\")?;\n\n    let ref_cell = cell_parser(a, c, r, open_paren + 1, close_paren - 1);\n    if let Ok(ref_cell) = ref_cell {\n        graph.add_formula(target_cell, ref_cell, ref_cell, 14, formula_array);\n        graph.add_edge(target_cell, ref_cell as usize);\n    } else {\n        let sleep_str = \u0026a[open_paren + 1..close_paren];\n        let sleep_value = sleep_str.parse::\u003ci32\u003e().map_err(|_| \"Invalid sleep value\")?;\n        graph.add_formula(target_cell, target_cell, sleep_value, 14, formula_array);\n    }\n\n    graph.recalc(c, arr, target_cell, formula_array, state)?;\n\n    if state.has_cycle {\n        arr[target_cell as usize] = state.old_value.clone();\n        graph.delete_edge(target_cell, c, formula_array);\n        formula_array[target_cell as usize] = Formula {\n            op_type: state.old_op_type,\n            op_info1: state.old_op_info1,\n            op_info2: state.old_op_info2,\n        };\n        graph.add_edge_formula(target_cell, c, formula_array);\n        return Err(\"Cycle detected\");\n    }\n    Ok(())\n}\n/// Master parser function that identifies the type of formula (value, arithmetic, function, autofill)\n/// and delegates to the appropriate handler.\n/// Handles cycle detection rollback, function dispatching, and runtime formula parsing.\n///\n/// # Arguments\n/// - `a`: Formula string to parse and execute.\n/// - `c`, `r`: Number of columns and rows.\n/// - `arr`: The spreadsheet’s cell array.\n/// - `graph`: The dependency graph used for topological sorting and cycle detection.\n/// - `formula_array`: Formula metadata array.\n/// - `state`: Context that keeps track of old values for undo during cycle resolution.\n///\n/// # Errors\n/// - Returns a string-based error if parsing or execution fails.\n/// - Detects mixed formulas (e.g., MIN(1:2) + 5) as invalid.\npub fn parser(\n    a: \u0026str,\n    c: i32,\n    r: i32,\n    arr: \u0026mut [Cell],\n    graph: \u0026mut Graph,\n    formula_array: \u0026mut [Formula],\n    state: \u0026mut State,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n    state.num_cells = c as usize * r as usize;\n    if a.starts_with('w') || a.starts_with('d') || a.starts_with('a') || a.starts_with('s') {\n        return Ok(());\n    }\n    println!(\"a: {}\", a);\n    if a.starts_with(\"=autofill\") {\n        println!(\"hi\");\n        let parts: Vec\u003c\u0026str\u003e = a.split_whitespace().collect();\n        if parts.len() != 3 {\n            return Err(\"Usage: autofill \u003ccolumn\u003e \u003clength\u003e\");\n        }\n        let col = parts[1];\n        println!(\"col: {}\", col);\n        let length = parts[2].parse::\u003cusize\u003e().map_err(|_| \"Invalid length\")?;\n        println!(\"here\");\n        return autofill(col, length, c, r, arr);\n    }\n    let pos_equalto = a.find('=').ok_or(\"No equals sign found\")?;\n    let pos_end = a.len();\n\n    let mut value = false;\n    let mut arth_exp = false;\n    let mut func = false;\n    let mut found_digit = false;\n\n    for ch in a[pos_equalto + 1..pos_end].chars() {\n        if ch == '(' {\n            func = true;\n            break;\n        }\n        if is_digit(ch) {\n            found_digit = true;\n        }\n        if \"+-*/\".contains(ch) \u0026\u0026 found_digit {\n            arth_exp = true;\n            break;\n        }\n    }\n\n    if !func \u0026\u0026 !arth_exp {\n        value = true;\n    }\n\n    if func \u0026\u0026 arth_exp {\n        return Err(\"Invalid input: Cannot mix function and arithmetic\");\n    }\n\n    if value {\n        value_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?;\n    } else if arth_exp {\n        arth_op(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?;\n    } else if func {\n        let func_name = \u0026a[pos_equalto + 1..a[pos_equalto..].find('(').unwrap() + pos_equalto];\n        println!(\"[DEBUG] Function name: {}\", func_name);\n        match func_name {\n            \"MIN\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 9)?\n            }\n            \"MAX\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 10)?\n            }\n            \"AVG\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 11)?\n            }\n            \"SUM\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 12)?\n            }\n            \"STDEV\" =\u003e {\n                range_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state, 13)?\n            }\n            \"SLEEP\" =\u003e sleep_func(a, c, r, pos_equalto, pos_end, arr, graph, formula_array, state)?,\n\n            _ =\u003e return Err(\"Unknown function\"),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":10,"address":[520080],"length":1,"stats":{"Line":5}},{"line":11,"address":[243316],"length":1,"stats":{"Line":5}},{"line":14,"address":[520128],"length":1,"stats":{"Line":5}},{"line":15,"address":[520133],"length":1,"stats":{"Line":5}},{"line":20,"address":[520160],"length":1,"stats":{"Line":6}},{"line":21,"address":[575501],"length":1,"stats":{"Line":6}},{"line":22,"address":[509541],"length":1,"stats":{"Line":6}},{"line":23,"address":[509549],"length":1,"stats":{"Line":6}},{"line":25,"address":[476146],"length":1,"stats":{"Line":6}},{"line":26,"address":[509592],"length":1,"stats":{"Line":1}},{"line":28,"address":[520345,520488],"length":1,"stats":{"Line":10}},{"line":29,"address":[243735,244344,244161],"length":1,"stats":{"Line":18}},{"line":30,"address":[244015],"length":1,"stats":{"Line":5}},{"line":31,"address":[576229],"length":1,"stats":{"Line":2}},{"line":33,"address":[476994,476880,476827],"length":1,"stats":{"Line":10}},{"line":34,"address":[244004],"length":1,"stats":{"Line":5}},{"line":35,"address":[458749,458859],"length":1,"stats":{"Line":8}},{"line":36,"address":[476801],"length":1,"stats":{"Line":8}},{"line":38,"address":[509657],"length":1,"stats":{"Line":1}},{"line":42,"address":[243700,243781,243757],"length":1,"stats":{"Line":12}},{"line":43,"address":[517343,517288,517329],"length":1,"stats":{"Line":12}},{"line":45,"address":[520584,520649,520611],"length":1,"stats":{"Line":18}},{"line":46,"address":[496797],"length":1,"stats":{"Line":2}},{"line":49,"address":[542769,542839],"length":1,"stats":{"Line":4}},{"line":55,"address":[459072],"length":1,"stats":{"Line":4}},{"line":56,"address":[497361],"length":1,"stats":{"Line":4}},{"line":57,"address":[459143],"length":1,"stats":{"Line":2}},{"line":59,"address":[510476,510861,510521],"length":1,"stats":{"Line":8}},{"line":62,"address":[521563,521695,521610],"length":1,"stats":{"Line":10}},{"line":63,"address":[497949],"length":1,"stats":{"Line":2}},{"line":67,"address":[498052,497849],"length":1,"stats":{"Line":4}},{"line":68,"address":[511432,511526],"length":1,"stats":{"Line":1}},{"line":69,"address":[522270,522232],"length":1,"stats":{"Line":2}},{"line":70,"address":[577649],"length":1,"stats":{"Line":1}},{"line":75,"address":[459772,460456,460408],"length":1,"stats":{"Line":3}},{"line":76,"address":[577825],"length":1,"stats":{"Line":1}},{"line":80,"address":[544614,544872],"length":1,"stats":{"Line":1}},{"line":81,"address":[478672],"length":1,"stats":{"Line":0}},{"line":84,"address":[511928],"length":1,"stats":{"Line":1}},{"line":85,"address":[577998],"length":1,"stats":{"Line":1}},{"line":89,"address":[544976,547023],"length":1,"stats":{"Line":2}},{"line":90,"address":[499159],"length":1,"stats":{"Line":2}},{"line":93,"address":[478888,478965],"length":1,"stats":{"Line":8}},{"line":94,"address":[480515,479021,480362],"length":1,"stats":{"Line":4}},{"line":95,"address":[500793,500850],"length":1,"stats":{"Line":4}},{"line":96,"address":[580024],"length":1,"stats":{"Line":2}},{"line":99,"address":[512455,512395],"length":1,"stats":{"Line":4}},{"line":100,"address":[246439,247135,247366],"length":1,"stats":{"Line":2}},{"line":101,"address":[513068,513005],"length":1,"stats":{"Line":2}},{"line":102,"address":[247498],"length":1,"stats":{"Line":1}},{"line":105,"address":[512537,512477],"length":1,"stats":{"Line":2}},{"line":106,"address":[499489,499708],"length":1,"stats":{"Line":2}},{"line":107,"address":[461574],"length":1,"stats":{"Line":1}},{"line":110,"address":[578603,578527],"length":1,"stats":{"Line":3}},{"line":111,"address":[479300],"length":1,"stats":{"Line":1}},{"line":115,"address":[499553],"length":1,"stats":{"Line":2}},{"line":120,"address":[549019,549476,547056],"length":1,"stats":{"Line":7}},{"line":127,"address":[580301],"length":1,"stats":{"Line":7}},{"line":129,"address":[600905,600880],"length":1,"stats":{"Line":14}},{"line":131,"address":[248285],"length":1,"stats":{"Line":7}},{"line":132,"address":[525218],"length":1,"stats":{"Line":1}},{"line":136,"address":[521894],"length":1,"stats":{"Line":6}},{"line":137,"address":[521939,522195,522062],"length":1,"stats":{"Line":13}},{"line":138,"address":[250121,250059,248590],"length":1,"stats":{"Line":12}},{"line":139,"address":[527045,527136,527085],"length":1,"stats":{"Line":18}},{"line":140,"address":[503268],"length":1,"stats":{"Line":1}},{"line":142,"address":[516476],"length":1,"stats":{"Line":6}},{"line":143,"address":[582623,582550],"length":1,"stats":{"Line":10}},{"line":144,"address":[527343],"length":1,"stats":{"Line":1}},{"line":149,"address":[547500,547806,549038,547593],"length":1,"stats":{"Line":8}},{"line":150,"address":[581093,580929],"length":1,"stats":{"Line":4}},{"line":153,"address":[526169,525991,526896,526206],"length":1,"stats":{"Line":14}},{"line":154,"address":[482112,482358,482430],"length":1,"stats":{"Line":8}},{"line":155,"address":[523653,523291,523344],"length":1,"stats":{"Line":8}},{"line":157,"address":[581513],"length":1,"stats":{"Line":4}},{"line":158,"address":[515684],"length":1,"stats":{"Line":4}},{"line":174,"address":[527497,524160,527465],"length":1,"stats":{"Line":6}},{"line":186,"address":[583149,582913],"length":1,"stats":{"Line":7}},{"line":187,"address":[549980,550079],"length":1,"stats":{"Line":10}},{"line":188,"address":[550302,550401],"length":1,"stats":{"Line":5}},{"line":189,"address":[504536,504582,504448],"length":1,"stats":{"Line":6}},{"line":190,"address":[251510,251556,251422],"length":1,"stats":{"Line":10}},{"line":192,"address":[504650,504715],"length":1,"stats":{"Line":10}},{"line":193,"address":[550762],"length":1,"stats":{"Line":0}},{"line":197,"address":[583841],"length":1,"stats":{"Line":5}},{"line":198,"address":[517449],"length":1,"stats":{"Line":5}},{"line":200,"address":[525497,525450,525361],"length":1,"stats":{"Line":10}},{"line":201,"address":[550802,550948,551157],"length":1,"stats":{"Line":11}},{"line":202,"address":[584221],"length":1,"stats":{"Line":1}},{"line":203,"address":[505196,505242],"length":1,"stats":{"Line":1}},{"line":206,"address":[466705,467122],"length":1,"stats":{"Line":6}},{"line":208,"address":[256581,256410,252285],"length":1,"stats":{"Line":2}},{"line":209,"address":[589441,588792,588894],"length":1,"stats":{"Line":2}},{"line":211,"address":[510131],"length":1,"stats":{"Line":1}},{"line":212,"address":[523318,523407],"length":1,"stats":{"Line":1}},{"line":215,"address":[534110],"length":1,"stats":{"Line":1}},{"line":216,"address":[527527,526662,525858],"length":1,"stats":{"Line":6}},{"line":217,"address":[520034,518686,520060],"length":1,"stats":{"Line":2}},{"line":218,"address":[518155],"length":1,"stats":{"Line":9}},{"line":219,"address":[526771,526840,526385],"length":1,"stats":{"Line":2}},{"line":220,"address":[506902,506343,506213],"length":1,"stats":{"Line":2}},{"line":223,"address":[486347],"length":1,"stats":{"Line":1}},{"line":226,"address":[519406,519495],"length":1,"stats":{"Line":1}},{"line":229,"address":[585878],"length":1,"stats":{"Line":1}},{"line":231,"address":[252820,252599,252936],"length":1,"stats":{"Line":5}},{"line":233,"address":[526654],"length":1,"stats":{"Line":1}},{"line":237,"address":[252998,253870,253913],"length":1,"stats":{"Line":3}},{"line":238,"address":[527659,527624],"length":1,"stats":{"Line":1}},{"line":242,"address":[468766,468867],"length":1,"stats":{"Line":2}},{"line":243,"address":[254016,254640],"length":1,"stats":{"Line":1}},{"line":244,"address":[586636],"length":1,"stats":{"Line":1}},{"line":245,"address":[531474,531569],"length":1,"stats":{"Line":1}},{"line":246,"address":[486863],"length":1,"stats":{"Line":1}},{"line":247,"address":[586905],"length":1,"stats":{"Line":1}},{"line":248,"address":[508091,507879],"length":1,"stats":{"Line":0}},{"line":249,"address":[521435,521306],"length":1,"stats":{"Line":0}},{"line":250,"address":[520917],"length":1,"stats":{"Line":0}},{"line":251,"address":[587380],"length":1,"stats":{"Line":0}},{"line":254,"address":[528495,528427],"length":1,"stats":{"Line":2}},{"line":257,"address":[254802,256392,255197],"length":1,"stats":{"Line":2}},{"line":259,"address":[255486],"length":1,"stats":{"Line":1}},{"line":262,"address":[524406],"length":1,"stats":{"Line":6}},{"line":272,"address":[529297],"length":1,"stats":{"Line":1}},{"line":275,"address":[521913],"length":1,"stats":{"Line":1}},{"line":279,"address":[531554],"length":1,"stats":{"Line":1}},{"line":280,"address":[530143,529552],"length":1,"stats":{"Line":0}},{"line":281,"address":[256154],"length":1,"stats":{"Line":0}},{"line":282,"address":[471135,471295],"length":1,"stats":{"Line":0}},{"line":283,"address":[471126],"length":1,"stats":{"Line":0}},{"line":284,"address":[256185],"length":1,"stats":{"Line":0}},{"line":285,"address":[471132],"length":1,"stats":{"Line":0}},{"line":287,"address":[522604],"length":1,"stats":{"Line":0}},{"line":288,"address":[509506],"length":1,"stats":{"Line":0}},{"line":291,"address":[255756],"length":1,"stats":{"Line":1}},{"line":302,"address":[556320,561831],"length":1,"stats":{"Line":4}},{"line":314,"address":[531222],"length":1,"stats":{"Line":1}},{"line":315,"address":[556601],"length":1,"stats":{"Line":4}},{"line":317,"address":[511032,510693],"length":1,"stats":{"Line":5}},{"line":318,"address":[590149],"length":1,"stats":{"Line":1}},{"line":319,"address":[535253,535104],"length":1,"stats":{"Line":4}},{"line":320,"address":[511401],"length":1,"stats":{"Line":1}},{"line":321,"address":[258223],"length":1,"stats":{"Line":4}},{"line":322,"address":[524161],"length":1,"stats":{"Line":1}},{"line":328,"address":[510932,511724,511637],"length":1,"stats":{"Line":5}},{"line":330,"address":[491525,491393,491661],"length":1,"stats":{"Line":5}},{"line":332,"address":[524620,524719],"length":1,"stats":{"Line":5}},{"line":333,"address":[532846,532945],"length":1,"stats":{"Line":4}},{"line":334,"address":[474214,474080,474168],"length":1,"stats":{"Line":5}},{"line":335,"address":[525243,525109,525197],"length":1,"stats":{"Line":5}},{"line":337,"address":[512603,512538],"length":1,"stats":{"Line":5}},{"line":338,"address":[259499],"length":1,"stats":{"Line":0}},{"line":343,"address":[558577],"length":1,"stats":{"Line":1}},{"line":344,"address":[259412],"length":1,"stats":{"Line":4}},{"line":345,"address":[558593],"length":1,"stats":{"Line":1}},{"line":346,"address":[533260],"length":1,"stats":{"Line":4}},{"line":348,"address":[474528,474439,474580],"length":1,"stats":{"Line":5}},{"line":349,"address":[492863,492488],"length":1,"stats":{"Line":1}},{"line":350,"address":[259658],"length":1,"stats":{"Line":0}},{"line":351,"address":[474903,474916,474671],"length":1,"stats":{"Line":0}},{"line":352,"address":[536692,536954],"length":1,"stats":{"Line":5}},{"line":353,"address":[536913,536959],"length":1,"stats":{"Line":1}},{"line":356,"address":[533561],"length":1,"stats":{"Line":1}},{"line":357,"address":[513044,513492,513732],"length":1,"stats":{"Line":8}},{"line":358,"address":[513616,513333,513737],"length":1,"stats":{"Line":2}},{"line":359,"address":[493420],"length":1,"stats":{"Line":1}},{"line":361,"address":[283335,283328],"length":1,"stats":{"Line":6}},{"line":364,"address":[559799,559747,559438],"length":1,"stats":{"Line":2}},{"line":365,"address":[260919,260568],"length":1,"stats":{"Line":1}},{"line":366,"address":[534535],"length":1,"stats":{"Line":0}},{"line":367,"address":[593269,593042,593256],"length":1,"stats":{"Line":0}},{"line":368,"address":[514158,513911],"length":1,"stats":{"Line":4}},{"line":369,"address":[475867,475907],"length":1,"stats":{"Line":0}},{"line":372,"address":[526697],"length":1,"stats":{"Line":1}},{"line":373,"address":[534654,535078,535284],"length":1,"stats":{"Line":7}},{"line":374,"address":[535168,535289,534928],"length":1,"stats":{"Line":4}},{"line":375,"address":[560620],"length":1,"stats":{"Line":2}},{"line":377,"address":[527176,526895,527064],"length":1,"stats":{"Line":3}},{"line":380,"address":[535359,535096],"length":1,"stats":{"Line":4}},{"line":382,"address":[593878,593989,595005],"length":1,"stats":{"Line":2}},{"line":383,"address":[494728,495585,494794],"length":1,"stats":{"Line":4}},{"line":384,"address":[561328],"length":1,"stats":{"Line":2}},{"line":385,"address":[515561,515493],"length":1,"stats":{"Line":2}},{"line":386,"address":[528285,528188],"length":1,"stats":{"Line":2}},{"line":387,"address":[495335,495436],"length":1,"stats":{"Line":2}},{"line":389,"address":[594766],"length":1,"stats":{"Line":0}},{"line":395,"address":[516068],"length":1,"stats":{"Line":1}},{"line":396,"address":[595231],"length":1,"stats":{"Line":1}},{"line":398,"address":[477833],"length":1,"stats":{"Line":1}},{"line":399,"address":[495796],"length":1,"stats":{"Line":1}},{"line":400,"address":[516111],"length":1,"stats":{"Line":1}},{"line":405,"address":[514882],"length":1,"stats":{"Line":1}},{"line":406,"address":[539776,538727],"length":1,"stats":{"Line":2}},{"line":407,"address":[536592],"length":1,"stats":{"Line":1}},{"line":410,"address":[528861],"length":1,"stats":{"Line":1}},{"line":411,"address":[516218],"length":1,"stats":{"Line":1}},{"line":412,"address":[528995],"length":1,"stats":{"Line":1}},{"line":414,"address":[262908],"length":1,"stats":{"Line":1}},{"line":415,"address":[262919],"length":1,"stats":{"Line":1}},{"line":416,"address":[495957,496034],"length":1,"stats":{"Line":1}},{"line":423,"address":[262494,263037],"length":1,"stats":{"Line":2}},{"line":425,"address":[529466],"length":1,"stats":{"Line":1}},{"line":426,"address":[595533,596124],"length":1,"stats":{"Line":0}},{"line":427,"address":[537414],"length":1,"stats":{"Line":0}},{"line":428,"address":[478620,478780],"length":1,"stats":{"Line":0}},{"line":429,"address":[263528],"length":1,"stats":{"Line":0}},{"line":430,"address":[537446],"length":1,"stats":{"Line":0}},{"line":431,"address":[540697],"length":1,"stats":{"Line":0}},{"line":433,"address":[537561],"length":1,"stats":{"Line":0}},{"line":434,"address":[596063],"length":1,"stats":{"Line":0}},{"line":437,"address":[478180],"length":1,"stats":{"Line":2}},{"line":448,"address":[544413,544445,540912],"length":1,"stats":{"Line":1}},{"line":460,"address":[530651,530439],"length":1,"stats":{"Line":2}},{"line":461,"address":[497325,497226],"length":1,"stats":{"Line":3}},{"line":462,"address":[563772,563871],"length":1,"stats":{"Line":1}},{"line":463,"address":[538628,538494,538582],"length":1,"stats":{"Line":3}},{"line":464,"address":[541974,541843,541931],"length":1,"stats":{"Line":3}},{"line":466,"address":[531283,531224],"length":1,"stats":{"Line":2}},{"line":467,"address":[531122],"length":1,"stats":{"Line":1}},{"line":470,"address":[564162],"length":1,"stats":{"Line":2}},{"line":471,"address":[564391,564215,564540],"length":1,"stats":{"Line":6}},{"line":473,"address":[518686,518751,518503],"length":1,"stats":{"Line":7}},{"line":475,"address":[283520,283534],"length":1,"stats":{"Line":7}},{"line":478,"address":[565246,565039,564928],"length":1,"stats":{"Line":3}},{"line":479,"address":[598469,598877,598382],"length":1,"stats":{"Line":3}},{"line":481,"address":[543453],"length":1,"stats":{"Line":1}},{"line":482,"address":[266287],"length":1,"stats":{"Line":2}},{"line":483,"address":[532559,532403],"length":1,"stats":{"Line":1}},{"line":485,"address":[540455],"length":1,"stats":{"Line":1}},{"line":486,"address":[519972,520602,520060],"length":1,"stats":{"Line":0}},{"line":487,"address":[500071],"length":1,"stats":{"Line":0}},{"line":488,"address":[544397,544237],"length":1,"stats":{"Line":0}},{"line":489,"address":[267019],"length":1,"stats":{"Line":0}},{"line":490,"address":[520407],"length":1,"stats":{"Line":0}},{"line":491,"address":[533514],"length":1,"stats":{"Line":0}},{"line":493,"address":[482266],"length":1,"stats":{"Line":0}},{"line":494,"address":[500224],"length":1,"stats":{"Line":0}},{"line":496,"address":[543774],"length":1,"stats":{"Line":1}},{"line":505,"address":[267248,270328,270356],"length":1,"stats":{"Line":5}},{"line":516,"address":[482829,482617],"length":1,"stats":{"Line":5}},{"line":517,"address":[541743,541644],"length":1,"stats":{"Line":10}},{"line":518,"address":[501086,501173],"length":1,"stats":{"Line":5}},{"line":519,"address":[268051,268130,268170],"length":1,"stats":{"Line":10}},{"line":520,"address":[542237,542118,542197],"length":1,"stats":{"Line":10}},{"line":522,"address":[534794,534738],"length":1,"stats":{"Line":10}},{"line":523,"address":[535065],"length":1,"stats":{"Line":1}},{"line":526,"address":[542329],"length":1,"stats":{"Line":4}},{"line":527,"address":[598638,598624],"length":1,"stats":{"Line":20}},{"line":529,"address":[546012,545827,546049],"length":1,"stats":{"Line":18}},{"line":532,"address":[501905,502118,501992],"length":1,"stats":{"Line":6}},{"line":533,"address":[535573,535495],"length":1,"stats":{"Line":6}},{"line":534,"address":[535591],"length":1,"stats":{"Line":2}},{"line":535,"address":[546348],"length":1,"stats":{"Line":2}},{"line":537,"address":[269317,269469,269126],"length":1,"stats":{"Line":4}},{"line":538,"address":[602045,601840,602008],"length":1,"stats":{"Line":4}},{"line":539,"address":[484694],"length":1,"stats":{"Line":2}},{"line":542,"address":[568546,568975],"length":1,"stats":{"Line":3}},{"line":544,"address":[602119],"length":1,"stats":{"Line":1}},{"line":545,"address":[543716,543804,544346],"length":1,"stats":{"Line":0}},{"line":546,"address":[547367],"length":1,"stats":{"Line":0}},{"line":547,"address":[523741,523581],"length":1,"stats":{"Line":0}},{"line":548,"address":[547396],"length":1,"stats":{"Line":0}},{"line":549,"address":[485319],"length":1,"stats":{"Line":0}},{"line":550,"address":[569498],"length":1,"stats":{"Line":0}},{"line":552,"address":[547514],"length":1,"stats":{"Line":0}},{"line":553,"address":[523696],"length":1,"stats":{"Line":0}},{"line":555,"address":[569038],"length":1,"stats":{"Line":1}},{"line":572,"address":[541761,536912],"length":1,"stats":{"Line":2}},{"line":581,"address":[537099,537174],"length":1,"stats":{"Line":12}},{"line":582,"address":[603208,603109,603158],"length":1,"stats":{"Line":18}},{"line":583,"address":[524119],"length":1,"stats":{"Line":0}},{"line":585,"address":[570118],"length":1,"stats":{"Line":12}},{"line":586,"address":[486039],"length":1,"stats":{"Line":4}},{"line":587,"address":[271002],"length":1,"stats":{"Line":1}},{"line":588,"address":[537603],"length":1,"stats":{"Line":1}},{"line":589,"address":[548401,551852],"length":1,"stats":{"Line":2}},{"line":590,"address":[528070],"length":1,"stats":{"Line":1}},{"line":592,"address":[607179,607106],"length":1,"stats":{"Line":0}},{"line":593,"address":[507826],"length":1,"stats":{"Line":0}},{"line":594,"address":[540898,541095,541311],"length":1,"stats":{"Line":0}},{"line":595,"address":[274881,274962],"length":1,"stats":{"Line":0}},{"line":596,"address":[552365],"length":1,"stats":{"Line":0}},{"line":598,"address":[548423,548550,548157],"length":1,"stats":{"Line":15}},{"line":599,"address":[524623],"length":1,"stats":{"Line":12}},{"line":601,"address":[524671],"length":1,"stats":{"Line":3}},{"line":602,"address":[545255],"length":1,"stats":{"Line":12}},{"line":603,"address":[504383],"length":1,"stats":{"Line":3}},{"line":604,"address":[486439],"length":1,"stats":{"Line":12}},{"line":606,"address":[603775,603880,604030],"length":1,"stats":{"Line":18}},{"line":607,"address":[271516],"length":1,"stats":{"Line":12}},{"line":608,"address":[486728],"length":1,"stats":{"Line":2}},{"line":611,"address":[537673,537725],"length":1,"stats":{"Line":4}},{"line":612,"address":[504741],"length":1,"stats":{"Line":6}},{"line":614,"address":[548879,548842],"length":1,"stats":{"Line":10}},{"line":615,"address":[504765],"length":1,"stats":{"Line":1}},{"line":620,"address":[538046,538186,538216],"length":1,"stats":{"Line":24}},{"line":621,"address":[548928],"length":1,"stats":{"Line":6}},{"line":624,"address":[571012,571046],"length":1,"stats":{"Line":4}},{"line":625,"address":[604208],"length":1,"stats":{"Line":0}},{"line":628,"address":[504810],"length":1,"stats":{"Line":3}},{"line":629,"address":[271801,274419],"length":1,"stats":{"Line":7}},{"line":630,"address":[271704],"length":1,"stats":{"Line":6}},{"line":631,"address":[505175,507540],"length":1,"stats":{"Line":1}},{"line":632,"address":[545958],"length":1,"stats":{"Line":2}},{"line":633,"address":[505312,505633],"length":1,"stats":{"Line":2}},{"line":634,"address":[505497],"length":1,"stats":{"Line":2}},{"line":636,"address":[272426],"length":1,"stats":{"Line":2}},{"line":637,"address":[527778,526077],"length":1,"stats":{"Line":2}},{"line":639,"address":[525953],"length":1,"stats":{"Line":2}},{"line":640,"address":[548288,546902],"length":1,"stats":{"Line":1}},{"line":642,"address":[546778],"length":1,"stats":{"Line":1}},{"line":643,"address":[526575,527646],"length":1,"stats":{"Line":2}},{"line":645,"address":[488195],"length":1,"stats":{"Line":1}},{"line":646,"address":[572744,573500],"length":1,"stats":{"Line":1}},{"line":648,"address":[488444],"length":1,"stats":{"Line":1}},{"line":649,"address":[547649,548090],"length":1,"stats":{"Line":2}},{"line":651,"address":[273826,273469,273967],"length":1,"stats":{"Line":7}},{"line":653,"address":[547774],"length":1,"stats":{"Line":1}},{"line":657,"address":[487335],"length":1,"stats":{"Line":2}}],"covered":266,"coverable":318},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","src","util_ext.rs"],"content":"use crate::function_ext::Cell;\nuse crate::function_ext::CellValue;\n/// Evaluates an arithmetic operation between two `Cell` values.\n///\n/// Supports operations on combinations of integers, floats, and strings:\n/// - Integer + Integer = Integer\n/// - Integer / Integer = Integer if divisible, otherwise Float\n/// - Float + Float = Float\n/// - Mixed Int/Float = Float\n/// - String + String = String concatenation\n///\n/// Returns an invalid `Cell` if:\n/// - Any operand is invalid\n/// - Division by zero occurs\n/// - Invalid operation is attempted (e.g., subtracting strings)\n///\n/// # Parameters\n/// - `v1`: First operand as a `Cell`\n/// - `v2`: Second operand as a `Cell`\n/// - `op`: Operator character (`+`, `-`, `*`, `/`)\n///\n/// # Returns\n/// A new `Cell` with the result of the operation or marked invalid.\n///\n/// # Examples\n/// ```\n/// let c1 = Cell::new_int(6);\n/// let c2 = Cell::new_int(3);\n/// let result = arithmetic_eval(c1, c2, '/');\n/// assert_eq!(result.value, CellValue::Int(2));\n/// ```\npub fn arithmetic_eval(v1: Cell, v2: Cell, op: char) -\u003e Cell {\n    if !v1.is_valid || !v2.is_valid {\n        return Cell::invalid();\n    }\n\n    match (\u0026v1.value, \u0026v2.value) {\n        (CellValue::Int(i1), CellValue::Int(i2)) =\u003e match op {\n            '+' =\u003e Cell::new_int(i1 + i2),\n            '-' =\u003e Cell::new_int(i1 - i2),\n            '*' =\u003e Cell::new_int(i1 * i2),\n            '/' =\u003e {\n                if *i2 == 0 {\n                    Cell::invalid()\n                } else if *i1 % *i2 == 0 {\n                    Cell::new_int(i1 / i2)\n                } else {\n                    Cell::new_float((*i1 as f64) / (*i2 as f64))\n                }\n            }\n            _ =\u003e Cell::invalid(),\n        },\n        (CellValue::Float(f1), CellValue::Float(f2)) =\u003e match op {\n            '+' =\u003e Cell::new_float(f1 + f2),\n            '-' =\u003e Cell::new_float(f1 - f2),\n            '*' =\u003e Cell::new_float(f1 * f2),\n            '/' =\u003e {\n                if *f2 == 0.0 {\n                    Cell::invalid()\n                } else {\n                    Cell::new_float(f1 / f2)\n                }\n            }\n            _ =\u003e Cell::invalid(),\n        },\n        (CellValue::Int(i1), CellValue::Float(f2)) =\u003e {\n            let f1 = *i1 as f64;\n            match op {\n                '+' =\u003e Cell::new_float(f1 + f2),\n                '-' =\u003e Cell::new_float(f1 - f2),\n                '*' =\u003e Cell::new_float(f1 * f2),\n                '/' =\u003e {\n                    if *f2 == 0.0 {\n                        Cell::invalid()\n                    } else {\n                        Cell::new_float(f1 / f2)\n                    }\n                }\n                _ =\u003e Cell::invalid(),\n            }\n        }\n        (CellValue::Float(f1), CellValue::Int(i2)) =\u003e {\n            let f2 = *i2 as f64;\n            match op {\n                '+' =\u003e Cell::new_float(f1 + f2),\n                '-' =\u003e Cell::new_float(f1 - f2),\n                '*' =\u003e Cell::new_float(f1 * f2),\n                '/' =\u003e {\n                    if f2 == 0.0 {\n                        Cell::invalid()\n                    } else {\n                        Cell::new_float(f1 / f2)\n                    }\n                }\n                _ =\u003e Cell::invalid(),\n            }\n        }\n        (CellValue::String(s1), CellValue::String(s2)) =\u003e {\n            // println!(\"String operation: {} {} {}\", s1, op, s2);\n            match op {\n                '+' =\u003e Cell::new_string(format!(\"{}{}\", s1, s2)),\n                '-' =\u003e Cell::invalid(),\n                '*' =\u003e Cell::invalid(),\n                '/' =\u003e Cell::invalid(),\n                _ =\u003e Cell::invalid(),\n            }\n        }\n        _ =\u003e {\n            println!(\"Invalid operation: {:?} {} {:?}\", v1.value, op, v2.value);\n            Cell::invalid()\n        }\n    }\n}\n/// Returns the internal operation code used to represent an arithmetic operator in formulas.\n///\n/// # Mapping\n/// - `+` → `1`\n/// - `-` → `2`\n/// - `*` → `3`\n/// - `/` → `4`\n/// - Any unsupported character → `-1`\n///\n/// # Parameters\n/// - `op`: Arithmetic operator character\n///\n/// # Returns\n/// An integer representing the operation type.\n///\n/// # Example\n/// ```\n/// assert_eq!(return_optype('+'), 1);\n/// assert_eq!(return_optype('x'), -1);\n/// ```\npub fn return_optype(op: char) -\u003e i32 {\n    match op {\n        '+' =\u003e 1,\n        '-' =\u003e 2,\n        '*' =\u003e 3,\n        '/' =\u003e 4,\n        _ =\u003e -1,\n    }\n}\n","traces":[{"line":32,"address":[580064,580402,583214],"length":1,"stats":{"Line":16}},{"line":33,"address":[471522,471486],"length":1,"stats":{"Line":32}},{"line":34,"address":[617500],"length":1,"stats":{"Line":2}},{"line":37,"address":[471780,471544],"length":1,"stats":{"Line":34}},{"line":38,"address":[618000],"length":1,"stats":{"Line":11}},{"line":39,"address":[618429,618304],"length":1,"stats":{"Line":6}},{"line":40,"address":[619855,619717],"length":1,"stats":{"Line":4}},{"line":41,"address":[238913,239030],"length":1,"stats":{"Line":6}},{"line":43,"address":[624055],"length":1,"stats":{"Line":5}},{"line":44,"address":[612484,612432],"length":1,"stats":{"Line":2}},{"line":45,"address":[472599,472555],"length":1,"stats":{"Line":10}},{"line":46,"address":[472783,472700],"length":1,"stats":{"Line":6}},{"line":48,"address":[618799,618745],"length":1,"stats":{"Line":4}},{"line":51,"address":[580898,581428],"length":1,"stats":{"Line":2}},{"line":53,"address":[581909],"length":1,"stats":{"Line":5}},{"line":54,"address":[240293,240177],"length":1,"stats":{"Line":2}},{"line":55,"address":[569298,569182],"length":1,"stats":{"Line":0}},{"line":56,"address":[582412,582528],"length":1,"stats":{"Line":4}},{"line":58,"address":[473813],"length":1,"stats":{"Line":3}},{"line":59,"address":[619999,619958],"length":1,"stats":{"Line":4}},{"line":61,"address":[625578,625631],"length":1,"stats":{"Line":2}},{"line":64,"address":[621080,621380],"length":1,"stats":{"Line":2}},{"line":66,"address":[612013],"length":1,"stats":{"Line":5}},{"line":67,"address":[472160],"length":1,"stats":{"Line":5}},{"line":68,"address":[612087],"length":1,"stats":{"Line":4}},{"line":69,"address":[657456,657604],"length":1,"stats":{"Line":4}},{"line":70,"address":[239522,239388],"length":1,"stats":{"Line":0}},{"line":71,"address":[624576,624710],"length":1,"stats":{"Line":4}},{"line":73,"address":[472959],"length":1,"stats":{"Line":2}},{"line":74,"address":[657731,657772],"length":1,"stats":{"Line":4}},{"line":76,"address":[636599,636652],"length":1,"stats":{"Line":4}},{"line":79,"address":[472817,473169],"length":1,"stats":{"Line":0}},{"line":82,"address":[613078],"length":1,"stats":{"Line":6}},{"line":83,"address":[619222],"length":1,"stats":{"Line":6}},{"line":84,"address":[473242],"length":1,"stats":{"Line":6}},{"line":85,"address":[658023,658138],"length":1,"stats":{"Line":0}},{"line":86,"address":[620822,620936],"length":1,"stats":{"Line":4}},{"line":87,"address":[620853,620966],"length":1,"stats":{"Line":2}},{"line":89,"address":[239976],"length":1,"stats":{"Line":1}},{"line":90,"address":[473645,473686],"length":1,"stats":{"Line":2}},{"line":92,"address":[613574,613521],"length":1,"stats":{"Line":0}},{"line":95,"address":[636894,637195],"length":1,"stats":{"Line":4}},{"line":98,"address":[582633],"length":1,"stats":{"Line":8}},{"line":100,"address":[658649],"length":1,"stats":{"Line":5}},{"line":101,"address":[240545,240622],"length":1,"stats":{"Line":4}},{"line":102,"address":[625787,626020],"length":1,"stats":{"Line":4}},{"line":103,"address":[637665,637881],"length":1,"stats":{"Line":4}},{"line":104,"address":[582807,583006],"length":1,"stats":{"Line":2}},{"line":105,"address":[614291,613994],"length":1,"stats":{"Line":2}},{"line":109,"address":[472244,474392],"length":1,"stats":{"Line":4}},{"line":110,"address":[659163],"length":1,"stats":{"Line":4}},{"line":134,"address":[614528],"length":1,"stats":{"Line":2}},{"line":135,"address":[659238],"length":1,"stats":{"Line":2}},{"line":136,"address":[570100],"length":1,"stats":{"Line":2}},{"line":137,"address":[583310],"length":1,"stats":{"Line":2}},{"line":138,"address":[241080],"length":1,"stats":{"Line":2}},{"line":139,"address":[474706],"length":1,"stats":{"Line":2}},{"line":140,"address":[638170],"length":1,"stats":{"Line":2}}],"covered":53,"coverable":58},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","display_ext_tests.rs"],"content":"use sheet::display_ext::{printer, scroller};\nuse sheet::function_ext::{Cell, CellValue};\nuse sheet::graph_ext::{Formula, Graph, State};\n\n#[test]\nfn test_add_and_delete_edge() {\n    let mut graph = Graph::new(5);\n    graph.add_edge(2, 0);\n    graph.add_edge(3, 0);\n    let mut formulas = vec![Formula::default(); 5];\n    formulas[2] = Formula { op_type: 1, op_info1: 0, op_info2: 0 };\n    graph.delete_edge(2, 5, \u0026formulas);\n    assert_eq!(graph.adj_lists_head[0].as_ref().unwrap().cell, 3);\n}\n\n// #[test]\n// fn test_add_and_delete_range() {\n//     let mut graph = Graph::new(5);\n//     graph.add_range_to_graph(0, 1, 2);\n//     graph.add_range_to_graph(3, 4, 2);\n//     graph.delete_range_from_graph(2);\n//     assert!(graph.ranges_head.is_none());\n// }\n\n#[test]\nfn test_printer_prints_valid_int_cells() {\n    let currx = 0;\n    let curry = 0;\n    let c = 5;\n    let r = 5;\n    let mut arr = vec![Cell::new_int(0); (c * r) as usize];\n    arr[2] = Cell::new_int(42);\n    printer(currx, curry, \u0026arr, c, r);\n}\n\n#[test]\nfn test_printer_prints_float_and_string_cells() {\n    let currx = 0;\n    let curry = 0;\n    let c = 5;\n    let r = 5;\n    let mut arr = vec![Cell::new_int(0); (c * r) as usize];\n    arr[1] = Cell::new_float(3.14159);\n    arr[2] = Cell::new_string(\"test\".to_string());\n    arr[3] = Cell::new_string(\"longer-than-ten-chars\".to_string());\n    printer(currx, curry, \u0026arr, c, r);\n}\n\n#[test]\nfn test_printer_with_invalid_cells() {\n    let currx = 0;\n    let curry = 0;\n    let c = 2;\n    let r = 2;\n    let mut arr = vec![Cell::new_int(0); 4];\n    arr[0] = Cell::invalid();\n    printer(currx, curry, \u0026arr, c, r);\n}\n\n#[test]\nfn test_scroller_with_unknown_command() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 10;\n    let r = 10;\n    let arr = vec![Cell::new_int(0); (c * r) as usize];\n    let graph = Graph::new((c * r) as usize);\n    let result = scroller(\"unknown\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_scroller_scroll_to_out_of_bounds_cell() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 5;\n    let r = 5;\n    let arr = vec![Cell::new_int(0); (c * r) as usize];\n    let graph = Graph::new((c * r) as usize);\n    let result = scroller(\"scroll_to ZZ99\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_scroller_scroll_to_cell_row_col_boundary() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 26;\n    let r = 26;\n    let arr = vec![Cell::new_int(0); (c * r) as usize];\n    let graph = Graph::new((c * r) as usize);\n    let result = scroller(\"scroll_to A1\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph);\n    assert!(result.is_ok());\n    assert_eq!((currx, curry), (0, 0));\n}\n\n#[test]\nfn test_printer_empty_grid() {\n    let currx = 0;\n    let curry = 0;\n    let c = 3;\n    let r = 3;\n    let arr = vec![Cell::default(); (c * r) as usize];\n    printer(currx, curry, \u0026arr, c, r);\n}\n\n#[test]\nfn test_scroller_scroll_to_valid_cell() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 26;\n    let r = 30;\n    let arr = vec![Cell::new_int(0); (c * r) as usize];\n    let graph = Graph::new((c * r) as usize);\n    let result = scroller(\"scroll_to Z30\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph);\n    assert!(result.is_ok());\n    assert_eq!((currx, curry), (25, 29));\n}\n\n#[test]\nfn test_scroller_scroll_and_print() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 10;\n    let r = 10;\n    let mut arr = vec![Cell::default(); (c * r) as usize];\n    arr[11] = Cell::new_string(\"xyz\".into()); // B2\n    let graph = Graph::new((c * r) as usize);\n    let _ = scroller(\"scroll_to B2\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph);\n    printer(currx, curry, \u0026arr, c, r);\n}\n#[test]\nfn test_scroll_left_edge_cases() {\n    let mut currx = 0;\n    let mut curry = 0;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n\n    // Already at leftmost, flag should be triggered (no movement)\n    assert!(scroller(\"s\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(currx, 0);\n\n    // Move right first then test left scroll\n    currx = 5;\n    assert!(scroller(\"s\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(currx, 5); // 15 - 10\n}\n\n#[test]\nfn test_scroll_top_edge_cases() {\n    let mut currx = 0;\n    let mut curry = 5;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n\n    // Already at topmost, flag should be triggered (no movement)\n    assert!(scroller(\"w\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(curry, 0);\n}\n\n#[test]\nfn test_scroll_negative_curry() {\n    let mut currx = 0;\n    let mut curry = -1;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n    assert!(scroller(\"w\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(curry, -1); // unchanged\n}\n\n#[test]\nfn test_scroll_normal_upscroll() {\n    let mut currx = 0;\n    let mut curry = 15;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n    assert!(scroller(\"w\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(curry, 5);\n}\n\n#[test]\nfn test_scroll_right_scroll_flag_set() {\n    let mut currx = 15;\n    let mut curry = 0;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n    assert!(scroller(\"s\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(currx, 15); // remains unchanged\n}\n\n#[test]\nfn test_scroll_negative_currx() {\n    let mut currx = -1;\n    let mut curry = 0;\n    let c = 20;\n    let r = 20;\n    let arr = vec![Cell::default(); c * r];\n    let graph = Graph::new(c * r);\n    assert!(scroller(\"a\", \u0026arr, \u0026mut currx, \u0026mut curry, c as i32, r as i32, \u0026graph).is_ok());\n    assert_eq!(currx, -1); // wrapped around to 0\n}\n\n// #[test]\n// fn test_scroll_right_with_column_limit() {\n//     let mut currx = 0;\n//     let mut curry = 0;\n//     let c = 18;\n//     let r = 20;\n//     let arr = vec![Cell::default(); c * r];\n//     let graph = Graph::new(c * r);\n\n//     assert!(scroller(\"scroll_right\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph).is_ok());\n//     assert_eq!(currx, 10); // Normal jump\n\n//     // Now currx = 10, remaining = 8\n//     assert!(scroller(\"scroll_right\", \u0026arr, \u0026mut currx, \u0026mut curry, c, r, \u0026graph).is_ok());\n//     assert_eq!(currx, 18); // Should cap at 18\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","display_tests.rs"],"content":"use sheet::display::{printer, scroller};\nuse sheet::graph::Graph;\nuse std::i32;\n\nfn generate_grid_with_pattern(c: usize, r: usize, err_at: Option\u003cusize\u003e) -\u003e Vec\u003ci32\u003e {\n    let mut grid = vec![0; c * r];\n    if let Some(idx) = err_at {\n        grid[idx] = i32::MIN;\n    }\n    for i in 0..(c * r) {\n        if Some(i) != err_at {\n            grid[i] = i as i32;\n        }\n    }\n    grid\n}\n\n#[test]\nfn test_printer_draws_headers_and_rows() {\n    let c = 12;\n    let r = 12;\n    let grid = generate_grid_with_pattern(c, r, None);\n    // This won't validate stdout, but ensures full execution path\n    printer(0, 0, \u0026grid, c, r); // draws A-L and 1–10\n    printer(2, 3, \u0026grid, c, r); // draws C–L and 4–13 (max 10 visible)\n}\n\n#[test]\nfn test_printer_shows_err_cell() {\n    let c = 10;\n    let r = 10;\n    let idx = 5 + 3 * c; // cell at col=5, row=3\n    let grid = generate_grid_with_pattern(c, r, Some(idx));\n    printer(0, 0, \u0026grid, c, r); // triggers ERR printing path\n}\n\n#[test]\nfn test_scroller_top_left_no_move() {\n    let mut x = 0;\n    let mut y = 0;\n    let c = 10;\n    let r = 10;\n    let mut arr = vec![0; c * r];\n    let mut graph = Graph::new(c * r);\n\n    assert_eq!(scroller(\"w\", \u0026mut arr, \u0026mut x, \u0026mut y, c, r, \u0026mut graph), 0);\n    assert_eq!(scroller(\"a\", \u0026mut arr, \u0026mut x, \u0026mut y, c, r, \u0026mut graph), 0);\n}\n\n#[test]\nfn test_scroller_down_and_right_partial_and_full_jump() {\n    let mut x = 0;\n    let mut y = 0;\n    let c = 15;\n    let r = 13;\n    let mut arr = vec![0; c * r];\n    let mut graph = Graph::new(c * r);\n\n    assert_eq!(scroller(\"s\", \u0026mut arr, \u0026mut x, \u0026mut y, c, r, \u0026mut graph), 0);\n    assert!(y \u003e 0);\n    assert_eq!(scroller(\"d\", \u0026mut arr, \u0026mut x, \u0026mut y, c, r, \u0026mut graph), 0);\n    assert!(x \u003e 0);\n}\n\n#[test]\nfn test_scroller_invalid_command() {\n    let mut x = 0;\n    let mut y = 0;\n    let c = 10;\n    let r = 10;\n    let mut arr = vec![0; c * r];\n    let mut graph = Graph::new(c * r);\n\n    assert_eq!(scroller(\"invalid_command\", \u0026mut arr, \u0026mut x, \u0026mut y, c, r, \u0026mut graph), -1);\n}\n","traces":[{"line":5,"address":[156896,157460],"length":1,"stats":{"Line":1}},{"line":6,"address":[157002,156952],"length":1,"stats":{"Line":1}},{"line":7,"address":[157018,156992,157138],"length":1,"stats":{"Line":3}},{"line":8,"address":[157132,157031],"length":1,"stats":{"Line":2}},{"line":10,"address":[157335,157145,157068],"length":1,"stats":{"Line":3}},{"line":11,"address":[157455,157356],"length":1,"stats":{"Line":2}},{"line":12,"address":[157418],"length":1,"stats":{"Line":1}},{"line":15,"address":[157292],"length":1,"stats":{"Line":1}}],"covered":8,"coverable":8},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","function_ext_tests.rs"],"content":"use sheet::function_ext::{Cell, CellValue};\n\n#[test]\nfn test_new_int_cell() {\n    let cell = Cell::new_int(100);\n    assert_eq!(cell.value, CellValue::Int(100));\n    assert!(cell.is_valid);\n}\n\n#[test]\nfn test_new_float_cell() {\n    let cell = Cell::new_float(12.34);\n    assert_eq!(cell.value, CellValue::Float(12.34));\n    assert!(cell.is_valid);\n}\n\n#[test]\nfn test_new_string_cell() {\n    let cell = Cell::new_string(\"hello\".to_string());\n    assert_eq!(cell.value, CellValue::String(\"hello\".to_string()));\n    assert!(cell.is_valid);\n}\n\n#[test]\nfn test_invalid_cell() {\n    let cell = Cell::invalid();\n    assert_eq!(cell.value, CellValue::Int(0));\n    assert!(!cell.is_valid);\n}\n\n#[test]\nfn test_default_cell() {\n    let default: Cell = Default::default();\n    assert_eq!(default, Cell::invalid());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","function_tests.rs"],"content":"use sheet::function::*;\nuse sheet::graph::{Formula, Graph};\n\nfn setup_grid() -\u003e (Vec\u003ci32\u003e, Graph, Vec\u003cFormula\u003e) {\n    let mut arr = vec![0; 25]; // 5x5 grid\n                               // Fill B2 and B3 with values: B2(6), B3(8)\n    arr[1 + 1 * 5] = 6; // B2\n    arr[1 + 2 * 5] = 8; // B3\n    let graph = Graph::new(25);\n    let formula_array = vec![Formula::default(); 25];\n    (arr, graph, formula_array)\n}\n\n#[test]\nfn test_min_func() {\n    let (mut arr, mut graph, mut formulas) = setup_grid();\n    let result = min_func(\"A1=min(B2:B3)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], 6);\n}\n\n#[test]\nfn test_max_func() {\n    let (mut arr, mut graph, mut formulas) = setup_grid();\n    let result = max_func(\"A1=max(B2:B3)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], 8);\n}\n\n#[test]\nfn test_sum_func() {\n    let (mut arr, mut graph, mut formulas) = setup_grid();\n    let result = sum_func(\"A1=sum(B2:B3)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], 6 + 8);\n}\n\n#[test]\nfn test_avg_func() {\n    let (mut arr, mut graph, mut formulas) = setup_grid();\n    let result = avg_func(\"A1=avg(B2:B3)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], (6 + 8) / 2);\n}\n\n#[test]\nfn test_stdev_func() {\n    let (mut arr, mut graph, mut formulas) = setup_grid();\n    let result = stdev_func(\"A1=stdev(B2:B3)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    // stddev of [6, 8] = sqrt(1) = 1\n    assert_eq!(arr[0], 1);\n}\n\n#[test]\nfn test_sleep_func_with_value() {\n    let mut arr = vec![0; 25];\n    let mut graph = Graph::new(25);\n    let mut formulas = vec![Formula::default(); 25];\n    let result = sleep_func(\"A1=sleep(5)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], 5);\n}\n\n#[test]\nfn test_sleep_func_with_reference() {\n    let mut arr = vec![0; 25];\n    arr[1 + 1 * 5] = 4; // B2 = 4\n    let mut graph = Graph::new(25);\n    let mut formulas = vec![Formula::default(); 25];\n    let result = sleep_func(\"A1=sleep(B2)\", 5, 5, 3, 0, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(result, 1);\n    assert_eq!(arr[0], 4);\n}\n","traces":[{"line":4,"address":[160311,159696],"length":1,"stats":{"Line":2}},{"line":5,"address":[159713],"length":1,"stats":{"Line":2}},{"line":7,"address":[159737,159847],"length":1,"stats":{"Line":4}},{"line":8,"address":[159900],"length":1,"stats":{"Line":2}},{"line":9,"address":[160021],"length":1,"stats":{"Line":2}},{"line":10,"address":[160098,160050],"length":1,"stats":{"Line":4}},{"line":11,"address":[160133],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":7},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","graph_ext_tests.rs"],"content":"// use sheet::graph_ext::{Graph, Formula, State};\n// use sheet::function_ext::{Cell, CellValue};\n\n// fn setup_graph_env(size: usize) -\u003e (Graph, Vec\u003cCell\u003e, Vec\u003cFormula\u003e, State) {\n//     let graph = Graph::new(size);\n//     let arr = vec![Cell::default(); size];\n//     let formulas = vec![Formula::default(); size];\n//     let state = State::new();\n//     (graph, arr, formulas, state)\n// }\n\n// #[test]\n// fn test_add_and_delete_edge() {\n//     let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n//     graph.add_edge(3, 5);\n//     assert!(graph.adj_lists_head[5].is_some());\n\n//     formulas[3] = Formula { op_type: 1, op_info1: 5, op_info2: 0 };\n//     graph.delete_edge(3, 10, \u0026formulas);\n//     assert!(graph.adj_lists_head[5].is_none());\n// }\n\n// #[test]\n// fn test_add_and_delete_range() {\n//     let (mut graph, _, _, _) = setup_graph_env(10);\n//     graph.add_range_to_graph(1, 3, 5);\n//     assert!(graph.ranges_head.is_some());\n\n//     graph.delete_range_from_graph(5);\n//     assert!(graph.ranges_head.is_none());\n// }\n\n// #[test]\n// fn test_topo_sort_and_recalc_arithmetic() {\n//     let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(10);\n//     arr[1] = Cell::new_int(10);\n//     formulas[0] = Formula { op_type: 1, op_info1: 1, op_info2: 5 }; // =B1 + 5\n//     graph.add_edge(0, 1);\n\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_int(15));\n// }\n\n// #[test]\n// fn test_topo_sort_cycle_detection() {\n//     let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n//     formulas[0] = Formula { op_type: 1, op_info1: 1, op_info2: 0 };\n//     formulas[1] = Formula { op_type: 1, op_info1: 0, op_info2: 0 };\n//     graph.add_edge(0, 1);\n//     graph.add_edge(1, 0);\n\n//     let result = graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state);\n//     assert!(result.is_err());\n//     assert!(state.has_cycle);\n// }\n\n// #[test]\n// fn test_recalc_sum() {\n//     let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(25);\n//     arr[6] = Cell::new_int(10);\n//     arr[11] = Cell::new_int(14);\n//     graph.add_range_to_graph(6, 11, 0);\n//     formulas[0] = Formula { op_type: 12, op_info1: 6, op_info2: 11 }; // SUM\n\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_int(75)); // 10+11+12+13+14\n// }\nuse sheet::function_ext::{Cell, CellValue};\nuse sheet::graph_ext::{Formula, Graph, State};\n\nuse sheet::parser_ext::autofill;\n\nfn setup_graph_env(size: usize) -\u003e (Graph, Vec\u003cCell\u003e, Vec\u003cFormula\u003e, State) {\n    let graph = Graph::new(size);\n    let arr = vec![Cell::default(); size];\n    let formulas = vec![Formula::default(); size];\n    let state = State::new();\n    (graph, arr, formulas, state)\n}\n\n#[test]\nfn test_add_and_delete_edge() {\n    let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n    graph.add_edge(3, 5);\n    assert!(graph.adj_lists_head[5].is_some());\n\n    formulas[3] = Formula { op_type: 1, op_info1: 5, op_info2: 0 };\n    graph.delete_edge(3, 10, \u0026formulas);\n    assert!(graph.adj_lists_head[5].is_none());\n}\n\n#[test]\nfn test_add_and_delete_range() {\n    let (mut graph, _, _, _) = setup_graph_env(10);\n    graph.add_range_to_graph(1, 3, 5);\n    assert!(graph.ranges_head.is_some());\n\n    graph.delete_range_from_graph(5);\n    assert!(graph.ranges_head.is_none());\n}\n#[test]\n// fn test_recalc_sum() {\n//     let cell_count = 25;\n//     let mut graph = Graph::new(cell_count);\n//     let mut arr = vec![Cell::default(); cell_count];\n//     let mut formula_array = vec![Formula::default(); cell_count];\n//     let mut state = State::new();\n//     state.num_cells = cell_count;\n\n//     arr[6] = Cell::new_int(10);\n//     arr[11] = Cell::new_int(14);\n//     graph.add_formula(0, 6, 11, 12, \u0026mut formula_array); // SUM\n//     graph.add_range_to_graph(6, 11, 0);\n\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_int(10 + 11 + 12 + 13 + 14));\n// }\n#[test]\nfn test_topo_sort_and_recalc_arithmetic() {\n    let cell_count = 10;\n    let mut graph = Graph::new(cell_count);\n    let mut arr = vec![Cell::default(); cell_count];\n    let mut formula_array = vec![Formula::default(); cell_count];\n    let mut state = State::new();\n    state.num_cells = cell_count;\n\n    arr[1] = Cell::new_int(5);\n    graph.add_edge(0, 1);\n    graph.add_formula(0, 1, 2, 1, \u0026mut formula_array); // 5 + 2\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state).unwrap();\n    assert_eq!(arr[0], Cell::new_int(7));\n}\n\n#[test]\nfn test_topo_sort_cycle_detection() {\n    let cell_count = 5;\n    let mut graph = Graph::new(cell_count);\n    let mut arr = vec![Cell::default(); cell_count];\n    let mut formula_array = vec![Formula::default(); cell_count];\n    let mut state = State::new();\n    state.num_cells = cell_count;\n\n    graph.add_edge(0, 1);\n    graph.add_edge(1, 0); // cycle\n\n    graph.add_formula(0, 1, 2, 5, \u0026mut formula_array);\n    graph.add_formula(1, 0, 3, 5, \u0026mut formula_array);\n\n    let result = graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state);\n    assert!(result.is_err());\n    assert!(state.has_cycle);\n}\n// #[test]\n// fn test_recalc_with_cell_plus_const() {\n//     let mut graph = Graph::new(10);\n//     let mut arr = vec![0; 10];\n//     let mut formula_array = vec![Formula::default(); 10];\n//     let mut has_cycle = false;\n\n//     arr[1] = 7;\n//     graph.add_formula(\u0026mut graph, 0, 1, 3, 1, \u0026mut formula_array); // A1 = B1 + 3\n//     graph.add_edge(1, 0);\n\n//     graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut has_cycle);\n//     assert_eq!(arr[0], 10);\n// }\n#[test]\nfn test_const_plus_invalid_cell() {\n    let mut graph = Graph::new(5);\n    let mut arr = vec![Cell::default(); 5];\n    let mut formula_array = vec![Formula::default(); 5];\n    let mut state = State::new();\n    state.num_cells = 5;\n\n    arr[1] = Cell::invalid(); // invalid cell\n    graph.add_formula(0, 1, 5, 1, \u0026mut formula_array); // =B1 + 5\n    graph.add_edge(0, 1);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n    assert_eq!(arr[0], Cell::invalid());\n}\n#[test]\nfn test_add_edge_duplicate_and_append() {\n    let (mut graph, _, _, _) = setup_graph_env(10);\n    graph.add_edge(3, 5); // Add edge 3 -\u003e 5\n    assert!(graph.adj_lists_head[5].is_some());\n    assert_eq!(graph.adj_lists_head[5].as_ref().unwrap().cell, 3); // Line 97-98\n\n    graph.add_edge(3, 5); // Duplicate edge, should not add (line 114)\n    assert!(graph.adj_lists_head[5].as_ref().unwrap().next.is_none());\n\n    graph.add_edge(4, 5); // Append new edge 4 -\u003e 5 (line 107)\n    assert!(graph.adj_lists_head[5].as_ref().unwrap().next.is_some());\n    assert_eq!(graph.adj_lists_head[5].as_ref().unwrap().next.as_ref().unwrap().cell, 4);\n}\n\n#[test]\nfn test_delete_node_non_head() {\n    let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n    graph.add_edge(3, 5);\n    graph.add_edge(4, 5);\n    assert!(graph.adj_lists_head[5].is_some());\n    assert!(graph.adj_lists_head[5].as_ref().unwrap().next.is_some());\n\n    formulas[3] = Formula { op_type: 1, op_info1: 5, op_info2: 0 };\n    graph.delete_node(4, 5); // Delete non-head node (lines 195-198)\n    assert_eq!(graph.adj_lists_head[5].as_ref().unwrap().cell, 3);\n    assert!(graph.adj_lists_head[5].as_ref().unwrap().next.is_none());\n\n    graph.delete_node(5, 5); // Empty list after deletion (line 179)\n    assert!(graph.adj_lists_head[5].is_some());\n}\n\n#[test]\nfn test_delete_head_node() {\n    let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n    graph.add_edge(3, 5);\n    formulas[3] = Formula { op_type: 1, op_info1: 5, op_info2: 0 };\n    graph.delete_node(3, 5); // Delete head node (lines 189, 191-193)\n    assert!(graph.adj_lists_head[5].is_none());\n}\n#[test]\nfn test_add_multiple_ranges() {\n    let (mut graph, _, _, _) = setup_graph_env(10);\n    graph.add_range_to_graph(1, 3, 5); // Lines 120-124, 126-127, 129\n    graph.add_range_to_graph(2, 4, 6);\n    assert!(graph.ranges_head.is_some());\n    assert_eq!(graph.ranges_head.as_ref().unwrap().dependent_cell, 6);\n    assert_eq!(graph.ranges_head.as_ref().unwrap().next.as_ref().unwrap().dependent_cell, 5);\n}\n\n#[test]\nfn test_delete_non_head_range() {\n    let (mut graph, _, _, _) = setup_graph_env(10);\n    graph.add_range_to_graph(1, 3, 5);\n    graph.add_range_to_graph(2, 4, 6);\n    graph.delete_range_from_graph(5); // Delete non-head range (lines 202-209, 211-214)\n    assert!(graph.ranges_head.is_some());\n    assert_eq!(graph.ranges_head.as_ref().unwrap().dependent_cell, 6);\n    assert!(graph.ranges_head.as_ref().unwrap().next.is_none());\n\n    graph.delete_range_from_graph(7); // Skip non-matching range (lines 217-218)\n    assert!(graph.ranges_head.is_some());\n}\n#[test]\nfn test_delete_edge_op_types() {\n    let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n    // op_type = -1 (cell reference)\n    formulas[0] = Formula { op_type: -1, op_info1: 1, op_info2: 0 };\n    graph.add_edge(0, 1);\n    graph.delete_edge(0, 5, \u0026formulas); // Lines 221-222\n    assert!(graph.adj_lists_head[1].is_none());\n\n    // op_type = 1 (add cell + constant)\n    formulas[0] = Formula { op_type: 1, op_info1: 2, op_info2: 0 };\n    graph.add_edge(0, 2);\n    graph.delete_edge(0, 5, \u0026formulas); // Line 228\n    assert!(graph.adj_lists_head[2].is_none());\n\n    // op_type = 5 (add two cells)\n    formulas[0] = Formula { op_type: 5, op_info1: 3, op_info2: 4 };\n    graph.add_edge(0, 3);\n    graph.add_edge(0, 4);\n    graph.delete_edge(0, 5, \u0026formulas); // Line 234\n    assert!(graph.adj_lists_head[3].is_none());\n    assert!(graph.adj_lists_head[4].is_none());\n\n    // op_type = 9 (MIN range)\n    formulas[0] = Formula { op_type: 9, op_info1: 1, op_info2: 3 };\n    graph.add_range_to_graph(1, 3, 0);\n    graph.delete_edge(0, 5, \u0026formulas); // Lines 248-254\n    assert!(graph.ranges_head.is_none());\n\n    // op_type = 14 (SLEEP)\n    formulas[0] = Formula { op_type: 14, op_info1: 5, op_info2: 0 };\n    graph.add_edge(0, 5);\n    graph.delete_edge(0, 5, \u0026formulas); // Lines 257-258\n    assert!(graph.adj_lists_head[5].is_none());\n\n    // op_type = 15 (division constant / cell)\n    formulas[0] = Formula { op_type: 15, op_info1: 0, op_info2: 6 };\n    graph.add_edge(0, 6);\n    graph.delete_edge(0, 5, \u0026formulas); // Lines 266-267\n    assert!(graph.adj_lists_head[6].is_none());\n}\n\n#[test]\nfn test_add_edge_formula_op_types() {\n    let (mut graph, _, mut formulas, _) = setup_graph_env(10);\n    // op_type = -1\n    formulas[0] = Formula { op_type: -1, op_info1: 1, op_info2: 0 };\n    graph.add_edge_formula(0, 5, \u0026formulas); // Lines 260-264\n    assert!(graph.adj_lists_head[1].is_some());\n\n    // op_type = 5\n    formulas[0] = Formula { op_type: 5, op_info1: 2, op_info2: 3 };\n    graph.add_edge_formula(0, 5, \u0026formulas); // Lines 260-264\n    assert!(graph.adj_lists_head[2].is_some());\n    assert!(graph.adj_lists_head[3].is_some());\n\n    // op_type = 9\n    formulas[0] = Formula { op_type: 9, op_info1: 4, op_info2: 6 };\n    graph.add_edge_formula(0, 5, \u0026formulas); // Lines 260-264\n    assert!(graph.ranges_head.is_some());\n\n    // op_type = 14 (SLEEP with non-self reference)\n    formulas[0] = Formula { op_type: 14, op_info1: 7, op_info2: 0 };\n    graph.add_edge_formula(0, 5, \u0026formulas); // Lines 260-264\n    assert!(graph.adj_lists_head[7].is_some());\n\n    // op_type = 15\n    formulas[0] = Formula { op_type: 15, op_info1: 0, op_info2: 8 };\n    graph.add_edge_formula(0, 5, \u0026formulas); // Lines 260-264\n    assert!(graph.adj_lists_head[8].is_some());\n}\n#[test]\nfn test_recalc_cell_reference_invalid() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[1] = Cell::invalid();\n    formulas[0] = Formula { op_type: -1, op_info1: 1, op_info2: 0 };\n    graph.add_edge(0, 1);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 358-363\n    assert_eq!(arr[0], Cell::invalid());\n}\n\n#[test]\nfn test_recalc_arithmetic_cell_constant() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[1] = Cell::new_int(10);\n    formulas[0] = Formula { op_type: 3, op_info1: 1, op_info2: 2 }; // B1 * 2\n    graph.add_edge(0, 1);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 381-386\n    assert_eq!(arr[0], Cell::new_int(20));\n\n    arr[1] = Cell::invalid();\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 381-386\n    assert_eq!(arr[0], Cell::invalid());\n}\n\n#[test]\nfn test_recalc_arithmetic_two_cells() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[1] = Cell::new_int(10);\n    arr[2] = Cell::new_int(5);\n    formulas[0] = Formula { op_type: 7, op_info1: 1, op_info2: 2 }; // B1 * C1\n    graph.add_edge(0, 1);\n    graph.add_edge(0, 2);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Line 402\n    assert_eq!(arr[0], Cell::new_int(50));\n}\n\n#[test]\nfn test_recalc_range_invalid() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(25);\n    state.num_cells = 25;\n    arr[6] = Cell::invalid(); // B2\n    formulas[0] = Formula { op_type: 12, op_info1: 6, op_info2: 11 }; // SUM(B2:C3)\n    graph.add_range_to_graph(6, 11, 0);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Line 414\n    assert_eq!(arr[0], Cell::invalid());\n}\n\n#[test]\nfn test_recalc_sleep() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[1] = Cell::new_int(1); // Sleep for 1 second\n    formulas[0] = Formula { op_type: 14, op_info1: 1, op_info2: 0 };\n    graph.add_edge(0, 1);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Line 420\n    assert_eq!(arr[0], Cell::new_int(1));\n}\n\n#[test]\nfn test_recalc_division_constant_cell() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[1] = Cell::new_int(10);\n    formulas[0] = Formula { op_type: 15, op_info1: 20, op_info2: 1 }; // 20 / B1\n    graph.add_edge(0, 1);\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 424-425, 428-429\n    assert_eq!(arr[0], Cell::new_int(2));\n}\n\n#[test]\nfn test_recalc_string() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[0] = Cell::new_string(\"test\".to_string());\n    formulas[0] = Formula { op_type: 16, op_info1: 0, op_info2: 0 };\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 435-437\n    assert_eq!(arr[0], Cell::new_string(\"test\".to_string()));\n}\n\n#[test]\nfn test_recalc_float() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    arr[0] = Cell::new_float(3.14);\n    formulas[0] = Formula { op_type: 17, op_info1: 0, op_info2: 0 };\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Lines 439-440\n    assert_eq!(arr[0], Cell::new_float(3.14));\n}\n\n#[test]\nfn test_recalc_invalid_op_type() {\n    let (mut graph, mut arr, mut formulas, mut state) = setup_graph_env(5);\n    state.num_cells = 5;\n    formulas[0] = Formula { op_type: 999, op_info1: 0, op_info2: 0 }; // Invalid op_type\n\n    graph.recalc(5, \u0026mut arr, 0, \u0026formulas, \u0026mut state).unwrap(); // Line 442\n    assert_eq!(arr[0], Cell::invalid());\n}\n\n// #[test]\n// fn test_add_and_delete_range() {\n//     let mut graph = Graph::new(5);\n//     graph.add_range_to_graph(0, 1, 2);\n//     graph.add_range_to_graph(3, 4, 2);\n//     graph.delete_range_from_graph(2);\n//     assert!(graph.ranges_head.is_none());\n// }\n\n// #[test]\n// fn test_recalc_sum() {\n//     let cell_count = 25;\n//     let mut graph = Graph::new(cell_count);\n//     let mut arr = vec![Cell::default(); cell_count];\n//     let mut formula_array = vec![Formula::default(); cell_count];\n//     let mut state = State::new();\n//     state.num_cells = cell_count;\n\n//     for i in 6..=11 {\n//         arr[i] = Cell::new_int((i as i32) + 4);\n//     }\n//     graph.add_formula(0, 6, 11, 12, \u0026mut formula_array);\n//     graph.add_range_to_graph(6, 11, 0);\n\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_int(10 + 11 + 12 + 13 + 14 + 15));\n// }\n\n// #[test]\n// fn test_topo_sort_cycle_detection() {\n//     let cell_count = 5;\n//     let mut graph = Graph::new(cell_count);\n//     let mut arr = vec![Cell::default(); cell_count];\n//     let mut formula_array = vec![Formula::default(); cell_count];\n//     let mut state = State::new();\n//     state.num_cells = cell_count;\n\n//     graph.add_edge(0, 1);\n//     graph.add_edge(1, 0);\n\n//     graph.add_formula(0, 1, 2, 5, \u0026mut formula_array);\n//     graph.add_formula(1, 0, 3, 5, \u0026mut formula_array);\n\n//     let result = graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state);\n//     assert!(result.is_err());\n//     assert!(state.has_cycle);\n// }\n\n// #[test]\n// fn test_string_assignment_and_recalc() {\n//     let mut graph = Graph::new(10);\n//     let mut arr = vec![Cell::default(); 10];\n//     let mut formula_array = vec![Formula::default(); 10];\n//     let mut state = State::new();\n//     state.num_cells = 10;\n\n//     arr[1] = Cell::new_string(\"hello\".to_string());\n//     graph.add_formula(0, 1, 0, -1, \u0026mut formula_array);\n//     graph.add_edge(0, 1);\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_string(\"hello\".to_string()));\n// }\n\n// #[test]\n// fn test_float_assignment_and_recalc() {\n//     let mut graph = Graph::new(10);\n//     let mut arr = vec![Cell::default(); 10];\n//     let mut formula_array = vec![Formula::default(); 10];\n//     let mut state = State::new();\n//     state.num_cells = 10;\n\n//     arr[1] = Cell::new_float(3.14);\n//     graph.add_formula(0, 1, 0, -1, \u0026mut formula_array);\n//     graph.add_edge(0, 1);\n//     graph.recalc(5, \u0026mut arr, 0, \u0026formula_array, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::new_float(3.14));\n// }\n\n// // #[test]\n// // fn test_const_division_by_zero() {\n// //     let mut graph = Graph::new(5);\n// //     let mut arr = vec![Cell::default(); 5];\n// //     let mut formula_array = vec![Formula::default(); 5];\n// //     let mut state = State::new();\n// //     state.num_cells = 5;\n\n// //     graph.add_formula(0, 10, 0, 4, \u0026mut formula_array);\n// //     graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n// //     assert_eq!(arr[0], Cell::invalid());\n// // }\n\n// // #[test]\n// // fn test_sleep_self_value() {\n// //     let mut graph = Graph::new(5);\n// //     let mut arr = vec![Cell::default(); 5];\n// //     let mut formula_array = vec![Formula::default(); 5];\n// //     let mut state = State::new();\n// //     state.num_cells = 5;\n\n// //     arr[0] = Cell::new_int(1);\n// //     graph.add_formula(0, 0, 0, 14, \u0026mut formula_array);\n// //     graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n// //     assert_eq!(arr[0], Cell::new_int(1));\n// // }\n\n// #[test]\n// fn test_invalid_formula_type() {\n//     let mut graph = Graph::new(5);\n//     let mut arr = vec![Cell::default(); 5];\n//     let mut formula_array = vec![Formula::default(); 5];\n//     let mut state = State::new();\n//     state.num_cells = 5;\n\n//     formula_array[0].op_type = 99;\n//     graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n//     assert_eq!(arr[0], Cell::invalid());\n// }\n\n#[test]\nfn test_minimum_value_in_range() {\n    let mut graph = Graph::new(16);\n    let mut arr = vec![Cell::default(); 16];\n    let mut formula_array = vec![Formula::default(); 16];\n    let mut state = State::new();\n    state.num_cells = 16;\n\n    arr[5] = Cell::new_int(4);\n    arr[6] = Cell::new_int(9);\n    arr[7] = Cell::new_int(-2);\n    graph.add_formula(0, 5, 7, 9, \u0026mut formula_array);\n    graph.add_range_to_graph(5, 7, 0);\n\n    graph.recalc(4, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n    assert_eq!(arr[0], Cell::new_int(-2));\n}\n\n#[test]\nfn test_division_by_zero_cell_cell() {\n    let mut graph = Graph::new(5);\n    let mut arr = vec![Cell::default(); 5];\n    let mut formula_array = vec![Formula::default(); 5];\n    let mut state = State::new();\n    state.num_cells = 5;\n\n    arr[1] = Cell::new_int(100);\n    arr[2] = Cell::new_int(0);\n    graph.add_formula(0, 1, 2, 8, \u0026mut formula_array);\n    graph.add_edge(0, 1);\n    graph.add_edge(0, 2);\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formula_array, \u0026mut state).unwrap();\n    assert_eq!(arr[0], Cell::invalid());\n}\n","traces":[{"line":73,"address":[161392,161953],"length":1,"stats":{"Line":9}},{"line":74,"address":[161421],"length":1,"stats":{"Line":4}},{"line":75,"address":[161435,161496],"length":1,"stats":{"Line":18}},{"line":76,"address":[161577,161528],"length":1,"stats":{"Line":13}},{"line":77,"address":[161604],"length":1,"stats":{"Line":4}},{"line":78,"address":[161666],"length":1,"stats":{"Line":9}}],"covered":6,"coverable":6},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","graph_recalc_tests.rs"],"content":"use sheet::graph::{Formula, Graph};\nuse std::i32;\n\nfn setup(cells: usize) -\u003e (Graph, Vec\u003ci32\u003e, Vec\u003cFormula\u003e, bool) {\n    (Graph::new(cells), vec![0; cells], vec![Formula::default(); cells], false)\n}\n#[test]\nfn test_add_duplicate_edge() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    graph.add_edge(0, 1); // Add edge 0-\u003e1\n    graph.add_edge(0, 1); // Duplicate edge (lines 75-78)\n    assert!(graph.has_edge(0, 1)); // Lines 85-86, 90\n    let mut current = \u0026graph.adj_lists[0];\n    let mut count = 0;\n    while let Some(cell) = current {\n        count += 1;\n        current = \u0026cell.next;\n    }\n    assert_eq!(count, 1); // Only one edge\n}\n\n#[test]\nfn test_add_and_delete_multiple_edges() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    graph.add_edge(0, 1); // Lines 40-41, 80-83\n    graph.add_edge(0, 2);\n    assert!(graph.has_edge(0, 1)); // Lines 85-86, 90\n    assert!(graph.has_edge(0, 2));\n    graph.delete_edge(0, 1); // Lines 96, 108\n    assert!(!graph.has_edge(0, 1));\n    assert!(graph.has_edge(0, 2));\n}\n#[test]\nfn test_add_and_delete_multiple_ranges() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    graph.add_range_to_graph(0, 1, 2); // Lines 67, 70, 125, 128\n    graph.add_range_to_graph(3, 4, 2);\n    let mut count = 0;\n    let mut current = \u0026graph.ranges;\n    while let Some(_) = current {\n        count += 1;\n        current = \u0026current.as_ref().unwrap().next;\n    }\n    assert_eq!(count, 2);\n    graph.delete_range(2); // Lines 143, 151-156, 158\n    assert!(graph.ranges.is_none());\n}\n#[test]\nfn test_arithmetic_eval_invalid_operator() {\n    let result = Graph::arithmetic_eval2(5, 2, '^'); // Lines 163-168\n    assert_eq!(result, i32::MIN);\n}\n\n#[test]\nfn test_add_formula_constant() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    Graph::add_formula(\u0026mut graph, 0, 42, 0, 0, \u0026mut formulas); // Line 172\n    assert_eq!(formulas[0].op_type, 0);\n    assert_eq!(formulas[0].op_info1, 42);\n}\n#[test]\nfn test_topo_sort_with_cycle_and_ranges() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(25);\n    graph.add_edge(0, 1);\n    graph.add_edge(1, 0); // Cycle\n    graph.add_range_to_graph(5, 10, 0); // Lines 215, 219-222, 224\n    let mut visited = vec![false; 25];\n    let mut on_stack = vec![false; 25];\n    let mut stack = Vec::new();\n    graph.topo_sort_from_cell(\n        0,\n        5,\n        \u0026mut visited,\n        \u0026mut on_stack,\n        \u0026mut stack,\n        \u0026formulas,\n        \u0026mut has_cycle,\n    ); // Lines 205-206\n    assert!(has_cycle);\n}\n#[test]\nfn test_recalc_constant_assignment() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    Graph::add_formula(\u0026mut graph, 0, 42, 0, 0, \u0026mut formulas); // Lines 235-236\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 42);\n}\n\n// #[test]\n// fn test_recalc_constant_division_by_zero() {\n//     let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n//     Graph::add_formula(\u0026mut graph, 0, 10, 0, 4, \u0026mut formulas); // Lines 238-239, 241\n//     graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n//     assert_eq!(arr[0], i32::MIN);\n// }\n\n#[test]\nfn test_recalc_cell_cell_subtraction() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    arr[1] = 10;\n    arr[2] = 3;\n    Graph::add_formula(\u0026mut graph, 0, 1, 2, 6, \u0026mut formulas); // Lines 255-256\n    graph.add_edge(0, 1);\n    graph.add_edge(0, 2);\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 7);\n}\n\n#[test]\nfn test_recalc_cell_cell_division_by_zero() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    arr[1] = 100;\n    arr[2] = 0;\n    Graph::add_formula(\u0026mut graph, 0, 1, 2, 8, \u0026mut formulas); // Lines 255-256, 260-261\n    graph.add_edge(0, 1);\n    graph.add_edge(0, 2);\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], i32::MIN);\n}\n\n#[test]\nfn test_recalc_max_range() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(16);\n    arr[5] = 4;\n    arr[6] = 9;\n    arr[7] = -2;\n    Graph::add_formula(\u0026mut graph, 0, 5, 7, 10, \u0026mut formulas); // Lines 266-271, 291\n    graph.add_range_to_graph(5, 7, 0);\n    graph.recalc(4, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 9); // MAX\n}\n\n#[test]\nfn test_recalc_avg_range() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(16);\n    arr[5] = 4;\n    arr[6] = 9;\n    arr[7] = 6;\n    Graph::add_formula(\u0026mut graph, 0, 5, 7, 11, \u0026mut formulas); // Lines 266-271, 296\n    graph.add_range_to_graph(5, 7, 0);\n    graph.recalc(4, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 6); // AVG = (4+9+6)/3\n}\n\n#[test]\nfn test_recalc_stdev_range() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(16);\n    arr[5] = 2;\n    arr[6] = 4;\n    arr[7] = 6;\n    Graph::add_formula(\u0026mut graph, 0, 5, 7, 13, \u0026mut formulas); // Lines 266-271, 299-309\n    graph.add_range_to_graph(5, 7, 0);\n    graph.recalc(4, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 2); // STDEV ≈ 2 (std dev of [2,4,6])\n}\n\n// #[test]\n// fn test_recalc_empty_range() {\n//     let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(16);\n//     Graph::add_formula(\u0026mut graph, 0, 5, 5, 12, \u0026mut formulas); // Lines 266-271, 280-281\n//     graph.add_range_to_graph(5, 5, 0);\n//     graph.recalc(4, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n//     assert_eq!(arr[0], i32::MIN);\n// }\n\n#[test]\nfn test_recalc_sleep_self_reference() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    arr[0] = 1;\n    Graph::add_formula(\u0026mut graph, 0, 0, 1, 14, \u0026mut formulas); // Lines 322-323, 337\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 1);\n}\n\n#[test]\nfn test_recalc_constant_cell_division() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    arr[1] = 2;\n    Graph::add_formula(\u0026mut graph, 0, 10, 1, 15, \u0026mut formulas); // Lines 344-345, 353, 355-356\n    graph.add_edge(0, 1);\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], 5); // 10/2\n}\n\n#[test]\nfn test_recalc_invalid_formula_type() {\n    let (mut graph, mut arr, mut formulas, mut has_cycle) = setup(5);\n    formulas[0] = Formula { op_type: 99, op_info1: 0, op_info2: 0 }; // Lines 362, 364-367\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n    assert_eq!(arr[0], i32::MIN);\n}\n","traces":[{"line":4,"address":[161680,161963],"length":1,"stats":{"Line":12}},{"line":5,"address":[161709],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","parser_ext_tests.rs"],"content":"use sheet::function_ext::{Cell, CellValue};\nuse sheet::graph_ext::{Formula, Graph, State};\nuse sheet::parser_ext::{autofill, cell_parser, detect_pattern, generate_sequence, parser};\nuse sheet::util_ext::{arithmetic_eval, return_optype};\n// use sheet::function_ext::{Cell, CellValue};\n\n#[test]\nfn test_arithmetic_eval_int_sub() {\n    let c1 = Cell::new_int(10);\n    let c2 = Cell::new_int(3);\n    let result = arithmetic_eval(c1, c2, '-');\n    assert_eq!(result.value, CellValue::Int(7));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_div_exact() {\n    let c1 = Cell::new_int(8);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Int(4));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_div_non_exact() {\n    let c1 = Cell::new_int(7);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Float(3.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_div_by_zero() {\n    let c1 = Cell::new_float(5.0);\n    let c2 = Cell::new_float(0.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_mixed_float_int_add() {\n    let c1 = Cell::new_int(4);\n    let c2 = Cell::new_float(3.5);\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::Float(7.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_invalid_cell() {\n    let mut c1 = Cell::new_int(5);\n    let c2 = Cell::new_int(5);\n    c1.is_valid = false;\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_invalid_op() {\n    let c1 = Cell::new_string(\"Hello\".into());\n    let c2 = Cell::new_string(\"World\".into());\n    let result = arithmetic_eval(c1, c2, '*');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_return_optype_mixed_cases() {\n    assert_eq!(return_optype('+'), 1);\n    assert_eq!(return_optype('-'), 2);\n    assert_eq!(return_optype('*'), 3);\n    assert_eq!(return_optype('/'), 4);\n    assert_eq!(return_optype('x'), -1);\n    assert_eq!(return_optype('='), -1);\n}\n\n#[test]\nfn test_arithmetic_eval_float_minus_int() {\n    let c1 = Cell::new_float(10.5);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '-');\n    assert_eq!(result.value, CellValue::Float(8.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_concat() {\n    let c1 = Cell::new_string(\"Hi \".to_string());\n    let c2 = Cell::new_string(\"there\".to_string());\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::String(\"Hi there\".to_string()));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_float_div() {\n    let c1 = Cell::new_int(7);\n    let c2 = Cell::new_float(2.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Float(3.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_float_mul() {\n    let c1 = Cell::new_float(2.5);\n    let c2 = Cell::new_float(2.0);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Float(5.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_subtract_should_fail() {\n    let c1 = Cell::new_string(\"Test\".into());\n    let c2 = Cell::new_string(\"Case\".into());\n    let result = arithmetic_eval(c1, c2, '-');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_mixed_float_int_div_zero() {\n    let c1 = Cell::new_int(10);\n    let c2 = Cell::new_float(0.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_int_invalid_op() {\n    let c1 = Cell::new_float(2.5);\n    let c2 = Cell::new_int(3);\n    let result = arithmetic_eval(c1, c2, '^');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_div_float() {\n    let c1 = Cell::new_float(9.0);\n    let c2 = Cell::new_float(3.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Float(3.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_mul_int() {\n    let c1 = Cell::new_int(6);\n    let c2 = Cell::new_int(7);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Int(42));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_concat_spaces() {\n    let c1 = Cell::new_string(\"   \".into());\n    let c2 = Cell::new_string(\"More\".into());\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::String(\"   More\".to_string()));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_mixed_float_int_mul() {\n    let c1 = Cell::new_int(3);\n    let c2 = Cell::new_float(4.0);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Float(12.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_plus_float() {\n    let c1 = Cell::new_float(1.5);\n    let c2 = Cell::new_float(2.5);\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::Float(4.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_add_float_should_fail() {\n    let c1 = Cell::new_string(\"Number: \".into());\n    let c2 = Cell::new_float(3.14);\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_string_non_add() {\n    let c1 = Cell::new_string(\"hello\".into());\n    let c2 = Cell::new_string(\"world\".into());\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_int_zero_denominator() {\n    let c1 = Cell::new_float(3.5);\n    let c2 = Cell::new_int(0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_invalid_combo() {\n    let c1 = Cell::new_float(1.2);\n    let c2 = Cell::new_string(\"abc\".into());\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n#[test]\nfn test_cell_parser_start_ge_end() {\n    let result = cell_parser(\"A1\", 10, 10, 2, 1);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cell_parser_letter_after_digit() {\n    let result = cell_parser(\"A1B\", 10, 10, 0, 2);\n    assert!(result.is_err()); // A1B is invalid\n}\n\n#[test]\nfn test_cell_parser_invalid_characters() {\n    let result = cell_parser(\"A$\", 10, 10, 0, 1);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cell_parser_out_of_bounds() {\n    let result = cell_parser(\"Z100\", 5, 5, 0, 3); // Assuming Z100 \u003e max rows\n    assert!(result.is_err());\n}\n#[test]\nfn test_detect_pattern_ap() {\n    assert_eq!(detect_pattern(\u0026[2, 4, 6, 8]), Some(\"AP\".to_string()));\n}\n\n#[test]\nfn test_detect_pattern_gp() {\n    assert_eq!(detect_pattern(\u0026[2, 4, 8, 16]), Some(\"GP\".to_string()));\n}\n\n#[test]\nfn test_detect_pattern_fib() {\n    assert_eq!(detect_pattern(\u0026[1, 1, 2, 3]), Some(\"FIB\".to_string()));\n}\n\n// #[test]\n// fn test_detect_pattern_const() {\n//     assert_eq!(detect_pattern(\u0026[5, 5, 5, 5]), Some(\"CONST\".to_string()));\n// }\n\n#[test]\nfn test_detect_pattern_none() {\n    assert_eq!(detect_pattern(\u0026[1, 2, 4, 7]), None);\n}\n#[test]\nfn test_generate_sequence_ap() {\n    let seq = generate_sequence(\u0026[1, 2, 3, 4], \"AP\", 7);\n    assert_eq!(seq, vec![1, 2, 3, 4, 5, 6, 7]);\n}\n\n#[test]\nfn test_generate_sequence_gp() {\n    let seq = generate_sequence(\u0026[2, 4, 8, 16], \"GP\", 6);\n    assert_eq!(seq, vec![2, 4, 8, 16, 32, 64]);\n}\n\n#[test]\nfn test_generate_sequence_fib() {\n    let seq = generate_sequence(\u0026[1, 1, 2, 3], \"FIB\", 8);\n    assert_eq!(seq, vec![1, 1, 2, 3, 5, 8, 13, 21]);\n}\n\n#[test]\nfn test_generate_sequence_const() {\n    let seq = generate_sequence(\u0026[7, 7, 7, 7], \"CONST\", 6);\n    assert_eq!(seq, vec![7, 7, 7, 7, 7, 7]);\n}\n#[test]\nfn test_autofill_invalid_column() {\n    let mut arr = vec![Cell::default(); 100];\n    let result = autofill(\"ZZ\", 5, 5, 5, \u0026mut arr);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_autofill_insufficient_data() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(1);\n    arr[5] = Cell::new_int(2);\n    let result = autofill(\"A\", 10, 10, 10, \u0026mut arr);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_autofill_invalid_type_in_column() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_string(\"bad\".to_string());\n    arr[10] = Cell::new_int(2);\n    let result = autofill(\"A\", 10, 10, 10, \u0026mut arr);\n    assert!(result.is_err());\n}\n#[test]\nfn test_cell_parser_invalid_range() {\n    use sheet::parser_ext::cell_parser;\n    let result = cell_parser(\"A1\", 10, 10, 2, 1); // start \u003e end\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_cell_parser_letters_after_digits() {\n    use sheet::parser_ext::cell_parser;\n    let result = cell_parser(\"1A\", 10, 10, 0, 1); // Invalid format\n    assert!(result.is_err());\n}\n// #[test]\n// fn test_cell_parser_invalid_character() {\n//     use sheet::parser_ext::cell_parser;\n//     let result = cell_parser(\"A!\", 10, 10, 0, 1); // `!` is invalid\n//     assert!(result.is_err());\n// }\n\n#[test]\nfn test_cell_parser_lower_bound() {\n    let result = cell_parser(\"A1\", 10, 10, 0, 1); // valid lower bound\n    assert_eq!(result.unwrap(), 0); // Cell 0\n}\n\n// #[test]\n// fn test_cell_parser_upper_bound() {\n//     let result = cell_parser(\"J10\", 10, 10, 0, 3); // valid upper\n//     assert_eq!(result.unwrap(), 99); // (9 * 10 + 9)\n// }\n#[test]\nfn test_detect_pattern_empty_input() {\n    assert_eq!(detect_pattern(\u0026[]), None);\n}\n\n#[test]\nfn test_detect_pattern_less_than_4() {\n    assert_eq!(detect_pattern(\u0026[1, 2, 3]), None);\n}\n#[test]\nfn test_generate_sequence_invalid_pattern() {\n    let seq = generate_sequence(\u0026[1, 2, 3, 4], \"XYZ\", 6);\n    assert_eq!(seq.len(), 4); // Should not extend\n}\n\n#[test]\nfn test_autofill_ap_valid() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(1);\n    arr[10] = Cell::new_int(2);\n    arr[20] = Cell::new_int(3);\n    arr[30] = Cell::new_int(4);\n    let result = autofill(\"A\", 10, 10, 4, \u0026mut arr);\n    assert!(result.is_ok());\n    assert_eq!(arr[40], Cell::new_int(5));\n    assert_eq!(arr[50], Cell::new_int(6));\n}\n#[test]\nfn test_parser_valid_expression() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut state = State::new();\n    state.num_cells = 100;\n\n    let result = parser(\"B1=3\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert_eq!(result, Ok(()));\n    assert_eq!(arr[1], Cell::new_int(3));\n}\n#[test]\nfn test_autofill_gp_valid() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(2);\n    arr[10] = Cell::new_int(4);\n    arr[20] = Cell::new_int(8);\n    arr[30] = Cell::new_int(16);\n    let result = sheet::parser_ext::autofill(\"A\", 10, 10, 4, \u0026mut arr);\n    assert!(result.is_ok());\n    assert_eq!(arr[40], Cell::new_int(32));\n    assert_eq!(arr[50], Cell::new_int(64));\n}\n\n#[test]\nfn test_autofill_const_valid() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(5);\n    arr[10] = Cell::new_int(5);\n    arr[20] = Cell::new_int(5);\n    arr[30] = Cell::new_int(5);\n    let result = sheet::parser_ext::autofill(\"A\", 10, 10, 4, \u0026mut arr);\n    assert!(result.is_ok());\n    assert_eq!(arr[40], Cell::new_int(5));\n    assert_eq!(arr[50], Cell::new_int(5));\n}\n\n#[test]\nfn test_autofill_fib_valid() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(1);\n    arr[10] = Cell::new_int(1);\n    arr[20] = Cell::new_int(2);\n    arr[30] = Cell::new_int(3);\n    let result = sheet::parser_ext::autofill(\"A\", 10, 10, 4, \u0026mut arr);\n    assert!(result.is_ok());\n    assert_eq!(arr[40], Cell::new_int(5));\n    assert_eq!(arr[50], Cell::new_int(8));\n}\n#[test]\nfn test_parser_const_assignment() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut formula_array = vec![Formula::default(); 100];\n    let result =\n        parser(\"A1=5\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut State::new());\n    assert!(result.is_ok());\n\n    assert_eq!(arr[0], Cell::new_int(5));\n}\n#[test]\nfn test_parser_binary_op() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut formula_array = vec![Formula::default(); 100];\n    arr[1] = Cell::new_int(4);\n    let result =\n        parser(\"A1=A2+3\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut State::new());\n    assert!(result.is_ok());\n}\n#[test]\nfn test_parser_sum_function() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut formula_array = vec![Formula::default(); 100];\n    arr[1] = Cell::new_int(4);\n    arr[2] = Cell::new_int(5);\n    arr[3] = Cell::new_int(6);\n    let result = parser(\n        \"A1=SUM(B1:D1)\",\n        10,\n        10,\n        \u0026mut arr,\n        \u0026mut graph,\n        \u0026mut formula_array,\n        \u0026mut State::new(),\n    );\n    assert!(result.is_ok());\n}\n#[test]\nfn test_parser_string_assignment() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut formula_array = vec![Formula::default(); 100];\n    let result =\n        parser(\"A1=\\\"hello\\\"\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut State::new());\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_string(\"hello\".to_string()));\n}\n#[test]\nfn test_parser_invalid_function_name() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=BOGUS(B1:B3)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_err());\n}\n#[test]\nfn test_parser_float_assignment() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result = parser(\"A1=3.14\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_float(3.14));\n}\n\n#[test]\nfn test_parser_const_division_formula() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result = parser(\"A1=10/2\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(5));\n}\n#[test]\nfn test_parser_float_division_formula() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result = parser(\"A1=7/2\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_float(3.5));\n}\n#[test]\nfn test_parser_stdev_with_invalid_type() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_string(\"invalid\".into());\n    arr[2] = Cell::new_int(5);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=STDEV(B1:B2)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0].is_valid, false);\n}\n\n#[test]\nfn test_parser_sleep_self_value_cycle() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[0] = Cell::new_int(1);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    state.num_cells = 100;\n\n    let result =\n        parser(\"A1=SLEEP(A1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_err());\n    assert!(state.has_cycle);\n}\n\n// #[test]\n// fn test_parser_trimmed_input() {\n//     let mut arr = vec![Cell::default(); 100];\n//     let mut formula_array = vec![Formula::default(); 100];\n//     let mut graph = Graph::new(100);\n//     let mut state = State::new();\n\n//     let result = parser(\"  A1=4+5\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n//     assert!(result.is_ok());\n//     assert_eq!(arr[0], Cell::new_int(9));\n// }\n#[test]\nfn test_parser_max_empty_range() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=MAX(B1:B1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert!(!arr[0].is_valid);\n}\n#[test]\nfn test_parser_avg_empty_range() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=AVG(B1:B1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert!(!arr[0].is_valid);\n}\n#[test]\nfn test_parser_cell_to_cell_assignment() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[11] = Cell::new_int(99); // B2\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result = parser(\"A1=B2\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(99));\n}\n#[test]\nfn test_parser_sleep_indirect_cell() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(0); // B1\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=SLEEP(B1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(0));\n}\n\n#[test]\nfn test_parser_min_range() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(10);\n    arr[2] = Cell::new_int(5);\n    arr[3] = Cell::new_int(15);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=MIN(B1:D1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(5));\n}\n\n#[test]\nfn test_parser_avg_range() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(10);\n    arr[2] = Cell::new_int(20);\n    arr[3] = Cell::new_int(30);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=AVG(B1:D1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(20));\n}\n\n#[test]\nfn test_parser_stdev_valid_range() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(2);\n    arr[2] = Cell::new_int(4);\n    arr[3] = Cell::new_int(4);\n    arr[4] = Cell::new_int(4);\n    arr[5] = Cell::new_int(5);\n    arr[6] = Cell::new_int(5);\n    arr[7] = Cell::new_int(7);\n    arr[8] = Cell::new_int(9);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n\n    let result =\n        parser(\"A1=STDEV(B1:I1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert!(arr[0].is_valid);\n    // We don’t assert exact float due to rounding, but you could use pattern matching if needed.\n}\n#[test]\nfn test_parser_invalid_cell_assignment() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"5=5\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_parser_negative_constant() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=-5\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state);\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(-5));\n}\n\n#[test]\nfn test_parser_positive_constant() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=+5\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 204, 207, 210\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(5));\n}\n\n#[test]\nfn test_parser_empty_string() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=\\\"\\\"\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 234-237\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_string(\"\".to_string()));\n}\n\n#[test]\nfn test_parser_autofill_missing_length() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"=autofill A\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 493-498\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Usage: autofill \u003ccolumn\u003e \u003clength\u003e\");\n}\n\n#[test]\nfn test_parser_no_digit_before_operator() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=+B1\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 521-524, 526-530\n    assert!(result.is_ok()); // Should parse as value function\n}\n\n#[test]\nfn test_parser_unknown_function() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=XYZ(B1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 550, 552-555\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Unknown function\");\n}\n#[test]\nfn test_parser_sleep_with_prior_formula() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    formula_array[0] = Formula { op_type: 1, op_info1: 1, op_info2: 2 };\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"A1=SLEEP(1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 467-470\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_parser_sleep_missing_paren() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=SLEEP(1\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 472-473\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Missing closing parenthesis\");\n}\n\n// #[test]\n// fn test_parser_sleep_invalid_cell() {\n//     let mut arr = vec![Cell::default(); 100];\n//     let mut formula_array = vec![Formula::default(); 100];\n//     let mut graph = Graph::new(100);\n//     let mut state = State::new();\n//     let result = parser(\"A1=SLEEP(Z1a)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Line 476\n//     assert!(result.is_ok()); // Falls back to constant parsing\n// }\n\n#[test]\nfn test_parser_sleep_constant() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"A1=SLEEP(2)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 485-487\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(2));\n}\n\n#[test]\nfn test_parser_range_with_prior_formula() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    formula_array[0] = Formula { op_type: 1, op_info1: 1, op_info2: 2 };\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"A1=MIN(B1:C1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 437-439\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_parser_missing_paren() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"A1=MIN(B1:C1\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 443-444\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Missing closing parenthesis\");\n}\n\n#[test]\nfn test_parser_missing_colon() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result =\n        parser(\"A1=MIN(B1 C1)\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Line 445\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Missing colon\");\n}\n// #[test]\n// fn test_parser_multiple_operators() {\n//     let mut arr = vec![Cell::default(); 100];\n//     let mut formula_array = vec![Formula::default(); 100];\n//     let mut graph = Graph::new(100);\n//     let mut state = State::new();\n//     let result = parser(\"A1=2++3\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 345-346, 348\n//     assert!(result.is_err());\n//     assert_eq!(result.unwrap_err(), \"No valid operator found\");\n// }\n\n#[test]\nfn test_parser_positive_first_operand() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=+2+3\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 364, 366, 368\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(5));\n}\n\n#[test]\nfn test_parser_positive_second_operand() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=2+3\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 378-380, 382-385\n                                                                                                 // assert!(result.is_err());\n                                                                                                 // assert_eq!(result.unwrap_err(), \"No valid operator found\");\n    assert!(result.is_ok());\n}\n\n#[test]\nfn test_parser_constant_cell_division() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(5);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=10/B1\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 423, 425-426\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(2));\n}\n\n#[test]\nfn test_parser_cell_cell_subtraction() {\n    let mut arr = vec![Cell::default(); 100];\n    arr[1] = Cell::new_int(10);\n    arr[2] = Cell::new_int(3);\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=B1-C1\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Line 429\n    assert!(result.is_ok());\n    assert_eq!(arr[0], Cell::new_int(7));\n}\n\n#[test]\nfn test_parser_invalid_cell_reference() {\n    let mut arr = vec![Cell::default(); 100];\n    let mut formula_array = vec![Formula::default(); 100];\n    let mut graph = Graph::new(100);\n    let mut state = State::new();\n    let result = parser(\"A1=Z100\", 10, 10, \u0026mut arr, \u0026mut graph, \u0026mut formula_array, \u0026mut state); // Lines 274-275\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err(), \"Cell reference out of bounds\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","parser_test.rs"],"content":"// use sheet::parser::{cell_parser};\n\n// #[test]\n// fn test_cell_parser(){\n//     // Test cases for the cell_parser function\n//     assert_eq!(cell_parser(\"A1\", 10, 10, 0, 1), Ok(0));\n//     assert_eq!(cell_parser(\"B2\", 10, 10, 0, 1), Ok(11));\n//     assert_eq!(cell_parser(\"C3\", 10, 10, 0, 1), Ok(22));\n//     assert_eq!(cell_parser(\"D4\", 10, 10, 0, 1), Ok(33));\n//     assert_eq!(cell_parser(\"E5\", 10, 10, 0, 1), Ok(44));\n//     assert_eq!(cell_parser(\"AA1\", 100, 100, 0, 2), Ok(26));\n//     assert_eq!(cell_parser(\"B10\", 10, 20, 0, 2), Ok(91));\n//     assert_eq!(\n//         cell_parser(\"A1A\", 10, 10, 0, 2),\n//         Err(\"Letters after digits not allowed\")\n//     );\n//     assert_eq!(\n//         cell_parser(\"A#1\", 10, 10, 0, 2),\n//         Err(\"Invalid character in cell reference\")\n//     );\n//     assert_eq!(\n//         cell_parser(\"A1\", 10, 10, 0, 5),\n//         Err(\"Invalid cell reference\")\n//     );\n//     assert_eq!(\n//         cell_parser(\"Z100\", 5, 5, 0, 3),\n//         Err(\"Cell reference out of bounds\")\n//     );\n//     assert_eq!(\n//         cell_parser(\"a1\", 10, 10, 0, 1),\n//         Err(\"Invalid character in cell reference\")\n//     );\n//     assert_eq!(\n//         cell_parser(\"A1\", 10, 10, 2, 1),\n//         Err(\"Invalid cell reference\")\n//     );\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","parser_tests.rs"],"content":"use sheet::graph::{Formula, Graph};\nuse std::i32;\n\nfn setup(cells: usize) -\u003e (Graph, Vec\u003ci32\u003e, Vec\u003cFormula\u003e) {\n    (Graph::new(cells), vec![0; cells], vec![Formula::default(); cells])\n}\n\n#[test]\nfn test_parser_const_assignment() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 42);\n}\n\n#[test]\nfn test_parser_cell_reference() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 30; // B1\n    let status = sheet::parser::parser(\"A1=B1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 30);\n}\n\n#[test]\nfn test_parser_arithmetic_const_expr() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=3+7\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 10);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_const_expr() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 9; // B1\n    let status = sheet::parser::parser(\"A1=B1+6\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 15);\n}\n\n#[test]\nfn test_parser_arithmetic_const_cell_expr() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[2] = 3; // C1\n    let status = sheet::parser::parser(\"A1=6/C1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 2);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_cell_expr_multiplication() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 5; // B1\n    arr[2] = 2; // C1\n    let status = sheet::parser::parser(\"A1=B1*C1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 10);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_cell_expr_addition() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 5; // B1\n    arr[2] = 2; // C1\n    let status = sheet::parser::parser(\"A1=B1+C1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 7);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_cell_expr_subtraction() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 5; // B1\n    arr[2] = 2; // C1\n    let status = sheet::parser::parser(\"A1=B1-C1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 3);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_cell_expr_division() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10; // B1\n    arr[2] = 2; // C1\n    let status = sheet::parser::parser(\"A1=B1/C1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 5);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_negative_constant() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=-10\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], -10);\n}\n\n#[test]\nfn test_parser_arithmetic_const_addition() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10+5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 15);\n}\n\n#[test]\nfn test_parser_arithmetic_const_subtraction() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10-5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 5);\n}\n\n#[test]\nfn test_parser_arithmetic_const_multiplication() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10*5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 50);\n}\n\n#[test]\nfn test_parser_arithmetic_const_division() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10/5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 2);\n}\n\n#[test]\nfn test_parser_arithmetic_cell_unknown_operator() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10@5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_arithmetic_divide_by_zero() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10/0\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], i32::MIN);\n}\n\n#[test]\nfn test_parser_sleep_with_value() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SLEEP(0)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 0);\n}\n\n#[test]\nfn test_parser_sleep_with_cell_ref() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 3; // B1\n    let status = sheet::parser::parser(\"A1=SLEEP(B1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 3);\n}\n\n#[test]\nfn test_parser_invalid_sleep_format() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SLEEP(1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_invalid_cell_name() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=XX\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_invalid_syntax() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, -1);\n}\n\n// #[test]\n// fn test_formula_const_div_by_zero() {\n//     let (mut graph, mut arr, mut formulas) = setup(5);\n//     Graph::add_formula(\u0026mut graph, 0, 10, 0, 4, \u0026mut formulas);\n//     let mut has_cycle = false;\n//     graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut has_cycle);\n//     assert_eq!(arr[0], i32::MIN);\n// }\n\n#[test]\nfn test_topo_sort_with_range_dependencies() {\n    let (mut graph, mut arr, mut formulas) = setup(25);\n    arr[6] = 10;\n    arr[11] = 14;\n    Graph::add_formula(\u0026mut graph, 0, 6, 11, 12, \u0026mut formulas);\n    graph.add_range_to_graph(6, 11, 0);\n    graph.recalc(5, \u0026mut arr, 0, \u0026mut formulas, \u0026mut false);\n    assert_eq!(arr[0], 24);\n}\n// #[test]\n// fn test_parser_lowercase_cell_name() {\n//     let (mut graph, mut arr, mut formulas) = setup(5);\n//     let status = sheet::parser::parser(\"a1=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 11, 84-86, 100\n//     assert_eq!(status, -1);\n// }\n\n#[test]\nfn test_parser_invalid_char_in_cell() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A@=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 84-86, 100\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_letter_after_digit() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1B=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 84-86\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_multi_digit_row() {\n    let (mut graph, mut arr, mut formulas) = setup(25);\n    arr[5 * 2] = 99; // A3 (row 3, index 10)\n    let status = sheet::parser::parser(\"A1=A3\", 5, 5, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 96, 98\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 99);\n}\n\n#[test]\nfn test_parser_out_of_bounds_cell() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"F1=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 113-117\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_negative_row() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A0=42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 113-117\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_invalid_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=A2\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 41, 61, 131, 133-136\n    assert_eq!(status, -1); // A2 out of bounds (row=2 \u003e r=1)\n}\n#[test]\nfn test_parser_empty_input() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 166-167\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_no_equals_sign() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1 42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 169-170, 183\n    assert_eq!(status, -1);\n}\n\n// #[test]\n// fn test_parser_positive_constant() {\n//     let (mut graph, mut arr, mut formulas) = setup(5);\n//     let status = sheet::parser::parser(\"A1=+42\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 205, 209-210, 212, 216, 221\n\n// }\n\n// #[test]\n// fn test_parser_negative_cell_reference() {\n//     let (mut graph, mut arr, mut formulas) = setup(5);\n//     arr[1] = 10; // B1\n//     let status = sheet::parser::parser(\"A1=-B1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 205, 207, 209, 226, 230, 233\n//     assert_eq!(status, 1);\n//     assert_eq!(arr[0], -10);\n// }\n\n#[test]\nfn test_parser_arithmetic_subtraction() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=10-3\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 241, 243-246, 249\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 7);\n}\n\n#[test]\nfn test_parser_arithmetic_multiplication() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=4*5\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 241, 243-246, 253-254\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 20);\n}\n\n#[test]\nfn test_parser_invalid_operator() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=2^3\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 241, 243-246, 258-259\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_sleep_missing_paren() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SLEEP(1\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 261-263\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_unknown_function() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=XYZ(1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 261, 267-268\n    assert_eq!(status, -1);\n}\n#[test]\nfn test_parser_sum_missing_colon() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SUM(B1 C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 289-293\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_sum_invalid_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SUM(B1:Z1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 294-296\n    assert_eq!(status, -1);\n}\n\n#[test]\nfn test_parser_sum_empty_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    let status = sheet::parser::parser(\"A1=SUM(B1:B1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 289-296, 300-301\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 0);\n}\n\n#[test]\nfn test_parser_valid_sum_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10;\n    arr[2] = 20;\n    let status = sheet::parser::parser(\"A1=SUM(B1:C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n    assert_eq!(arr[0], 30);\n}\n\n#[test]\nfn test_parser_valid_stdev_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10;\n    arr[2] = 20;\n    let status =\n        sheet::parser::parser(\"A1=STDEV(B1:C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n}\n\n#[test]\nfn test_parser_valid_average_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10;\n    arr[2] = 20;\n    let status = sheet::parser::parser(\"A1=AVG(B1:C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n}\n\n#[test]\nfn test_parser_valid_min_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10;\n    arr[2] = 20;\n    let status = sheet::parser::parser(\"A1=MIN(B1:C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n}\n\n#[test]\nfn test_parser_valid_max_range() {\n    let (mut graph, mut arr, mut formulas) = setup(5);\n    arr[1] = 10;\n    arr[2] = 20;\n    let status = sheet::parser::parser(\"A1=MAX(B1:C1)\", 5, 1, \u0026mut arr, \u0026mut graph, \u0026mut formulas);\n    assert_eq!(status, 1);\n}\n\n// #[test]\n// fn test_parser_cycle_in_range() {\n//     let (mut graph, mut arr, mut formulas) = setup(25);\n//     arr[6] = 10; // B2\n//     arr[11] = 14; // B3\n//     Graph::add_formula(\u0026mut graph, 6, 0, 0, -1, \u0026mut formulas); // B2 = A1\n//     graph.add_edge(6, 0);\n//     let status = sheet::parser::parser(\"A1=SUM(B2:B3)\", 5, 5, \u0026mut arr, \u0026mut graph, \u0026mut formulas); // Lines 304-310\n//     assert_eq!(status, -1);\n//     assert_eq!(arr[0], 0); // Cycle resets A1\n// }\n","traces":[{"line":4,"address":[161568,161847],"length":1,"stats":{"Line":16}},{"line":5,"address":[161597],"length":1,"stats":{"Line":16}}],"covered":2,"coverable":2},{"path":["/","home","basil","dev","COP290-Rust","rustlab","sheet","tests","utils_ext_tests.rs"],"content":"use sheet::function_ext::{Cell, CellValue};\nuse sheet::util_ext::{arithmetic_eval, return_optype};\n\n#[test]\nfn test_arithmetic_eval_int_sub() {\n    let c1 = Cell::new_int(10);\n    let c2 = Cell::new_int(3);\n    let result = arithmetic_eval(c1, c2, '-');\n    assert_eq!(result.value, CellValue::Int(7));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_div_exact() {\n    let c1 = Cell::new_int(8);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Int(4));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_div_non_exact() {\n    let c1 = Cell::new_int(7);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Float(3.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_div_by_zero() {\n    let c1 = Cell::new_float(5.0);\n    let c2 = Cell::new_float(0.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_mixed_float_int_add() {\n    let c1 = Cell::new_int(4);\n    let c2 = Cell::new_float(3.5);\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::Float(7.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_invalid_cell() {\n    let mut c1 = Cell::new_int(5);\n    let c2 = Cell::new_int(5);\n    c1.is_valid = false;\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_invalid_op() {\n    let c1 = Cell::new_string(\"Hello\".into());\n    let c2 = Cell::new_string(\"World\".into());\n    let result = arithmetic_eval(c1, c2, '*');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_return_optype_mixed_cases() {\n    assert_eq!(return_optype('+'), 1);\n    assert_eq!(return_optype('-'), 2);\n    assert_eq!(return_optype('*'), 3);\n    assert_eq!(return_optype('/'), 4);\n    assert_eq!(return_optype('x'), -1);\n    assert_eq!(return_optype('='), -1);\n}\n\n#[test]\nfn test_arithmetic_eval_float_minus_int() {\n    let c1 = Cell::new_float(10.5);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '-');\n    assert_eq!(result.value, CellValue::Float(8.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_concat() {\n    let c1 = Cell::new_string(\"Hi \".to_string());\n    let c2 = Cell::new_string(\"there\".to_string());\n    let result = arithmetic_eval(c1, c2, '+');\n    assert_eq!(result.value, CellValue::String(\"Hi there\".to_string()));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_float_div() {\n    let c1 = Cell::new_int(7);\n    let c2 = Cell::new_float(2.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert_eq!(result.value, CellValue::Float(3.5));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_float_mul() {\n    let c1 = Cell::new_float(2.5);\n    let c2 = Cell::new_float(2.0);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Float(5.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_subtract_should_fail() {\n    let c1 = Cell::new_string(\"Test\".into());\n    let c2 = Cell::new_string(\"Case\".into());\n    let result = arithmetic_eval(c1, c2, '-');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_mixed_float_int_div_zero() {\n    let c1 = Cell::new_int(10);\n    let c2 = Cell::new_float(0.0);\n    let result = arithmetic_eval(c1, c2, '/');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_int_invalid_op() {\n    let c1 = Cell::new_float(2.5);\n    let c2 = Cell::new_int(3);\n    let result = arithmetic_eval(c1, c2, '^');\n    assert!(!result.is_valid);\n}\n#[test]\nfn test_arithmetic_eval_int_mul() {\n    let c1 = Cell::new_int(3);\n    let c2 = Cell::new_int(4);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Int(12));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_invalid_op() {\n    let c1 = Cell::new_int(3);\n    let c2 = Cell::new_int(4);\n    let result = arithmetic_eval(c1, c2, '^');\n    assert!(!result.is_valid);\n}\n\n// #[test]\n// fn test_arithmetic_eval_float_add_float() {\n//     let c1 = Cell::new_float(1.1);\n//     let c2 = Cell::new_float(2.2);\n//     let result = arithmetic_eval(c1, c2, '+');\n//     assert_eq!(result.value, CellValue::Float(3.3));\n//     assert!(result.is_valid);\n// }\n\n#[test]\nfn test_arithmetic_eval_float_invalid_op() {\n    let c1 = Cell::new_float(1.0);\n    let c2 = Cell::new_float(2.0);\n    let result = arithmetic_eval(c1, c2, '%');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_mul_int() {\n    let c1 = Cell::new_float(1.5);\n    let c2 = Cell::new_int(2);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Float(3.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_mul_float() {\n    let c1 = Cell::new_int(2);\n    let c2 = Cell::new_float(1.5);\n    let result = arithmetic_eval(c1, c2, '*');\n    assert_eq!(result.value, CellValue::Float(3.0));\n    assert!(result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_string_unknown_op() {\n    let c1 = Cell::new_string(\"foo\".to_string());\n    let c2 = Cell::new_string(\"bar\".to_string());\n    let result = arithmetic_eval(c1, c2, '%');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_int_string() {\n    let c1 = Cell::new_int(42);\n    let c2 = Cell::new_string(\"oops\".into());\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_float_string() {\n    let c1 = Cell::new_float(3.14);\n    let c2 = Cell::new_string(\"bad\".into());\n    let result = arithmetic_eval(c1, c2, '*');\n    assert!(!result.is_valid);\n}\n\n#[test]\nfn test_arithmetic_eval_debug_log_on_invalid_combo() {\n    let c1 = Cell::new_string(\"bad\".into());\n    let c2 = Cell::new_int(1);\n    let result = arithmetic_eval(c1, c2, '+');\n    assert!(!result.is_valid);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","ws_client","src","bin","ws_client_bin.rs"],"content":"//! The binary entry point for the WebSocket client application.\n//!\n//! This module provides the main function that bootstraps the Leptos application\n//! and mounts the root `App` component to the web page's body.\n\n#![allow(non_snake_case)]\nuse leptos::*;\nuse ws_client::App;\n\n/// The main entry point for the WebSocket client application.\n///\n/// This function:\n/// 1. Initializes the Leptos runtime\n/// 2. Mounts the root `App` component to the document body\n/// 3. Starts the reactive system for handling UI updates\nfn main() {\n    mount_to_body(|| view! { \u003cApp /\u003e})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","basil","dev","COP290-Rust","rustlab","ws_client","src","lib.rs"],"content":"//! A WebSocket client implementation for real-time collaborative grid editing.\n//!\n//! This module provides a WebSocket client that connects to a server, manages a shared grid,\n//! and handles real-time updates from other clients. It uses Leptos for the UI and implements\n//! a simple CRDT-based conflict resolution strategy.\n\nuse crate::wasm_bindgen::closure::Closure;\nuse crdt::{CLIENT_LIST, ClientListEvent, Column, Event, GRID_UPDATE, GridUpdateEvent, Row};\nuse leptos::wasm_bindgen::JsCast;\nuse leptos::{ev::SubmitEvent, html::Input, *};\nuse rand::prelude::*;\nuse web_sys::WebSocket;\n\n/// Represents a change event in the grid.\n///\n/// This struct is used to communicate UI changes to the Leptos effect system\n/// and to send updates to other connected clients.\n#[derive(Debug, Clone)]\npub struct ChangeEvent {\n    /// The row index where the change occurred\n    pub row: usize,\n    /// The column index where the change occurred\n    pub column: usize,\n    /// The new value entered in the cell\n    pub value: String,\n}\n\n/// The main application component that manages the WebSocket connection and grid state.\n///\n/// This component:\n/// 1. Establishes the WebSocket connection\n/// 2. Manages the list of connected clients\n/// 3. Handles grid updates and synchronization\n/// 4. Renders the UI components\n#[component]\npub fn App() -\u003e impl IntoView {\n    let (ws, set_ws) = create_signal::\u003cOption\u003cWebSocket\u003e\u003e(None);\n    let (clients, set_clients) = create_signal(vec![]);\n    let (data_change, set_data_change) = create_signal::\u003cOption\u003cChangeEvent\u003e\u003e(None);\n    let (data, set_data) = create_signal(init_data());\n    let (name, set_name) = create_signal(String::default());\n\n    // Initialize WebSocket connection\n    create_effect(move |_| {\n        if ws.get().is_none() {\n            let ws = WebSocket::new(\"ws://localhost:3030\").expect(\"Failed to create WebSocket\");\n            // ws.set_binary_type(web_sys::BinaryType::Blob);\n\n            // Set up message handler\n            let set_clients_clone = set_clients;\n            let set_data_clone = set_data;\n\n            let onmessage = Closure::wrap(Box::new(move |ev: web_sys::MessageEvent| {\n                if let Some(msg) = ev.data().as_string() {\n                    if let Ok(evt) = serde_json::from_str::\u003cEvent\u003e(\u0026msg) {\n                        if evt.event_type == CLIENT_LIST {\n                            if let Ok(cl) = serde_json::from_value::\u003cClientListEvent\u003e(evt.data) {\n                                set_clients_clone.update(|c| {\n                                    *c = cl\n                                        .clients\n                                        .into_iter()\n                                        .map(|c| c.name)\n                                        .collect::\u003cVec\u003cString\u003e\u003e()\n                                });\n                            }\n                        } else if evt.event_type == GRID_UPDATE {\n                            if let Ok(m) = serde_json::from_value::\u003cGridUpdateEvent\u003e(evt.data) {\n                                // simple last-write-wins CRDT merge logic\n                                set_data_clone.update(|d| {\n                                    for i in 0..d.len() {\n                                        for j in 0..d[0].columns.len() {\n                                            let local = \u0026d[i].columns[j];\n                                            let remote = \u0026m.grid[i].columns[j];\n\n                                            if local.timestamp \u003e remote.timestamp {\n                                                continue; // local version is newer - nothing to update\n                                            }\n\n                                            if local.timestamp == remote.timestamp \u0026\u0026 random() {\n                                                continue; // timestamps are the same, use one at random\n                                            }\n\n                                            // overwrite local with remote\n                                            d[i].columns[j] = m.grid[i].columns[j].clone();\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n            }) as Box\u003cdyn FnMut(_)\u003e);\n\n            ws.set_onmessage(Some(onmessage.as_ref().unchecked_ref()));\n            onmessage.forget();\n\n            set_ws.set(Some(ws));\n        }\n    });\n\n    // effect for handling the sending of local updates to other clients via the websocket server\n    create_effect(move |_| {\n        if let Some(change) = data_change.get() {\n            set_data_change.update(|dc| *dc = None);\n            set_data.update(|d| {\n                let old = \u0026d[change.row].columns[change.column];\n                let new = Column {\n                    idx: old.idx,\n                    peer: name.get(),\n                    value: change.value,\n                    timestamp: old.timestamp + 1,\n                };\n                d[change.row].columns[change.column] = new;\n            });\n            let d = data.get();\n\n            let data_event = serde_json::to_value(GridUpdateEvent { grid: d, sender: name.get() })\n                .expect(\"can serialize change event\");\n            let serialized = serde_json::to_string(\u0026Event {\n                event_type: GRID_UPDATE.to_owned(),\n                data: data_event,\n            })\n            .expect(\"can be serialized\");\n\n            if let Some(ws) = ws.get() {\n                if ws.ready_state() == WebSocket::OPEN {\n                    ws.send_with_str(\u0026serialized).expect(\"Failed to send message\");\n                }\n            }\n        }\n    });\n\n    view! {\n        \u003cdiv class=\"app\"\u003e\n            \u003cdiv class=\"container\"\u003e\n                \u003cspan class=\"hidden\"\u003e{move || data_change.get().is_some()}\u003c/span\u003e\n                \u003cConnect ws={ws} set_name={set_name} /\u003e\n                \u003cClients clients={clients} /\u003e\n                \u003cGrid data={data} set_data_change={set_data_change} /\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    }\n}\n\n/// A component that handles the initial connection to the WebSocket server.\n///\n/// This component:\n/// 1. Provides a form for users to enter their name\n/// 2. Establishes the initial connection to the server\n/// 3. Sends the INIT event with the user's name\n///\n/// # Props\n/// * `ws` - A signal containing the WebSocket connection\n/// * `set_name` - A signal setter for the user's name\n#[component]\npub fn Connect(ws: ReadSignal\u003cOption\u003cWebSocket\u003e\u003e, set_name: WriteSignal\u003cString\u003e) -\u003e impl IntoView {\n    let (connected, set_connected) = create_signal(false);\n    let name_input: NodeRef\u003cInput\u003e = create_node_ref();\n\n    let submit_handler = move |ev: SubmitEvent| {\n        ev.prevent_default();\n        let name = name_input.get().expect(\"input exists\").value();\n        if let Some(ws) = ws.get() {\n            if ws.ready_state() == WebSocket::OPEN {\n                ws.send_with_str(\u0026format!(\n                    r#\"{{ \"event_type\": \"INIT\", \"data\": {{ \"name\": \"{}\" }} }}\"#,\n                    name\n                ))\n                .expect(\"Failed to send message\");\n                set_connected.update(|c| *c = true);\n                set_name.update(|n| *n = name);\n            }\n        }\n    };\n\n    view! {\n        \u003cdiv class=\"connect\"\u003e\n            \u003cdiv class=\"connect-name\"\u003e\n                \u003cform on:submit=submit_handler\u003e\n                    \u003cspan\u003eName\u003c/span\u003e\n                    \u003cspan\u003e\u003cinput type=\"text\" name=\"name\" node_ref=name_input disabled=move || connected.get() /\u003e\u003c/span\u003e\n                    \u003cspan\u003e\u003cinput type=\"submit\" disabled=move || connected.get() value=\"Connect\" /\u003e\u003c/span\u003e\n                \u003c/form\u003e\n            \u003c/div\u003e\n        \u003c/div\u003e\n    }\n}\n\n/// A component that displays the list of currently connected clients.\n///\n/// # Props\n/// * `clients` - A signal containing the list of connected client names\n#[component]\npub fn Clients(clients: ReadSignal\u003cVec\u003cString\u003e\u003e) -\u003e impl IntoView {\n    view! {\n        \u003cdiv class=\"clients\"\u003e\n            \u003cspan\u003eClients\u003c/span\u003e\n            \u003cul class=\"clients-list\"\u003e\n                \u003cFor\n                    each=move || clients.get()\n                    key=|state| state.clone()\n                    children=|child| view! { \u003cli\u003e{child}\u003c/li\u003e }\n\n                /\u003e\n            \u003c/ul\u003e\n        \u003c/div\u003e\n    }\n}\n\n/// A component that renders and manages the interactive grid.\n///\n/// This component:\n/// 1. Renders a 10x10 grid of input cells\n/// 2. Handles user input and cell value changes\n/// 3. Manages the grid's state and updates\n///\n/// # Props\n/// * `data` - A signal containing the grid data\n/// * `set_data_change` - A signal setter for grid change events\n#[component]\npub fn Grid(\n    data: ReadSignal\u003cVec\u003cRow\u003e\u003e,\n    set_data_change: WriteSignal\u003cOption\u003cChangeEvent\u003e\u003e,\n) -\u003e impl IntoView {\n    view! {\n        \u003cdiv class=\"grid-container\"\u003e\n            \u003ctable class=\"grid\"\u003e\n                \u003cthead\u003e\n                    \u003ctr\u003e\n                        \u003cth\u003e\u003c/th\u003e // Empty corner cell\n                        {(0..10).map(|i| view! {\n                            \u003cth\u003e{char::from_u32(65 + i as u32).unwrap()}\u003c/th\u003e\n                        }).collect_view()}\n                    \u003c/tr\u003e\n                \u003c/thead\u003e\n                \u003ctbody\u003e\n                    \u003cFor\n                        each=move || data.get()\n                        key=|r| r.idx\n                        children=move |row| view! {\n                            \u003ctr\u003e\n                                \u003ctd class=\"row-header\"\u003e{row.idx + 1}\u003c/td\u003e\n                                \u003cFor\n                                    each=move || row.columns.clone()\n                                    key=move |c| format!(\"{}{}\", row.idx, c.idx)\n                                    children=move |col| view! {\n                                        \u003ctd\u003e\n                                            \u003cinput\n                                                type=\"text\"\n                                                on:input=move |ev| {\n                                                    set_data_change.update(|dc| *dc = Some(ChangeEvent {\n                                                        row: row.idx,\n                                                        column: col.idx,\n                                                        value: event_target_value(\u0026ev)\n                                                    }));\n                                                }\n                                                prop:value=move || data.get()[row.idx].columns[col.idx].value.clone()\n                                            /\u003e\n                                        \u003c/td\u003e\n                                    }\n                                /\u003e\n                            \u003c/tr\u003e\n                        }\n                    /\u003e\n                \u003c/tbody\u003e\n            \u003c/table\u003e\n        \u003c/div\u003e\n    }\n}\n\n/// Creates a new column with default values.\n///\n/// # Arguments\n/// * `idx` - The index of the column\n///\n/// # Returns\n/// A new `Column` instance with default values\nfn init_column(idx: usize) -\u003e Column {\n    Column { idx, value: String::default(), timestamp: 0, peer: String::default() }\n}\n\n/// Initializes the grid data structure.\n///\n/// Creates a 10x10 grid with default values for all cells.\n///\n/// # Returns\n/// A vector of `Row` instances representing the initial grid state\npub fn init_data() -\u003e Vec\u003cRow\u003e {\n    (0..10).map(|i| Row { idx: i, columns: (0..10).map(init_column).collect() }).collect()\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>